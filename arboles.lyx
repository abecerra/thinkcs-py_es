#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass book
\use_default_options false
\maintain_unincluded_children false
\language spanish
\language_package none
\inputencoding utf8
\fontencoding default
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 0
\use_package cancel 0
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 0
\use_package mhchem 0
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% LaTeX source for textbook ``How to think like a computer scientist''
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% Copyderecho (c)  2001  Allen B.
 Downey, Jeffrey Elkner, and Chris Meyers.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% Permission is granted to copy, distribute and/or modify this
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% document under the terms of the GNU Free Documentation License,
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% Version 1.1  or any later version published by the Free Software
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% Foundation; with the Invariant Sections being "Contributor List",
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% with no Front-Cover Texts, and with no Back-Cover Texts.
 A copy of
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% the license is included in the section entitled "GNU Free
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% Documentation License".
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% This distribution includes a file named fdl.tex that contains the text
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% of the GNU Free Documentation License.
  If it is missing, you can obtain
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% it from www.gnu.org or by writing to the Free Software Foundation,
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Árboles
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
árbol
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
nodo
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
nodo de un árbol
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
carga
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
referencia incrustada
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
árbol binario
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Como las listas enlazadas, los árboles están compuestos de nodos.
 Una clase muy común es el 
\series bold
árbol binario
\series default
, en el que cada nodo contiene una referencia a otros dos nodos (posiblemente
 nulas).
 Estas referencias se denominan los subárboles izquierdo y derecho.
 Como los nodos de las listas, los nodos de los árboles también contienen
 una carga.
 Un diagrama de estados para los árboles luce así:
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "tree"

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforefig
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
centerline{
\end_layout

\end_inset


\begin_inset Graphics
	filename illustrations/tree1.eps

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterfig
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Para evitar el caos en las figuras, a menudo omitimos los valores 
\family typewriter
None
\family default
.
\end_layout

\begin_layout Standard
El inicio del árbol (al nodo al que 
\family typewriter
árbol
\family default
 se refiere) se denomina 
\series bold
raíz
\series default
.
 Para conservar la metáfora con los árboles, los otros nodos se denominan
 ramas, y los nodos que tienen referencias nulas se llaman 
\series bold
hojas
\series default
.
 Parece extraño el dibujo con la raíz en la parte superior y las hojas en
 la inferior, pero esto es sólo el principio.
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
nodo raíz
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
nodo hoja
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
nodo padre
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
nodo hijo
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
nivel
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Los científicos de la computación también usan otra metáfora---el árbol
 genealógico.
 El nodo raíz se denomina 
\series bold
padre
\series default
 y los nodos a los que se refiere 
\series bold
hijos
\series default
, los nodos que tienen el mismo padre se denominan 
\series bold
hermanos
\series default
.
\end_layout

\begin_layout Standard
Finalmente, hay un vocabulario geométrico para referirse a los árboles.
 Ya mencionamos la distinción entre izquierda y derecha, también se acostumbra
 diferenciar entre 
\begin_inset Quotes eld
\end_inset

arriba
\begin_inset Quotes erd
\end_inset

 (hacia el padre/raíz) y 
\begin_inset Quotes eld
\end_inset

abajo
\begin_inset Quotes erd
\end_inset

 (hacia los hijos/hojas).
 Además, todos los nodos que están a una misma distancia de la raíz comprenden
 un 
\series bold
nivel
\series default
.
\end_layout

\begin_layout Standard
Probablemente no necesitemos estas metáforas para describir los árboles,
 pero se usan extensivamente.
\end_layout

\begin_layout Standard
Como las listas enlazadas, los árboles son estructuras de datos recursivas
 ya que su definición es recursiva.
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
estructuras de datos recursivas
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
estructuras de datos!recursivas
\end_layout

\end_inset


\end_layout

\begin_layout Quote
Un árbol es:
\end_layout

\begin_deeper
\begin_layout Itemize
el árbol vacío, representado por 
\family typewriter
None
\family default
, o
\end_layout

\begin_layout Itemize
Un nodo que contiene una referencia a un objeto y referencias a otros aŕboles.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
árbol!vacío
\end_layout

\end_inset


\end_layout

\begin_layout Section
Construyendo árboles
\end_layout

\begin_layout Standard
El proceso de construir un árbol es similar al de una lista enlazada.
 La llamada al constructor arma un árbol con un solo nodo.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforeverb
\end_layout

\end_inset

 
\end_layout

\begin_layout Verbatim

class arbol:
\end_layout

\begin_layout Verbatim

  def __init__(self, carga, izquierdo=None, derecho=None):
\end_layout

\begin_layout Verbatim

    self.carga = carga
\end_layout

\begin_layout Verbatim

    self.izquierdo  = izquierdo
\end_layout

\begin_layout Verbatim

    self.derecho = derecho
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def __str__(self):
\end_layout

\begin_layout Verbatim

    return str(self.carga)
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterverb
\end_layout

\end_inset

 La 
\family typewriter
carga
\family default
 puede tener cualquier tipo, pero los parámetros 
\family typewriter
izquierdo
\family default
 y 
\family typewriter
derecho
\family default
 deben ser nodos.
 En 
\family typewriter
__init__
\family default
, 
\family typewriter
izquierdo
\family default
 y 
\family typewriter
derecho
\family default
 son opcionales; su valor por defecto es 
\family typewriter
None
\family default
.
 Imprimir un nodo equivale a imprimir su carga.
\end_layout

\begin_layout Standard
Una forma de construir un árbol es de abajo hacia arriba.
 Primero se construyen los nodos hijos:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforeverb
\end_layout

\end_inset

 
\end_layout

\begin_layout Verbatim

izquierdo = arbol(2)
\end_layout

\begin_layout Verbatim

derecho = arbol(3)
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterverb
\end_layout

\end_inset

 Ahora se crea el padre y se enlazan los hijos:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforeverb
\end_layout

\end_inset

 
\end_layout

\begin_layout Verbatim

arbol = arbol(1, izquierdo, derecho);
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterverb
\end_layout

\end_inset

 Podemos escribir esto de una manera más compacta anidando los llamados:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforeverb
\end_layout

\end_inset

 
\end_layout

\begin_layout Verbatim

>>> arbol = arbol(1, arbol(2), arbol(3))
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterverb
\end_layout

\end_inset

 Con las dos formas se obtiene como resultado el árbol que ilustramos al
 principio del capítulo.
\end_layout

\begin_layout Section
Recorridos sobre árboles
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
árbol!recorrido
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
recorrer
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
recursión
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Cada vez que se encuentre con una nueva estructura de datos su primera pregunta
 debería ser, 
\begin_inset Quotes eld
\end_inset

¿Cóomo la recorro?
\begin_inset Quotes erd
\end_inset

.
 La forma más natural de recorrer un árbol es recursiva.
 Si el árbol contiene números enteros en la carga, esta función calcula
 su suma :
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforeverb
\end_layout

\end_inset

 
\end_layout

\begin_layout Verbatim

def total(arbol):
\end_layout

\begin_layout Verbatim

  if arbol == None: 
\end_layout

\begin_layout Verbatim

     return 0
\end_layout

\begin_layout Verbatim

  else:
\end_layout

\begin_layout Verbatim

     return total(arbol.izquierdo) + total(arbol.derecho) 
\end_layout

\begin_layout Verbatim

            + arbol.carga
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterverb
\end_layout

\end_inset

 El caso base se da cuando el argumento es el árbol vacío, que no tiene
 carga, así que la suma se define como 0.
 El paso recursivo realiza dos llamados recursivos para encontrar la suma
 de los árboles hijos, cuando finalizan, se suma a estos valores la carga
 del padre.
\end_layout

\begin_layout Section
Árboles de expresiones
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
árbol!expresión
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
árbol para una expresión
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
postfija
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
infija
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
operador binario
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
operador!binario
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Un árbol representa naturalmente la estructura de una expresión.
 Además, lo puede realizar sin ninguna ambigüedad.
 Por ejemplo, la expresión infija 
\family typewriter
1 + 2 * 3
\family default
 es ambigua a menos que se establezca que la multiplicación se debe realizar
 antes que la suma.
\end_layout

\begin_layout Standard
Este árbol representa la misma expresión:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforefig
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
centerline{
\end_layout

\end_inset


\begin_inset Graphics
	filename illustrations/tree2.eps

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterfig
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Los nodos de un árbol para una expresión pueden ser operandos como 
\family typewriter
1
\family default
 y 
\family typewriter
2
\family default
, también operadores como 
\family typewriter
+
\family default
 y 
\family typewriter
*
\family default
.
 Los operandos deben ser nodos hoja; y los nodos que contienen operadores
 tienen referencias a sus operandos.
 Todos estos operadores son 
\series bold
binarios
\series default
, así que solamente tienen dos operandos.
\end_layout

\begin_layout Standard
Un árbol como el siguiente representa la figura anterior:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforeverb
\end_layout

\end_inset

 
\end_layout

\begin_layout Verbatim

>>> arbol = arbol('+', arbol(1), 
\end_layout

\begin_layout Verbatim

                       arbol('*', arbol(2), arbol(3)))
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterverb
\end_layout

\end_inset

 Observando la figura no hay ninguna duda sobre el orden de las operaciones;
 la multiplicación ocurre primero para que se calcule el segundo operando
 de la suma.
\end_layout

\begin_layout Standard
Los árboles de expresiones tienen muchos usos.
 El ejemplo de este capítulo utiliza árboles para traducir expresiones entre
 las notaciones postfija, prefija, e infija.
 Árboles similares se usan en los compiladores para analizar sintácticamente,
 optimizar y traducir programas.
\end_layout

\begin_layout Section
Recorrido en árboles
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
árbol!recorrido
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
recorrido
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
recursión
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Preorden
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Postorden
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
EnOrden
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Podemos recorrer un árbol de expresiones e imprimir el contenido de la siguiente
 forma:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforeverb
\end_layout

\end_inset

 
\end_layout

\begin_layout Verbatim

def imprimirarbol(arbol):
\end_layout

\begin_layout Verbatim

  if arbol == None: 
\end_layout

\begin_layout Verbatim

     return
\end_layout

\begin_layout Verbatim

  print arbol.carga,
\end_layout

\begin_layout Verbatim

  imprimirarbol(arbol.izquierdo)
\end_layout

\begin_layout Verbatim

  imprimirarbol(arbol.derecho)
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterverb
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Preorden
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
prefija
\end_layout

\end_inset


\end_layout

\begin_layout Standard
En otras palabras, para imprimir un árbol, primero se imprime el contenido
 (carga) de la raíz, luego todo el subárbol izquierdo, y a continuación
 todo el subárbol derecho.
 Este recorrido se denomina 
\series bold
preorden
\series default
, porque el contenido de la raíz se despliega 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
em
\end_layout

\end_inset

 antes
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 que el contenido de los hijos.
 Para el ejemplo anterior, la salida es:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforeverb
\end_layout

\end_inset

 
\end_layout

\begin_layout Verbatim

>>> arbol = arbol('+', arbol(1), 
\end_layout

\begin_layout Verbatim

                       arbol('*', arbol(2), arbol(3)))
\end_layout

\begin_layout Verbatim

>>> imprimirarbol(arbol)
\end_layout

\begin_layout Verbatim

+ 1 * 2 3
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterverb
\end_layout

\end_inset

 Esta notación diferente a la infija y a la postfija, se denomina 
\series bold
prefija
\series default
, porque los operadores aparecen antes que sus operandos.
\end_layout

\begin_layout Standard
Usted puede sospechar que si se recorre el árbol de una forma distinta se
 obtiene otra notación.
 Por ejemplo si se despliegan los dos subárboles primero y a continuación
 el nodo raíz, se obtiene
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforeverb
\end_layout

\end_inset

 
\end_layout

\begin_layout Verbatim

def imprimirarbolPostorden(arbol):
\end_layout

\begin_layout Verbatim

  if arbol == None: 
\end_layout

\begin_layout Verbatim

     return
\end_layout

\begin_layout Verbatim

  else 
\end_layout

\begin_layout Verbatim

     imprimirarbolPostorden(arbol.izquierdo)
\end_layout

\begin_layout Verbatim

     imprimirarbolPostorden(arbol.derecho)
\end_layout

\begin_layout Verbatim

     print arbol.carga,
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterverb
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
postorden
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
en orden
\end_layout

\end_inset

 El resultado, 
\family typewriter
1 2 3 * +
\family default
, está en notación postfija!.
 Por esta razón este recorrido se denomina 
\series bold
postorden
\series default
.
\end_layout

\begin_layout Standard
Finalmente, para recorrer el árbol 
\series bold
en orden
\series default
, se imprime el árbol izquierdo, luego la raíz y, por último, el árbol derecho:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforeverb
\end_layout

\end_inset

 
\end_layout

\begin_layout Verbatim

def imprimirabolEnOrden(árbol):
\end_layout

\begin_layout Verbatim

  if arbol == None: 
\end_layout

\begin_layout Verbatim

     return
\end_layout

\begin_layout Verbatim

  imprimirabolEnOrden(arbol.izquierdo)
\end_layout

\begin_layout Verbatim

  print arbol.carga,
\end_layout

\begin_layout Verbatim

  imprimirabolEnOrden(arbol.derecho)
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterverb
\end_layout

\end_inset

 El resultado es 
\family typewriter
1 + 2 * 3
\family default
, la expresión en notación infija.
\end_layout

\begin_layout Standard
Por precisión debemos anotar que hemos omitido una complicación importante.
 Algunas veces cuando escribimos una expresión infija, tenemos que usar
 paréntesis para preservar el orden de las operaciones.
 Así que un recorrido en orden no es suficiente en todos los casos para
 generar una expresión infija.
\end_layout

\begin_layout Standard
Sin embargo, con unas mejoras adicionales, los árboles de expresiones y
 los tres recorridos recursivos proporcionan una forma general de traducir
 expresiones de un formato al otro.
\end_layout

\begin_layout Quote
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
em
\end_layout

\end_inset

 Como ejercicio, modifique 
\family typewriter
imprimirarbolEnOrden
\family default
 para que despliegue paréntesis alrededor de cada operador y pareja de operandos.
 ¿La salida es correcta e inequívoca? ¿Siempre son necesarios los paréntesis?
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
Si realizamos un recorrido en orden y llevamos pista del nivel en el que
 vamos podemos generar una representación gráfica del árbol:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforeverb
\end_layout

\end_inset

 
\end_layout

\begin_layout Verbatim

def imprimirarbolSangrado(arbol, nivel=0):
\end_layout

\begin_layout Verbatim

  if arbol == None: 
\end_layout

\begin_layout Verbatim

     return
\end_layout

\begin_layout Verbatim

  imprimirarbolSangrado(arbol.derecho, nivel+1)
\end_layout

\begin_layout Verbatim

  print '  '*nivel + str(arbol.carga)
\end_layout

\begin_layout Verbatim

  imprimirarbolSangrado(arbol.izquierdo, nivel+1)
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterverb
\end_layout

\end_inset

 El parámetro 
\family typewriter
nivel
\family default
 lleva el nivel actual.
 Por defecto es 0.
 Cada vez que hacemos un llamado recursivo pasamos 
\family typewriter
nivel+1
\family default
, porque el nivel de los hijos siempre es uno más del nivel del padre.
 Cada objeto se sangra o indenta con dos espacios por nivel.
 El resultado para el árbol de ejemplo es:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforeverb
\end_layout

\end_inset

 
\end_layout

\begin_layout Verbatim

>>> imprimirarbolSangrado(arbol)
\end_layout

\begin_layout Verbatim

    3
\end_layout

\begin_layout Verbatim

  *
\end_layout

\begin_layout Verbatim

    2
\end_layout

\begin_layout Verbatim

+
\end_layout

\begin_layout Verbatim

  1
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterverb
\end_layout

\end_inset

 Si rota el libro 90 grados en el sentido de las manecillas del reloj verá
 una forma simplificada del dibujo al principio del capítulo.
\end_layout

\begin_layout Section
Construyendo un árbol para una expresión
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
árbol para una expresión
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
árbol!expresión
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
análisis sintáctico
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
lexema
\end_layout

\end_inset


\end_layout

\begin_layout Standard
En esta sección, analizaremos sintácticamente expresiones infijas para construir
 su respectivo árbol de expresión.
 Por ejemplo, la expresión 
\family typewriter
(3+7)*9
\family default
 se representa con el siguiente árbol:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforefig
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
centerline{
\end_layout

\end_inset


\begin_inset Graphics
	filename illustrations/tree3.eps

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterfig
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note que hemos simplificado el diagrama ocultando los nombres de los atributos.
\end_layout

\begin_layout Standard
El análisis sintáctico se hará sobre expresiones que incluyan números, paréntesi
s, y los operadores 
\family typewriter
+
\family default
 y 
\family typewriter
*
\family default
.
 Asumimos que la cadena de entrada ha sido separada en una lista de lexemas;
 por ejemplo, para 
\family typewriter
(3+7)*9
\family default
 la lista de lexemas es:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforeverb
\end_layout

\end_inset

 
\end_layout

\begin_layout Verbatim

['(', 3, '+', 7, ')', '*', 9, 'fin']
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterverb
\end_layout

\end_inset

 La cadena 
\family typewriter
fin
\family default
 sirve para prevenir que el analizador sintáctico siga leyendo más allá
 del final de la lista.
\end_layout

\begin_layout Quote
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
em
\end_layout

\end_inset

 Como ejercicio escriba una función que reciba una cadena de texto con una
 expresión y retorne la lista de lexemas (con la cadena 
\family typewriter
fin
\family default
 al final).
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
La primera función que escribiremos es 
\family typewriter
obtenerLexema
\family default
, que toma una lista de lexemas y un lexema esperado como parámetros.
 Compara el lexema esperado con el primero de la lista: si son iguales,
 elimina el lexema de la lista y retorna True, si no son iguales, retorna
 False:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforeverb
\end_layout

\end_inset

 
\end_layout

\begin_layout Verbatim

def obtenerLexema(listaLexemas, esperado):
\end_layout

\begin_layout Verbatim

  if listaLexemas[0] == esperado:
\end_layout

\begin_layout Verbatim

    del listaLexemas[0]
\end_layout

\begin_layout Verbatim

    return 1
\end_layout

\begin_layout Verbatim

  else:
\end_layout

\begin_layout Verbatim

    return 0
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterverb
\end_layout

\end_inset

 Como 
\family typewriter
listaLexemas
\family default
 se refiere a un objeto mutable, los cambios que hacemos son visibles en
 cualquier otra parte del programa que tenga una referencia a la lista.
\end_layout

\begin_layout Standard
La siguiente función, 
\family typewriter
obtenerNumero
\family default
, acepta operandos.
 Si el siguiente lexema en 
\family typewriter
listaLexemas
\family default
 es un número, 
\family typewriter
obtenerNumero
\family default
 lo elimina y retorna un nodo hoja cuya carga será el número; si no es un
 número retorna 
\family typewriter
None
\family default
.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforeverb
\end_layout

\end_inset

 
\end_layout

\begin_layout Verbatim

def obtenerNumero(listaLexemas):
\end_layout

\begin_layout Verbatim

  x = listaLexemas[0]
\end_layout

\begin_layout Verbatim

  if type(x) != type(0): 
\end_layout

\begin_layout Verbatim

     return None
\end_layout

\begin_layout Verbatim

  del listaLexemas[0]
\end_layout

\begin_layout Verbatim

  return arbol (x, None, None)
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterverb
\end_layout

\end_inset

 Probemos a 
\family typewriter
obtenerNumero
\family default
 con una lista pequeña de números.
 Después del llamado, imprimimos el árbol resultante y lo que queda de la
 lista:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforeverb
\end_layout

\end_inset

 
\end_layout

\begin_layout Verbatim

>>> listaLexemas = [9, 11, 'fin']
\end_layout

\begin_layout Verbatim

>>> x = obtenerNumero(listaLexemas)
\end_layout

\begin_layout Verbatim

>>> imprimirarbolPostorden(x)
\end_layout

\begin_layout Verbatim

9
\end_layout

\begin_layout Verbatim

>>> print listaLexemas
\end_layout

\begin_layout Verbatim

[11, 'fin']
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterverb
\end_layout

\end_inset

 El siguiente método que necesitamos es 
\family typewriter
obtenerProducto
\family default
, que construye un árbol de expresión para productos.
 Un producto sencillo tiene dos números como operandos, como en 
\family typewriter
3 * 7
\family default
.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforeverb
\end_layout

\end_inset

 
\end_layout

\begin_layout Verbatim

def obtenerProducto(listaLexemas):
\end_layout

\begin_layout Verbatim

  a = obtenerNumero(listaLexemas)
\end_layout

\begin_layout Verbatim

  if obtenerLexema(listaLexemas, '*'):
\end_layout

\begin_layout Verbatim

    b = obtenerNumero(listaLexemas)
\end_layout

\begin_layout Verbatim

    return árbol ('*', a, b)
\end_layout

\begin_layout Verbatim

  else:
\end_layout

\begin_layout Verbatim

    return a
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterverb
\end_layout

\end_inset

 Asumiendo que 
\family typewriter
obtenerNumero
\family default
 retorna un árbol, le asignamos el primer operando a 
\family typewriter
a
\family default
.
 Si el siguiente carácter es 
\family typewriter
*
\family default
, obtenemos el segundo número y construimos un árbol de expresión con 
\family typewriter
a
\family default
, 
\family typewriter
b
\family default
, y el operador.
\end_layout

\begin_layout Standard
Si el siguiente carácter es cualquier otro, retornamos el nodo hoja con
 
\family typewriter
a
\family default
.
 Aquí hay dos ejemplos:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforeverb
\end_layout

\end_inset

 
\end_layout

\begin_layout Verbatim

>>> listaLexemas = [9, '*', 11, 'fin']
\end_layout

\begin_layout Verbatim

>>> arbol = obtenerProducto(listaLexemas)
\end_layout

\begin_layout Verbatim

>>> imprimirarbolPostorden(árbol)
\end_layout

\begin_layout Verbatim

9 11 *
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterverb
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforeverb
\end_layout

\end_inset

 
\end_layout

\begin_layout Verbatim

>>> listaLexemas = [9, '+', 11, 'fin']
\end_layout

\begin_layout Verbatim

>>> arbol = obtenerProducto(listaLexemas)
\end_layout

\begin_layout Verbatim

>>> imprimirarbolPostorden(arbol)
\end_layout

\begin_layout Verbatim

9
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterverb
\end_layout

\end_inset

 El segundo ejemplo implica que consideramos que un solo operando sea tratado
 como una clase de producto.
 Esta definición de 
\begin_inset Quotes eld
\end_inset

producto
\begin_inset Quotes erd
\end_inset

 es contraintuitiva, pero resulta ser muy provechosa.
\end_layout

\begin_layout Standard
Ahora, tenemos que manejar los productos compuestos, como 
\family typewriter
3 * 5 * 13
\family default
.
 Esta expresión es un producto de productos, vista así: 
\family typewriter
3 * (5 * 13)
\family default
.
 El árbol resultante es:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforefig
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
centerline{
\end_layout

\end_inset


\begin_inset Graphics
	filename illustrations/tree4.eps

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterfig
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Con un pequeño cambio en 
\family typewriter
obtenerProducto
\family default
, podemos analizar un producto arbitrariamente largo:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforeverb
\end_layout

\end_inset

 
\end_layout

\begin_layout Verbatim

def obtenerProducto(listaLexemas):
\end_layout

\begin_layout Verbatim

  a = obtenerNumero(listaLexemas)
\end_layout

\begin_layout Verbatim

  if obtenerLexema(listaLexemas, '*'):
\end_layout

\begin_layout Verbatim

    b = obtenerProducto(listaLexemas)   # esta línea cambió
\end_layout

\begin_layout Verbatim

    return arbol ('*', a, b)
\end_layout

\begin_layout Verbatim

  else:
\end_layout

\begin_layout Verbatim

    return a
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterverb
\end_layout

\end_inset

 En otras palabras, un producto puede ser un árbol singular o un árbol con
 
\family typewriter
*
\family default
 en la raíz, un número en el subárbol izquierdo, y un producto en el subárbol
 derecho.
\end_layout

\begin_layout Standard
Esta clase de definición recursiva debería empezar a ser familiar.
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
producto
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
definición!recursiva
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
definición recursiva
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Probemos la nueva versión con un producto compuesto:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforeverb
\end_layout

\end_inset

 
\end_layout

\begin_layout Verbatim

>>> listaLexemas = [2, '*', 3, '*', 5 , '*', 7, 'fin']
\end_layout

\begin_layout Verbatim

>>> arbol = obtenerProducto(listaLexemas)
\end_layout

\begin_layout Verbatim

>>> imprimirarbolPostorden(arbol)
\end_layout

\begin_layout Verbatim

2 3 5 7 * * *
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterverb
\end_layout

\end_inset

 Ahora, agregaremos la posibilidad de analizar sumas.
 Otra vez daremos una definición contraintuitiva a la 
\begin_inset Quotes eld
\end_inset

suma.
\begin_inset Quotes erd
\end_inset

 Una suma puede ser un árbol con 
\family typewriter
+
\family default
 en la raíz, un producto en el subárbol izquierdo y una suma en el subárbol
 derecho.
 O, una suma puede ser sólo un producto.
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
suma
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Si usted analiza esta definición encontrará que tiene una propiedad muy
 bonita: podemos representar cualquier expresión (sin paréntesis) como una
 suma de productos.
 Esta propiedad es el fundamento de nuestro algoritmo de análisis sintáctico.
\end_layout

\begin_layout Standard

\family typewriter
obtenerSuma
\family default
 intenta construir un árbol con un producto en izquierdo y una suma en derecho.
 Pero si no encuentra un 
\family typewriter
+
\family default
, solamente construye un producto.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforeverb
\end_layout

\end_inset

 
\end_layout

\begin_layout Verbatim

def obtenerSuma(listaLexemas):
\end_layout

\begin_layout Verbatim

  a = obtenerProducto(listaLexemas)
\end_layout

\begin_layout Verbatim

  if obtenerLexema(listaLexemas, '+'):
\end_layout

\begin_layout Verbatim

    b = obtenerSuma(listaLexemas)
\end_layout

\begin_layout Verbatim

    return arbol ('+', a, b)
\end_layout

\begin_layout Verbatim

  else:
\end_layout

\begin_layout Verbatim

    return a
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterverb
\end_layout

\end_inset

 Probemos con 
\family typewriter
9 * 11 + 5 * 7
\family default
:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforeverb
\end_layout

\end_inset

 
\end_layout

\begin_layout Verbatim

>>> listaLexemas = [9, '*', 11, '+', 5, '*', 7, 'fin']
\end_layout

\begin_layout Verbatim

>>> arbol = obtenerSuma(listaLexemas)
\end_layout

\begin_layout Verbatim

>>> imprimirarbolPostorden(árbol)
\end_layout

\begin_layout Verbatim

9 11 * 5 7 * +
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterverb
\end_layout

\end_inset

 Casi terminamos, pero todavía faltan los paréntesis.
 En cualquier posición de una expresión donde podamos encontrar un número
 puede también haber una suma completa cerrada entre paréntesis.
 Necesitamos modificar 
\family typewriter
obtenerNumero
\family default
 para que sea capaz de manejar 
\series bold
subexpresiones
\series default
:
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
subexpresión
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforeverb
\end_layout

\end_inset

 
\end_layout

\begin_layout Verbatim

def obtenerNumero(listaLexemas):
\end_layout

\begin_layout Verbatim

  if obtenerLexema(listaLexemas, '('):
\end_layout

\begin_layout Verbatim

    # obtiene la subexpresión
\end_layout

\begin_layout Verbatim

    x = obtenerSuma(listaLexemas)  
\end_layout

\begin_layout Verbatim

    # elimina los paréntesis
\end_layout

\begin_layout Verbatim

    obtenerLexema(listaLexemas, ')') 
\end_layout

\begin_layout Verbatim

    return x
\end_layout

\begin_layout Verbatim

  else:
\end_layout

\begin_layout Verbatim

    x = listaLexemas[0]
\end_layout

\begin_layout Verbatim

    if type(x) != type(0): 
\end_layout

\begin_layout Verbatim

       return None
\end_layout

\begin_layout Verbatim

    listaLexemas[0:1] = []
\end_layout

\begin_layout Verbatim

    return árbol (x, None, None)    
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterverb
\end_layout

\end_inset

 Probemos esto con 
\family typewriter
9 * (11 + 5) * 7
\family default
:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforeverb
\end_layout

\end_inset

 
\end_layout

\begin_layout Verbatim

>>> listaLexemas = [9, '*', '(', 11, '+', 5, ')','*', 7, 
\end_layout

\begin_layout Verbatim

'fin']
\end_layout

\begin_layout Verbatim

>>> arbol = obtenerSuma(listaLexemas)
\end_layout

\begin_layout Verbatim

>>> imprimirarbolPostorden(arbol)
\end_layout

\begin_layout Verbatim

9 11 5 + 7 * *
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterverb
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%
\backslash
adjustpage{-2}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%
\backslash
pagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El analizador manejó los paréntesis correctamente, la suma se hace antes
 que la multiplicación.
\end_layout

\begin_layout Standard
En la versión final del programa, sería bueno nombrar a 
\family typewriter
obtenerNumero
\family default
 con un rol más descriptivo.
\end_layout

\begin_layout Section
Manejo de errores
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
manejo de errores
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
errores!manejo de
\end_layout

\end_inset


\end_layout

\begin_layout Standard
En todo momento hemos asumido que las expresiones están bien formadas.
 Por ejemplo, cuando llegamos al final de una subexpresión, asumimos que
 el siguiente carácter es un paréntesis derecho.
 Si hay un error y el siguiente carácter es algo distinto debemos manejar
 esta situación.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforeverb
\end_layout

\end_inset

 
\end_layout

\begin_layout Verbatim

def obtenerNumero(listaLexemas):
\end_layout

\begin_layout Verbatim

  if obtenerLexema(listaLexemas, '('):
\end_layout

\begin_layout Verbatim

    x = obtenerSuma(listaLexemas)       
\end_layout

\begin_layout Verbatim

    if not obtenerLexema(listaLexemas, ')'):
\end_layout

\begin_layout Verbatim

      raise 'ErrorExpresionMalFormada', 'falta paréntesis'
\end_layout

\begin_layout Verbatim

    return x
\end_layout

\begin_layout Verbatim

  else:
\end_layout

\begin_layout Verbatim

    # el resto del código se omite
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterverb
\end_layout

\end_inset

 La sentencia 
\family typewriter
raise
\family default
 crea una excepción.
 En este caso creamos una nueva clase de excepción llamada 
\family typewriter
ErrorExpresionMalFormada
\family default
.
 Si la función que llamó a 
\family typewriter
obtenerNumero
\family default
, o una de las funciones en la traza que causante de su llamado maneja la
 excepción, el programa puede continuar.
 De otra forma, Python imprimirá un mensaje de error y abortará la ejecución.
\end_layout

\begin_layout Quote
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
em
\end_layout

\end_inset

 Como ejercicio, encuentre otros lugares donde pueden ocurrir errores de
 este tipo y agregue sentencias 
\family typewriter
raise
\family default
 apropiadas.
 Pruebe su código con expresiones mal formadas.
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\begin_layout Section
El árbol de animales
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
juego de animales
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
juego!de animales
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
base de conocimiento
\end_layout

\end_inset


\end_layout

\begin_layout Standard
En esta sección desarrollaremos un pequeño programa que usa un árbol para
 representar una base de conocimiento.
\end_layout

\begin_layout Standard
El programa interactúa con el usuario para crear un árbol de preguntas y
 nombres de animales.
 Aquí hay una ejecución de ejemplo:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
adjustpage
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

-3
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%
\backslash
pagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforeverb
\end_layout

\end_inset

 
\end_layout

\begin_layout Verbatim

¿Esta pensando en un animal? s
\end_layout

\begin_layout Verbatim

¿Es un pájaro? n
\end_layout

\begin_layout Verbatim

¿Cual es el nombre del animal? perro
\end_layout

\begin_layout Verbatim

¿Que pregunta permite distinguir entre un perro 
\end_layout

\begin_layout Verbatim

y un pájaro? Puede volar
\end_layout

\begin_layout Verbatim

¿Si el animal fuera perro la respuesta sería? n
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

¿Esta pensando en un animal? s
\end_layout

\begin_layout Verbatim

¿Puede volar? n
\end_layout

\begin_layout Verbatim

¿Es un perro? n
\end_layout

\begin_layout Verbatim

¿Cual es el nombre del animal? gato
\end_layout

\begin_layout Verbatim

¿Que pregunta permite distinguir un gato 
\end_layout

\begin_layout Verbatim

de un perro? Ladra
\end_layout

\begin_layout Verbatim

¿Si el animal fuera un gato 
\end_layout

\begin_layout Verbatim

la respuesta sería? n
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

¿Esta pensando en un animal? y
\end_layout

\begin_layout Verbatim

¿Puede volar? n
\end_layout

\begin_layout Verbatim

¿Ladra? s
\end_layout

\begin_layout Verbatim

¿Es un perro? s
\end_layout

\begin_layout Verbatim

¡Soy el mejor!
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterverb
\end_layout

\end_inset

 Este es el árbol que el diálogo genera:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforefig
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
centerline{
\end_layout

\end_inset


\begin_inset Graphics
	filename illustrations/tree5.eps

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterfig
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Al principio de cada ronda, el programa empieza en la raíz del árbol y hace
 la primera pregunta.
 Dependiendo de la respuesta se mueve al subárbol izquierdo o derecho y
 continúa hasta que llega a un nodo hoja.
 En ese momento conjetura.
 Si falla, le pregunta al usuario el nombre del animal y una pregunta que
 le permitiría distinguir el animal conjeturado del real.
 Con esta información agrega un nodo al árbol con la nueva pregunta y el
 nuevo animal.
\end_layout

\begin_layout Standard
Aquí está el código fuente:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
adjustpage
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

-2
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%
\backslash
pagebreak
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforeverb
\end_layout

\end_inset

 
\end_layout

\begin_layout Verbatim

def animal():
\end_layout

\begin_layout Verbatim

  # Un solo nodo
\end_layout

\begin_layout Verbatim

  raiz = arbol("pajaro")
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  # Hasta que el usuario salga
\end_layout

\begin_layout Verbatim

  while True:
\end_layout

\begin_layout Verbatim

    print
\end_layout

\begin_layout Verbatim

    if not si("Esta pensando en un animal? "): 
\end_layout

\begin_layout Verbatim

       break
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

    # Recorrer el arbol
\end_layout

\begin_layout Verbatim

    arbol = raiz
\end_layout

\begin_layout Verbatim

    while arbol.obtenerizquierdo() != None:
\end_layout

\begin_layout Verbatim

      pregunta = arbol.obtenercarga() + "? "
\end_layout

\begin_layout Verbatim

      if si(pregunta):
\end_layout

\begin_layout Verbatim

        árbol = arbol.obtenerderecho()
\end_layout

\begin_layout Verbatim

      else:
\end_layout

\begin_layout Verbatim

        arbol = arbol.obtenerizquierdo()
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

    # conjetura
\end_layout

\begin_layout Verbatim

    conjetura = arbol.obtenercarga()
\end_layout

\begin_layout Verbatim

    pregunta = "¿Es un" + conjetura + "? "
\end_layout

\begin_layout Verbatim

    if si(pregunta):
\end_layout

\begin_layout Verbatim

      print "¡Soy el mejor!"
\end_layout

\begin_layout Verbatim

      continue
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

    # obtener mas informacion
\end_layout

\begin_layout Verbatim

    pregunta  = "¿Cual es el nombre el animal? "
\end_layout

\begin_layout Verbatim

    animal  = raw_input(pregunta)
\end_layout

\begin_layout Verbatim

    pregunta  = "¿Que pregunta permitiria 
\end_layout

\begin_layout Verbatim

                  distinguir un %s de un %s? "
\end_layout

\begin_layout Verbatim

    q = raw_input(pregunta % (animal,conjetura))
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

    # agrega un nuevo nodo arbol
\end_layout

\begin_layout Verbatim

    arbol.asignarcarga(q)
\end_layout

\begin_layout Verbatim

    pregunta = "¿Si el animal fuera %s 
\end_layout

\begin_layout Verbatim

                la respuesta sería? "
\end_layout

\begin_layout Verbatim

    if si(pregunta % animal):
\end_layout

\begin_layout Verbatim

      arbol.asignarizquierdo(arbol(conjetura))
\end_layout

\begin_layout Verbatim

      árbol.asignarderecho(arbol(animal))
\end_layout

\begin_layout Verbatim

    else:
\end_layout

\begin_layout Verbatim

      arbol.asignarizquierdo(arbol(animal))
\end_layout

\begin_layout Verbatim

      arbol.asignarderecho(arbol(conjetura))
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterverb
\end_layout

\end_inset

 La función 
\family typewriter
si
\family default
 es auxiliar, imprime una pregunta y recibe la respuesta del usuario.
 Si la respuesta empieza con 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
em
\end_layout

\end_inset

 s
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 o 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
em
\end_layout

\end_inset

 S
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

, retorna cierto:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforeverb
\end_layout

\end_inset

 
\end_layout

\begin_layout Verbatim

def si(preg):
\end_layout

\begin_layout Verbatim

  from string import lower
\end_layout

\begin_layout Verbatim

  r = lower(raw_input(preg))
\end_layout

\begin_layout Verbatim

  return (r[0] == 's')
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterverb
\end_layout

\end_inset

 La condición del ciclo es 
\family typewriter
True
\family default
, lo que implica que el ciclo iterará hasta que la sentencia 
\family typewriter
break
\family default
 se ejecute cuando el usuario deje de pensar en animales.
\end_layout

\begin_layout Standard
El ciclo 
\family typewriter
while
\family default
 interno recorre el árbol desde la raíz hasta el fondo, guiándose por las
 respuestas del usuario.
\end_layout

\begin_layout Standard
Cuando se agrega un nuevo nodo al árbol, la nueva pregunta reemplaza la
 carga, y los dos hijos son el animal nuevo y la carga original.
\end_layout

\begin_layout Standard
Una limitación seria de este programa es que cuando finaliza, ¡olvida todo
 lo que se le ha enseñado!
\end_layout

\begin_layout Quote
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
em
\end_layout

\end_inset

 Como ejercicio, piense en diferentes maneras de guardar este árbol de conocimie
nto en un archivo.
 Implemente la que parezca más sencilla.
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\begin_layout Section
Glosario
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
árbol binario
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
nodo
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
nodo raíz
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
nodo hoja
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
nodo padre
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
nodo hijo
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
nodo hermano
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
nivel
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
prefija
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
preorden
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
postorden
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
en orden
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
operador binario
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
operador!binario
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

Arbol binario:
\end_layout

\end_inset

 un árbol en el que cada nodo se refiere a cero, uno o dos nodos, llamados
 hijos.
\end_layout

\begin_layout Description
Raíz: nodo inicial en un árbol, es el único que no tiene padre.
\end_layout

\begin_layout Description
Hoja: nodo que no tiene hijos y se encuentra lo mas abajo posible.
\end_layout

\begin_layout Description
Padre: nodo que tiene la referencia hacia otro nodo.
\end_layout

\begin_layout Description
Hijo: uno de los nodos referenciados por un nodo.
\end_layout

\begin_layout Description
Hermanos: nodos que comparten un padre común.
\end_layout

\begin_layout Description
Nivel: conjunto de nodos equidistantes a la raíz.
\end_layout

\begin_layout Description
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

Operador binario:
\end_layout

\end_inset

 operador que acepta dos operandos.
\end_layout

\begin_layout Description
Subexpresión: expresión en paréntesis que se puede ver como un solo operando
 en una expresión más grande.
\end_layout

\begin_layout Description
Preorden: es el recorrido sobre un árbol en el que se visita cada nodo antes
 que a sus hijos.
\end_layout

\begin_layout Description
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

Notación prefija:
\end_layout

\end_inset

 notación para escribir una expresión matemática en la que cada operador
 aparece antes de sus operandos.
\end_layout

\begin_layout Description
Postorden: forma de recorrer un árbol, visitando los hijos de un nodo antes
 que a este.
\end_layout

\begin_layout Description
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

En orden:
\end_layout

\end_inset

 forma de recorrer un árbol, visitando primero el subárbol izquierdo, luego
 la raíz y por último, el subárbol derecho.
\end_layout

\begin_layout Standard

\end_layout

\end_body
\end_document
