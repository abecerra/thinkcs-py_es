
\chapter{Condicionales y recursi贸n}

\section{El operador residuo}

\index{operador residuo} \index{operador!residuo}

El \textbf{operador residuo} trabaja con enteros (y expresiones enteras)
calculando el residuo del primer operando cuando se divide por el
segundo. En Python este operador es un signo porcentaje (\texttt{\%}).
La sintaxis es la misma que para los otros operadores:

\inputencoding{latin9}\begin{lstlisting}
>>> cociente = 7 // 3
>>> print(cociente)
2
>>> residuo = 7 % 3
>>> print(residuo)
1
\end{lstlisting}
\inputencoding{utf8}
As铆 que 7 dividido por 3 da 2 con residuo 1.

El operador residuo resulta ser sorprendentemente 煤til. Por ejemplo,
usted puede chequear si un n煤mero es divisible por otro si \texttt{x\%y}
es cero, entonces \texttt{x} es divisible por \texttt{y}.

Usted tambi茅n puede extraer el d铆gito o d铆gitos m谩s a la derecha de
un n煤mero. Por ejemplo, \texttt{x \% 10} entrega el d铆gito m谩s a la
derecha de \texttt{x} (en base 10). Igualmente, \texttt{x \% 100}
entrega los dos 煤ltimos d铆gitos.

\section{Expresiones booleanas}

\index{expresi贸n Booleana} \index{expresi贸n!booleana} \index{operador l贸gico}
\index{operador!l贸gico}

El tipo que Python provee para almacenar valores de verdad (cierto
o falso) se denomina bool por el matem谩tico brit谩nico George Bool.
l cre贸 el lgebra Booleana, que es la base para la aritm茅tica que
se usa en los computadores modernos.

S贸lo hay dos valores booleanos: True (cierto) y False (falso). Las
may煤sculas importan, ya que true y false no son valores booleanos.

El operador \texttt{==} compara dos valores y produce una expresi贸n
booleana:

\inputencoding{latin9}\begin{lstlisting}
>>> 5 == 5
True
>>> 5 == 6
False
\end{lstlisting}
\inputencoding{utf8} En la primera sentencia, los dos operandos son iguales, as铆 que la
expresi贸n eval煤a a True (cierto); en la segunda sentencia, 5 no es
igual a 6, as铆 que obtenemos False (falso).

El operador \texttt{==} es uno de los \textbf{operadores de comparaci贸n};
los otros son:\inputencoding{latin9}
\begin{lstlisting}
      x != y               # x no es igual y
      x > y                # x es mayor que y
      x < y                # x es menor que y
      x >= y               # x es mayor o igual a y
      x <= y               # x es menor o igual a y
\end{lstlisting}
\inputencoding{utf8}
Aunque estas operaciones probablemente son familiares para usted,
los s铆mbolos en Python difieren de los matem谩ticos. Un error com煤n
consiste en usar un solo signo igual (\texttt{=}) en lugar en un doble
signo igual (\texttt{==}). Recuerde que \texttt{=} es el operador
para la asignaci贸n y que \texttt{==} es el operador para comparaci贸n.
Tenga en cuenta que no existen los signos \texttt{=<} o \texttt{=>}.

\section{Operadores l贸gicos}

\index{operadores l贸gicos} \index{operador!l贸gicos}

Hay tres \textbf{operadores l贸gicos}: \texttt{and}, \texttt{or} y
\texttt{not}. La sem谩ntica (el significado) de ellos es similar a
su significado en ingl茅s. Por ejemplo, \texttt{x>0 and x<10} es cierto,
s贸lo si \texttt{x} es mayor a cero {\em y} menor que 10.

\texttt{n\%2 == 0 or n\%3 == 0} es cierto si {\em alguna} de las
condiciones es cierta, esto es, si el n煤mero es divisible por 2 {\em
o} por 3.

Finalmente, el operador \texttt{not} niega una expresi贸n booleana,
as铆 que \texttt{not(x>y)} es cierta si \texttt{(x>y)} es falsa, esto
es, si \texttt{x} es menor o igual a \texttt{y}.

Formalmente, los operandos de los operadores l贸gicos deben ser expresiones
booleanas, pero Python no es muy formal. Cualquier n煤mero diferente
de cero se interpreta como ``cierto.''\inputencoding{latin9}
\begin{lstlisting}
>>>  x = 5
>>>  x and 1
1
>>>  y = 0
>>>  y and 1
0
\end{lstlisting}
\inputencoding{utf8}
En general, esto no se considera un buen estilo de programaci贸n. Si
usted desea comparar un valor con cero, procure codificarlo expl铆citamente.

\section{Ejecuci贸n condicional}

\label{alternative execution} \index{ramificaci贸n condicional}
\index{ejecuci贸n condicional}

A fin de escribir programas 煤tiles, casi siempre necesitamos la capacidad
de chequear condiciones y cambiar el comportamiento del programa en
consecuencia. Las \textbf{sentencias condicionales} nos dan este poder.
La m谩s simple es la sentencia \texttt{if}: \inputencoding{latin9}
\begin{lstlisting}
if x > 0:
  print("x es positivo")
\end{lstlisting}
\inputencoding{utf8}
La expresi贸n despu茅s de la sentencia \texttt{if} se denomina la \textbf{condici贸n}.
Si es cierta, la sentencia de abajo se ejecuta. Si no lo es, no pasa
nada.

\index{sentencia compuesta} \index{sentencia compuesta!cabecera}
\index{sentencia compuesta!cuerpo} \index{sentencia compuesta!bloque de sentencias}
\index{sentencia!compuesta}

Como otras sentencias compuestas, la sentencia \texttt{if} comprende
una cabecera y un bloque de sentencias:
\begin{verbatim}
CABECERA:
  PRIMERA SENTENCIA
  ...
  ULTIMA SENTENCIA
\end{verbatim}
La cabecera comienza en una nueva l铆nea y termina con dos puntos seguidos
(:). Las sentencias sangradas o indentadas que vienen a continuaci贸n
se denominan el \textbf{bloque}. La primera sentencia sin sangrar
marca el fin del bloque. Un bloque de sentencias dentro de una sentencia
compuesta tambi茅n se denomina el \textbf{cuerpo} de la sentencia.

\index{bloque} \index{sentencia!bloque} \index{cuerpo}

No hay l铆mite en el n煤mero de sentencias que pueden aparecer en el
cuerpo de una sentencia, pero siempre tiene que haber, al menos, una.
Ocasionalmente, es 煤til tener un cuerpo sin sentencias (como un hueco
para c贸digo que a煤n no se ha escrito). En ese caso se puede usar la
sentencia \texttt{pass}, que no hace nada.

\index{sentencia pass} \index{sentencia!pass}

\section{Ejecuci贸n alternativa}

\label{alternative execution2}

Una segunda forma de sentencia \texttt{if} es la ejecuci贸n alternativa
en la que hay dos posibilidades y la condici贸n determina cual de ellas
se ejecuta. La sintaxis luce as铆:\inputencoding{latin9}
\begin{lstlisting}
if x%2 == 0:
  print(x, "es par")
else:
  print(x, "es impar")
\end{lstlisting}
\inputencoding{utf8}
Si el residuo de dividir \texttt{x} por 2 es 0, entonces sabemos que
\texttt{x} es par, y el programa despliega un mensaje anunciando esto.
Si la condici贸n es falsa, la segunda sentencia se ejecuta. Como la
condici贸n, que es una expresi贸n booleana, debe ser cierta o falsa,
exactamente una de las alternativas se va a ejecutar. Estas alternativas
se denominan \textbf{ramas}, porque, de hecho, son ramas en el flujo
de ejecuci贸n.

\index{rama}

Y茅ndonos ``por las ramas'', si usted necesita chequear la paridad
(si un n煤mero es par o impar) a menudo, se podr铆a ``envolver'' el
c贸digo anterior en una funci贸n:\inputencoding{latin9}
\begin{lstlisting}
def imprimirParidad(x):
  if x%2 == 0:
    print(x, "es par")
  else:
    print(x, "es impar")
\end{lstlisting}
\inputencoding{utf8}
Para cualquier valor de \texttt{x}, \texttt{imprimirParidad} despliega
un mensaje apropiado. Cuando se llama la funci贸n, se le puede pasar
cualquier expresi贸n entera como argumento.\inputencoding{latin9}
\begin{lstlisting}
>>> imprimirParidad(17)
>>> imprimirParidad(y+1)
\end{lstlisting}
\inputencoding{utf8}
\section{Condicionales encadenados}

\index{condicional encadenados} \index{condicional!encadenados}

Algunas veces hay m谩s de dos posibilidades y necesitamos m谩s de dos
ramas. Una forma de expresar un c谩lculo as铆 es un \textbf{condicional
encadenado}:

\inputencoding{latin9}\begin{lstlisting}
if x < y:
  print(x, "es menor que", y)
elif x > y:
  print(x, "es mayor que", y)
else:
  print(x, "y", y, "son iguales")
\end{lstlisting}
\inputencoding{utf8}
\texttt{elif} es una abreviatura de ``else if.'' De nuevo, exactamente
una de las ramas se ejecutar谩. No hay l铆mite en el n煤mero de sentencias
\texttt{elif}, pero la 煤ltima rama tiene que ser una sentencia \texttt{else}:\inputencoding{latin9}
\begin{lstlisting}
if eleccion == 'A':
  funcionA()
elif eleccion == 'B':
  funcionB()
elif eleccion == 'C':
  funcionC()
else:
  print("Eleccion incorrecta.")
\end{lstlisting}
\inputencoding{utf8}
Cada condici贸n se chequea en orden. Si la primera es falsa, se chequea
la siguiente, y as铆 sucesivamente. Si una de ellas es cierta, se ejecuta
la rama correspondiente y la sentencia termina. Si hay m谩s de una
condici贸n cierta, s贸lo la primera rama que eval煤a a cierto se ejecuta.

\section{Condicionales anidados}

Un condicional tambi茅n se puede anidar dentro de otro. La tricotom铆a
anterior se puede escribir as铆:

\inputencoding{latin9}\begin{lstlisting}
if x == y:
  print(x, "y", y, "son iguales")
else:
  if x < y:
    print(x, "es menor que", y)
  else:
    print(x, "es mayor que", y)
\end{lstlisting}
\inputencoding{utf8} El condicional externo contiene dos ramas: la primera contiene una
sentencia de salida sencilla, la segunda contiene otra sentencia \texttt{if},
que tiene dos ramas propias. Esas dos ramas son sentencias de impresi贸n,
aunque tambi茅n podr铆an ser sentencias condicionales.

Aunque la indentaci贸n o sangrado de las sentencias sugiere la estructura,
los condicionales anidados r谩pidamente se hacen dif铆ciles de leer.
En general, es una buena idea evitarlos cada vez que se pueda.

Los operadores l贸gicos proporcionan formas de simplificar las sentencias
condicionales anidadas. Por ejemplo, podemos reescribir el siguiente
c贸digo usando un solo condicional:\inputencoding{latin9}
\begin{lstlisting}
if 0 < x:
  if x < 10:
    print("x es un digito positivo.")
\end{lstlisting}
\inputencoding{utf8}
La sentencia \texttt{print} se ejecuta solamente si el flujo de ejecuci贸n
ha pasado las dos condiciones, as铆 que podemos usar el operador \texttt{and}:\inputencoding{latin9}
\begin{lstlisting}
if 0 < x and x < 10:
  print("x es un digito positivo.")
\end{lstlisting}
\inputencoding{utf8}
Esta clase de condiciones es muy com煤n, por esta raz贸n Python proporciona
una sintaxis alternativa que es similar a la notaci贸n matem谩tica:\inputencoding{latin9}
\begin{lstlisting}
if 0 < x < 10:
  print("x es un digito positivo")
\end{lstlisting}
\inputencoding{utf8}
Desde el punto de vista sem谩ntico 茅sta condici贸n es la misma que la
expresi贸n compuesta y que el condicional anidado.

\section{La sentencia \texttt{return} }

\index{sentencia return} \index{sentencia!return}

La sentencia \texttt{return} permite terminar la ejecuci贸n de una
funci贸n antes de llegar al final. Una raz贸n para usarla es reaccionar
a una condici贸n de error:

\inputencoding{latin9}\begin{lstlisting}
import math

def imprimirLogaritmo(x):
  if x <= 0:
    print("Numeros positivos solamente. Por favor")
    return

  result = math.log(x)
  print("El logaritmo de ",  x ," es ", result)
\end{lstlisting}
\inputencoding{utf8} La funci贸n \texttt{imprimirLogaritmo} toma un par谩metro denominado
\texttt{x}. Lo primero que hace es chequear si \texttt{x} es menor
o igual a 0, caso en el que despliega un mensaje de error y luego
usa a \texttt{return} para salir de la funci贸n. El flujo de ejecuci贸n
inmediatamente retorna al punto donde se hab铆a llamado la funci贸n,
y las l铆neas restantes de la funci贸n no se ejecutan.

Recuerde que para usar una funci贸n del m贸dulo matem谩tico (math) hay
que importarlo previamente.

\section{Recursi贸n}

\label{recursion} \index{recursi贸n}

Hemos mencionado que es legal que una funci贸n llame a otra, y usted
ha visto varios ejemplos as铆. Hemos olvidado mencionar el hecho de
que una funci贸n tambi茅n puede llamarse a s铆 misma. Al principio no
parece algo 煤til, pero resulta ser una de las capacidades m谩s interesantes
y m谩gicas que un programa puede tener. Por ejemplo, observe la siguiente
funci贸n:

\pagebreak{}

\inputencoding{latin9}\begin{lstlisting}
def conteo(n):
  if n == 0:
    print("Despegue!")
  else:
    print(n)
    conteo(n-1)
\end{lstlisting}
\inputencoding{utf8}
\texttt{conteo} espera que el par谩metro \texttt{n} sea un n煤mero entero
positivo. Si \texttt{n} es 0, despliega la cadena, ``Despegue!''.
Si no lo es, despliega \texttt{n} y luego llama a la funci贸n llamada
\texttt{conteo}ella mismapasando a \texttt{n-1} como argumento.

Analicemos lo que sucede si llamamos a esta funci贸n as铆:\inputencoding{latin9}
\begin{lstlisting}
>>> conteo(3)
\end{lstlisting}
\inputencoding{utf8}
La ejecuci贸n de \texttt{conteo} comienza con \texttt{n=3}, y como
\texttt{n} no es 0, despliega el valor 3, y se llama a s铆 misma ...
\begin{quote}
La ejecuci贸n de \texttt{conteo} comienza con \texttt{n=2}, y como
\texttt{n} no es 0, despliega el valor 2, y se llama a si misma ...

\begin{quote}
La ejecuci贸n de \texttt{conteo} comienza con \texttt{n=1}, y como
\texttt{n} no es 0, despliega el valor 1, y se llama a s铆 misma ...

\begin{quote}
La ejecuci贸n de \texttt{conteo} comienza con \texttt{n=0}, y como
\texttt{n} es 0, despliega la cadena ``Despegue!'' y retorna (finaliza). 
\end{quote}
El \texttt{conteo} que recibi贸 \texttt{n=1} retorna. 
\end{quote}
El \texttt{conteo} que recibi贸 \texttt{n=2} retorna. 
\end{quote}
El \texttt{conteo} que recibi贸 \texttt{n=3} retorna.

Y el flujo de ejecuci贸n regresa a \texttt{\_\_main\_\_} (vaya viaje!).
As铆 que, la salida total luce as铆:
\begin{verbatim}
3
2
1
Despegue!
\end{verbatim}
Como otro ejemplo, utilizaremos nuevamente las funciones \texttt{nuevaLinea}
y \texttt{tresLineas}:

\inputencoding{latin9}\begin{lstlisting}
def nuevalinea():
  print()

def tresLineas():
  nuevaLinea()
  nuevaLinea()
  nuevaLinea()
\end{lstlisting}
\inputencoding{utf8}
Este trabajo no ser铆a de mucha ayuda si quisi茅ramos desplegar 2 l铆neas
o 106. Una mejor alternativa ser铆a:

\inputencoding{latin9}\begin{lstlisting}
def nLineas(n):
  if n > 0:
    print()
    nLineas(n-1)
\end{lstlisting}
\inputencoding{utf8} Esta funci贸n es similar a \texttt{conteo}; en tanto \texttt{n} sea
mayor a 0, despliega una nueva l铆nea y luego se llama a s铆 misma para
desplegar \texttt{n-1} l铆neas adicionales. As铆, el n煤mero total de
nuevas l铆neas es \texttt{1 + (n - 1)} que, si usted verifica con 谩lgebra,
resulta ser \texttt{n}.

El proceso por el cual una funci贸n se llama a s铆 misma es la \textbf{recursi贸n},
y se dice que estas funciones son recursivas.

\index{recursi贸n} \index{funci贸n!recursiva}

\section{Diagramas de pila para funciones recursivas}

\index{diagrama de pila} \index{marco de funci贸n} \index{marco}

En la Secci贸n~\ref{stackdiagram}, usamos un diagrama de pila para
representar el estado de un programa durante un llamado de funci贸n.
La misma clase de diagrama puede ayudarnos a interpretar una funci贸n
recursiva.

Cada vez que una funci贸n se llama, Python crea un nuevo marco de funci贸n
que contiene los par谩metros y variables locales de 茅sta. Para una
funci贸n recursiva, puede existir m谩s de un marco en la pila al mismo
tiempo.

Este es el diagrama de pila para \texttt{conteo} llamado con \texttt{n
= 3}:

\beforefig \centerline{\includegraphics{illustrations/stack2}}
\afterfig

Como siempre, el tope de la pila es el marco para \texttt{\_\_main\_\_}.
Est谩 vac铆o porque no creamos ninguna variable en \texttt{\_\_main\_\_}
ni le pasamos par谩metros.

Los cuatro marcos de \texttt{conteo} tienen diferentes valores para
el par谩metro \texttt{n}. El fondo de la pila, donde \texttt{n=0},
se denomina el \textbf{caso base }. Como no hace una llamada recursiva,
no hay mas marcos.

\index{case base} \index{recursi贸n!caso base}

\section{Recursi贸n infinita}

\index{recursi贸n infinita} \index{recursi贸n!infinita} \index{error de tiempo de ejecuci贸n}
\index{error!de tiempo de ejecuci贸n} \index{trazado inverso}

Si una funci贸n recursiva nunca alcanza un caso base va a hacer llamados
recursivos por siempre y el programa nunca termina. Esto se conoce
como \textbf{recursi贸n infinita}, y, generalmente, no se considera
una buena idea. Aqu铆 hay un programa minimalista con recursi贸n infinita:

\inputencoding{latin9}\begin{lstlisting}
def recurrir():
  recurrir()
\end{lstlisting}
\inputencoding{utf8} En la mayor铆a de ambientes de programaci贸n un programa con recursi贸n
infinita no corre realmente para siempre. Python reporta un mensaje
de error cuando alcanza la m谩xima profundidad de recursi贸n:
\begin{verbatim}
  File "<stdin>", line 2, in recurrir
  (98 repeticiones omitidas)
  File "<stdin>", line 2, in recurrir
RuntimeError: Maximum recursion depth exceeded
\end{verbatim}
Este trazado inverso es un poco m谩s grande que el que vimos en el
cap铆tulo anterior. Cuando se presenta el error, 隆hay m谩s de 100 marcos
de \texttt{recurrir} en la pila!.

\section{Entrada por el teclado}

Los programas que hemos escrito son un poco toscos ya que no aceptan
entrada de un usuario. S贸lo hacen la misma operaci贸n todo el tiempo.

Python proporciona funciones primitivas que obtienen entrada desde
el teclado. La m谩s sencilla se llama \texttt{raw\_input}. Cuando esta
funci贸n se llama el programa se detiene y espera a que el usuario
digite algo. Cuando el usuario digita la tecla Enter o Intro, el programa
retoma la ejecuci贸n y \texttt{raw\_input} retorna lo que el usuario
digit贸 como una cadena (\texttt{string}):

\inputencoding{latin9}\begin{lstlisting}
>>> entrada = raw_input ()
Que esta esperando?
>>> print(entrada)
Que esta esperando?
\end{lstlisting}
\inputencoding{utf8} Antes de llamar a \texttt{raw\_input} es una muy buena idea desplegar
un mensaje dici茅ndole al usuario qu茅 digitar. Este mensaje se denomina
indicador de entrada (\textbf{prompt} en ingl茅s). Podemos dar un argumento
prompt a \texttt{raw\_input}:

\index{prompt}

\inputencoding{latin9}\begin{lstlisting}
>>> nombre = raw_input ("Cual es tu nombre? ")
Cual es tu nombre? Arturo, Rey de los Bretones!
>>> print(nombre)
Arturo, Rey de los Bretones!
\end{lstlisting}
\inputencoding{utf8}
Si esperamos que la respuesta sea un entero, podemos usar la funci贸n
\texttt{input}:

\inputencoding{latin9}\begin{lstlisting}
prompt = "Cual es la velocidad de una golondrina sin carga?\n"
velocidad = input(prompt)
\end{lstlisting}
\inputencoding{utf8} Si el usuario digita una cadena de d铆gitos, 茅stos se convierten a
un entero que se asigna a \texttt{velocidad}. Desafortunadamente,
si el usuario digita una entrada que no representa un d铆gito, velocidad
almacenar谩 una cadena de texto.

\inputencoding{latin9}\begin{lstlisting}
>>> prompt = "Cual es la velocidad una golondrina sin carga?\n"
>>> velocidad = input (prompt)
Que quiere decir, una golondria Africana o Europea?
\end{lstlisting}
\inputencoding{utf8}
Para evitar este error, es una buena idea usar \texttt{raw\_input}
para obtener una cadena y las funciones de conversi贸n (int, float)
para transformarla en otros tipos.

\section{Glosario}
\begin{description}
\item [{Operador residuo:}] operador que se denota con un signo porcentaje
(\texttt{\%}), y trabaja sobre enteros produciendo el residuo de un
n煤mero al dividirlo por otro.
\item [{Expresi贸n booleana:}] expresi贸n cierta o falsa.
\item [{Operador de comparaci贸n:}] uno de los operadores que compara
dos valores: \texttt{==}, \texttt{!=}, \texttt{>}, \texttt{<}, \texttt{>=},
y \texttt{<=}.
\item [{Operador l贸gico:}] uno de los operadores que combina expresiones
booleanas: \texttt{and}, \texttt{or}, y \texttt{not}.
\item [{Sentencia condicional:}] sentencia que controla el flujo de ejecuci贸n
dependiendo de alguna condici贸n.
\item [{Condici贸n:}] la expresi贸n booleana en una sentencia condicional
que determina que rama se ejecuta.
\item [{Sentencia compuesta:}] es la sentencia que comprende una cabecera
y un cuerpo. La cabecera termina con dos puntos seguidos (:). El cuerpo
se sangra o indenta con respecto a la cabecera.
\item [{Bloque:}] grupo de sentencias consecutivas con la misma indentaci贸n.
\item [{Cuerpo:}] el bloque, en una sentencia compuesta, que va despu茅s
de la cabecera.
\item [{Anidamiento:}] situaci贸n en la que hay una estructura dentro de
otra, tal como una sentencia condicional dentro de una rama de otra
sentencia condicional.
\item [{Recursi贸n:}] es el proceso de llamar la funci贸n que se est谩 ejecutando
actualmente.
\item [{Caso base:}] corresponde a una rama de la sentencia condicional
dentro de una funci贸n recursiva, que no hace un llamado recursivo.
\item [{Recursi贸n infinita:}] funci贸n que se llama a s铆 misma recursivamente
sin alcanzar nunca el caso base. En Python una recursi贸n infinita
eventualmente causa un error en tiempo de ejecuci贸n.
\item [{Prompt (indicador de entrada):}] una pista visual que le indica
al usuario que digite alguna informaci贸n.

\index{operador residuo} \index{expresi贸n booleana} \index{expresi贸n!booleana}
\index{sentencia condicional} \index{sentencia!condicional} \index{condici贸n}
\index{sentencia compuesta} \index{rama} \index{cuerpo} \index{bloque}
\index{anidamiento} \index{recursi贸n} \index{caso base} \index{recursi贸n infinita}
\index{prompt}
\end{description}

\section{Ejercicios}
\begin{enumerate}
\item Eval煤e la expresi贸n \verb+7 % 0+. Explique lo que ocurre.
\item Envuelva el c贸digo que viene a continuaci贸n en una funci贸n llamada
\verb+comparar(x, y)+. Llame a la funci贸n comparar tres veces: una
en la que el primer argumento sea menor que el segundo, otra en la
que aquel sea mayor que 茅ste, y una tercera en la que los argumentos
sean iguales. \inputencoding{latin9}
\begin{lstlisting}
 if x < y:
    print(x, "es menor que", y)
 elif x > y:
    print(x, "es mayor que", y)
 else:
    print(x, "y", y, "son iguales")
\end{lstlisting}
\inputencoding{utf8}\item Copie este programa en un archivo llamado tabladeverdad.py: \inputencoding{latin9}
\begin{lstlisting}
def tabladeverdad(expresion):
    print(" p      q      %s"  % expresion)
    longitud = len( " p      q      %s"  % expresion)
    print(longitud*"=")

    for p in True, False:
        for q in True, False:
            print("%-7s %-7s %-7s" % (p, q, eval(expresion)))
\end{lstlisting}
\inputencoding{utf8}
\begin{verbatim}
 
\end{verbatim}
Pru茅belo con el llamado \verb+tabladeverdad("p or q")+. Ahora ejec煤telo
con las siguientes expresiones: 
\begin{enumerate}
\item \texttt{\textquotedbl{}not(p or q)\textquotedbl{}} 
\item \texttt{\textquotedbl{}p and q\textquotedbl{}} 
\item \texttt{\textquotedbl{}not(p and q)\textquotedbl{}} 
\item \texttt{\textquotedbl{}not(p) or not(q)\textquotedbl{}} 
\item \texttt{\textquotedbl{}not(p) and not(q)\textquotedbl{} }
\end{enumerate}
驴Cuales de estas expresiones tienen el mismo valor de verdad (son
l贸gicamente equivalentes)?
\end{enumerate}

