%% LyX 2.2.3 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[oneside]{book}
\usepackage[utf8]{inputenc}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\synctex=-1
\usepackage{graphicx}
\usepackage{listings}
\renewcommand{\lstlistingname}{\inputencoding{latin9}Listado de cÛdigo}

\begin{document}

\chapter{El camino hacia el programa}

El objetivo de este libro es el de ense√±ar al estudiante a pensar
como lo hacen los cient√≠ficos inform√°ticos. Esta manera de pensar
combina las mejores caracter√≠sticas de la matem√°tica, la ingenier√≠a
y las ciencias naturales. Como los matem√°ticos, los cient√≠ficos inform√°ticos
usan lenguajes formales para dise√±ar ideas (espec√≠ficamente, c√≥mputos).
Como los ingenieros, ellos dise√±an cosas, construyendo sistemas mediante
el ensamble de componentes y evaluando las ventajas y desventajas
de cada una de las alternativas de construcci√≥n. Como los cient√≠ficos,
ellos observan el comportamiento de sistemas complejos, forman hip√≥tesis,
y prueban sus predicciones.

La habilidad m√°s importante del cient√≠fico inform√°tico es \textbf{la
soluci√≥n de problemas}. La soluci√≥n de problemas incluye poder formular
problemas, pensar en soluciones de manera creativa y expresar soluciones
clara y precisamente. Como se ver√°, el proceso de aprender a programar
es la oportunidad perfecta para desarrollar la habilidad de resolver
problemas. Por esa raz√≥n este cap√≠tulo se llama ``El camino hacia
el programa''.

A cierto nivel, usted aprender√° a programar, lo cual es una habilidad
muy √∫til por s√≠ misma. A otro nivel, usted utilizar√° la programaci√≥n
para obtener alg√∫n resultado. Ese resultado se ver√° m√°s claramente
durante el proceso.

\section{El lenguaje de programaci√≥n Python}

\index{lenguaje de programaci√≥n} \index{lenguaje!programaci√≥n}

El lenguaje de programaci√≥n que aprender√° es Python. Python es un
ejemplo de \textbf{lenguaje de alto nivel}; otros ejemplos de lenguajes
de alto nivel son C, C++, Perl y Java.

Como se puede deducir de la nomenclatura ``lenguaje de alto nivel,''
tambi√©n existen \textbf{lenguajes de bajo nivel}, que tambi√©n se denominan
lenguajes de m√°quina o lenguajes ensambladores. A prop√≥sito, las computadoras
s√≥lo ejecutan programas escritos en lenguajes de bajo nivel. Los programas
de alto nivel tienen que ser traducidos antes de ser ejecutados. Esta
traducci√≥n lleva tiempo, lo cual es una peque√±a desventaja de los
lenguajes de alto nivel.

\index{port√°til} \index{lenguaje de alto nivel} \index{lenguaje de bajo nivel}
\index{lenguaje!alto nivel} \index{lenguaje!bajo nivel}

Aun as√≠, las ventajas son enormes. En primer lugar, la programaci√≥n
en lenguajes de alto nivel es mucho m√°s f√°cil; escribir programas
en un lenguaje de alto nivel toma menos tiempo ya que los programas
son m√°s cortos, m√°s f√°ciles de leer, y es m√°s probable que queden
correctos. En segundo lugar, los lenguajes de alto nivel son \textbf{portables},
lo que significa que los programas escritos con estos pueden ser ejecutados
en tipos diferentes de computadoras sin modificaci√≥n alguna o con
pocas modificaciones. Programas escritos en lenguajes de bajo nivel
s√≥lo pueden ser ejecutados en un tipo de computadora y deben ser reescritos
para ser ejecutados en otra.

Debido a estas ventajas, casi todo programa se escribe en un lenguaje
de alto nivel. Los lenguajes de bajo nivel son s√≥lo usados para unas
pocas aplicaciones especiales.

\index{compilar} \index{interpretar}

Hay dos tipos de programas que traducen lenguajes de alto nivel a
lenguajes de bajo nivel: \textbf{int√©rpretes} y \textbf{compiladores}.
Un int√©rprete lee un programa de alto nivel y lo ejecuta, lo que significa
que lleva a cabo lo que indica el programa. Traduce el programa poco
a poco, leyendo y ejecutando cada comando.

\vspace{0.1in}
 \centerline{\includegraphics[scale=0.7]{illustrations/interpret}}
\vspace{0.1in}

Un compilador lee el programa y lo traduce todo al mismo tiempo, antes
de ejecutar alguno de los programas. A menudo se compila un programa
como un paso aparte, y luego se ejecuta el c√≥digo compilado. En este
caso, al programa de alto nivel se lo llama el \textbf{c√≥digo fuente},
y al programa traducido es llamado el \textbf{c√≥digo de objeto} o
el \textbf{c√≥digo ejecutable}.

\vspace{0.1in}
 \centerline{\includegraphics[scale=0.7]{illustrations/compile}}
\vspace{0.1in}

A Python se lo considera un lenguaje interpretado, porque sus programas
son ejecutados por un int√©rprete. Existen dos maneras de usar el int√©rprete:
modo de comando y modo de gui√≥n. En modo de comando se escriben sentencias
en el lenguaje Python y el int√©rprete muestra el resultado.
\begin{verbatim}
$python
Python 3.6.1 (default, Apr 29 2017, 15:32:44) [GCC 5.4.0] on linux 
Type "help", "copyright", "credits" or "license" for more information. 
>>>1+1
2
\end{verbatim}
La primera l√≠nea de este ejemplo es el comando que pone en marcha
al int√©rprete de Python. Las dos l√≠neas siguientes son mensajes del
int√©rprete. La tercera l√≠nea comienza con {\verb+>>>+}, lo que
indica que el int√©rprete est√° listo para recibir comandos. Escribimos
\texttt{1+1} y el int√©rprete contest√≥ \texttt{2}.

Alternativamente, se puede escribir el programa en un archivo y usar
el int√©rprete para ejecutar el contenido de dicho archivo. El archivo,
en este caso, se denomina un \textbf{gui√≥n (script)}; por ejemplo,
en un editor de texto se puede crear un archivo \texttt{unomasuno.py}
que contenga esta l√≠nea:

\inputencoding{latin9}\begin{lstlisting}
print(1 + 1)
\end{lstlisting}
\inputencoding{utf8}
Por acuerdo un√°nime, los archivos que contienen programas de Python
tienen nombres que terminan con \texttt{.py}. Para ejecutar el programa,
se le tiene que indicar el nombre del gui√≥n al int√©rprete.

\inputencoding{latin9}\begin{lstlisting}
$ python unomasuno.py
2
\end{lstlisting}
\inputencoding{utf8}\begin{verbatim}

\end{verbatim}
En otros entornos de desarrollo, los detalles de la ejecuci√≥n de programas
diferir√°n. Adem√°s, la mayor√≠a de programas son m√°s interesantes que
el anterior.

La mayor√≠a de ejemplos en este libro son ejecutados en la l√≠nea de
comandos. La l√≠nea de comandos es m√°s conveniente para el desarrollo
de programas y para pruebas r√°pidas, porque las instrucciones de Python
se pueden pasar a la m√°quina para ser ejecutadas inmediatamente. Una
vez que el programa est√° completo, se lo puede archivar en un gui√≥n
para ejecutarlo o modificarlo en el futuro.

\section{¬øQu√© es un programa?}

Un programa es una secuencia de instrucciones que especifican c√≥mo
ejecutar un c√≥mputo. El c√≥mputo puede ser matem√°tico, c√≥mo solucionar
un sistema de ecuaciones o determinar las ra√≠ces de un polinomio,
pero tambi√©n puede ser simb√≥lico, c√≥mo buscar y reemplazar el texto
de un documento o (aunque parezca raro) compilar un programa.

\index{instrucci√≥n}

Las instrucciones (comandos, √≥rdenes) tienen una apariencia diferente
en lenguajes de programaci√≥n diferentes, pero existen algunas funciones
b√°sicas que se presentan en casi todo lenguaje:
\begin{description}
\item [{Entrada:}] recibir datos del teclado, o de un archivo o de otro
aparato.
\item [{Salida:}] mostrar datos en el monitor o enviar datos a un archivo
u otro aparato.
\item [{Matem√°ticas:}] ejecutar operaciones b√°sicas, como la adici√≥n y
la multiplicaci√≥n.
\item [{Operaci√≥n condicional:}] probar la veracidad de alguna condici√≥n
y ejecutar una secuencia de instrucciones apropiada.
\item [{Repetici√≥n}] ejecutar alguna acci√≥n repetidas veces, usualmente
con alguna variaci√≥n.
\end{description}
Aunque sea dif√≠cil de creer, todos los programas en existencia son
formulados exclusivamente con tales instrucciones. As√≠, una manera
de describir la programaci√≥n es: el proceso de romper una tarea en
tareas cada vez m√°s peque√±as hasta que √©stas sean lo suficientemente
sencillas como para ser ejecutadas con una secuencia de estas instrucciones
b√°sicas.

Quiz√°s esta descripci√≥n es un poco ambigua. No se preocupe. Explicaremos
√©sto con m√°s detalle en el tema de \textbf{algoritmos}.

\section{¬øQu√© es la depuraci√≥n (debugging)?}

\index{depuraci√≥n (debugging)} \index{error (bug)}

La programaci√≥n es un proceso complejo, y a veces este proceso lleva
a \textbf{errores indefinidos}, tambi√©n llamados \textbf{defectos}
o \textbf{errores de programaci√≥n} (en ingl√©s `bugs'), y el proceso
de buscarlos y corregirlos es llamado \textbf{depuraci√≥n} (en ingl√©s
`debugging').

Hay tres tipos de errores que pueden ocurrir en un programa. Es muy
√∫til distinguirlos para encontrarlos m√°s r√°pido.

\subsection{Errores sint√°cticos}

\index{error sint√°ctico} \index{error!sintaxis}

Python s√≥lo puede ejecutar un programa si est√° sint√°cticamente bien
escrito. Al contrario, es decir, si el programa tiene alg√∫n error
de sintaxis, el proceso falla y devuelve un mensaje de error. La palabra
\textbf{sint√°ctica} se refiere a la estructura de cualquier programa
y a las reglas de esa estructura. \index{sint√°ctica} Por ejemplo,
en espa√±ol, la primera letra de toda oraci√≥n debe ser may√∫scula y
el fin de toda oraci√≥n debe llevar un punto. esta oraci√≥n tiene un
error sint√°ctico. Esta oraci√≥n tambi√©n

Para la mayor√≠a de lectores, unos pocos errores no impiden la comprensi√≥n
de los grafitis en la calle que, a menudo, rompen muchas reglas de
sintaxis. Sin embargo Python no es as√≠. Si hay aunque sea un error
sint√°ctico en el programa, Python mostrar√° un mensaje de error y abortar√°
su ejecuci√≥n. Al principio usted pasar√° mucho tiempo buscando errores
sint√°cticos, pero con el tiempo no cometer√° tantos errores y los encontrar√°
r√°pidamente.

\subsection{Errores en tiempo de ejecuci√≥n}

\label{runtime} \index{error en tiempo de ejecuci√≥n} \index{error!en tiempo de ejecuci√≥n}
\index{excepci√≥n} \index{lenguaje seguro} \index{seguro!lenguaje}

El segundo tipo de error es el de tiempo de ejecuci√≥n. Este error
aparece s√≥lo cuando se ejecuta un programa. Estos errores tambi√©n
se llaman \textbf{excepciones}, porque indican que algo excepcional
ha ocurrido.

Con los programas que vamos a escribir al principio, los errores de
tiempo de ejecuci√≥n ocurrir√°n con poca frecuencia.

\subsection{Errores sem√°nticos}

\index{sem√°ntica} \index{error sem√°ntico} \index{sem√°ntico!error}

El tercer tipo de error es el \textbf{sem√°ntico}. Si hay un error
de l√≥gica en su programa, √©ste ser√° ejecutado sin ning√∫n mensaje de
error, pero el resultado no ser√° el deseado. El programa ejecutar√°
la l√≥gica que usted le dijo que ejecutara.

A veces ocurre que el programa escrito no es el que se ten√≠a en mente.
El sentido o significado del programa no es correcto. Es dif√≠cil hallar
errores de l√≥gica. Eso requiere trabajar al rev√©s, comenzando a analizar
la salida para encontrar al problema.

\subsection{Depuraci√≥n experimental}

Una de las t√©cnicas m√°s importantes que usted aprender√° es la depuraci√≥n.
Aunque a veces es frustrante, la depuraci√≥n es una de las partes de
la programaci√≥n m√°s estimulantes, interesantes e intelectualmente
exigentes.

La depuraci√≥n es una actividad parecida a la tarea de un investigador:
se tienen que estudiar las pistas para inferir los procesos y eventos
que han generado los resultados encontrados.

La depuraci√≥n tambi√©n es una ciencia experimental. Una vez que se
tiene conciencia de un error, se modifica el programa y se intenta
nuevamente. Si la hip√≥tesis fue la correcta se pueden predecir los
resultados de la modificaci√≥n y estaremos m√°s cerca a un programa
correcto. Si la hip√≥tesis fue la err√≥nea tendr√° que idearse otra hip√≥tesis.
Como dijo Sherlock Holmes: ``Cuando se ha descartado lo imposible,
lo que queda, no importa cuan inveros√≠mil, debe ser la verdad'' (A.
Conan Doyle, {\em The Sign of Four})

\index{Holmes, Sherlock} \index{Doyle, Arthur Conan}

Para algunas personas, la programaci√≥n y la depuraci√≥n son lo mismo:
la programaci√≥n es el proceso de depurar un programa gradualmente,
hasta que el programa tenga el resultado deseado. Esto quiere decir
que el programa debe ser, desde un principio, un programa que funcione,
aunque su funci√≥n sea solo m√≠nima. El programa es depurado mientras
crece y se desarrolla.

Por ejemplo, aunque el sistema operativo Linux contenga miles de l√≠neas
de instrucciones, Linus Torvalds lo comenz√≥ como un programa para
explorar el microprocesador Intel 80836. Seg√∫n Larry Greenfield: ``Uno
de los proyectos tempranos de Linus fue un programa que intercambiar√≠a
la impresi√≥n de AAAA con BBBB. Este programa se convirti√≥ en Linux''
(de {\em The Linux Users' Guide} Versi√≥n Beta 1).

\index{Linux}

Otros cap√≠tulos tratar√°n m√°s el tema de la depuraci√≥n y otras t√©cnicas
de programaci√≥n.

\section{Lenguajes formales y lenguajes naturales}

\index{lenguaje formal} \index{lenguaje natural} \index{formal!lenguaje}
\index{natural!lenguaje}

Los \textbf{lenguajes naturales} son los hablados por seres humanos,
como el espa√±ol, el ingl√©s y el franc√©s. √âstos no han sido dise√±ados
artificialmente (aunque se trate de imponer cierto orden en ellos),
pues se han desarrollado naturalmente.

Los \textbf{Lenguajes formales} son dise√±ados por humanos y tienen
aplicaciones espec√≠ficas. La notaci√≥n matem√°tica, por ejemplo, es
un lenguaje formal, ya que se presta a la representaci√≥n de las relaciones
entre n√∫meros y s√≠mbolos. Los qu√≠micos utilizan un lenguaje formal
para representar la estructura qu√≠mica de las mol√©culas. Es necesario
notar que:
\begin{quote}
\textbf{Los lenguajes de programaci√≥n son formales y han sido desarrollados
para expresar c√≥mputos.} 
\end{quote}
Los lenguajes formales casi siempre tienen reglas sint√°cticas estrictas.
Por ejemplo, $3+3=6$ es una expresi√≥n matem√°tica correcta, pero $3=+6\$$
no lo es. De la misma manera, $H_{2}O$ es una nomenclatura qu√≠mica
correcta, pero $_{2}Zz$ no lo es.

Existen dos clases de reglas sint√°cticas, en cuanto a unidades y estructura.
Las unidades son los elementos b√°sicos de un lenguaje, como lo son
las palabras, los n√∫meros y los elementos qu√≠micos. Por ejemplo, en
\texttt{3=+6\$}, \texttt{\$} no es una unidad matem√°tica aceptada.
Similarmente, $_{2}Zz$ no es formal porque no hay ning√∫n elemento
qu√≠mico con la abreviaci√≥n $Zz$.

La segunda clase de error sint√°ctico est√° relacionado con la estructura
de un elemento; mejor dicho, el orden de las unidades. La estructura
de la sentencia \texttt{3=+6\$} no es aceptada porque no se puede
escribir el s√≠mbolo de igualdad seguido de un s√≠mbolo m√°s. Similarmente,
las f√≥rmulas moleculares tienen que mostrar el n√∫mero de sub√≠ndice
despu√©s del elemento, no antes.

Al leer una oraci√≥n, sea en un lenguaje natural o una sentencia en
un lenguaje t√©cnico, se debe discernir la estructura de la oraci√≥n.
En un lenguaje natural este proceso, llamado \textbf{an√°lisis sint√°ctico},
ocurre subconscientemente.

\index{analizar sint√°cticamente}

Por ejemplo cuando se escucha una oraci√≥n simple como ``el otro zapato
se cay√≥'', se puede distinguir el sustantivo ``el otro zapato''
y el predicado ``se cay√≥''. Cuando se ha analizado la oraci√≥n sint√°cticamente,
se puede deducir el significado, o la sem√°ntica, de la oraci√≥n. Si
usted sabe lo que es un zapato y el significado de caer, comprender√°
el significado de la oraci√≥n.

Aunque existen muchas cosas en com√∫n entre los lenguajes naturales
y los formales‚Äîpor ejemplo las unidades, la estructura, la sint√°ctica
y la sem√°ntica‚Äî tambi√©n existen muchas diferencias.

\index{Ambig√ºedad} \index{Redundancia} \index{Literalidad}
\begin{description}
\item [{Ambig√ºedad:}] los lenguajes naturales tienen much√≠simas ambig√ºedades
que se superan usando claves contextuales e informaci√≥n adicional.
Los lenguajes formales son dise√±ados para estar completamente libres
de ambig√ºedades o, tanto como sea posible, lo que quiere decir que
cualquier sentencia tiene s√≥lo un significado sin importar el contexto
en el que se encuentra.
\item [{Redundancia:}] para reducir la ambig√ºedad y los malentendidos,
los lenguajes naturales utilizan bastante redundancia. Como resultado
tienen una abundancia de posibilidades para expresarse. Los lenguajes
formales son menos redundantes y mas concisos.
\item [{Literalidad:}] los lenguajes naturales tienen muchas met√°foras
y frases comunes. El significado de un dicho, por ejemplo: ``Estirar
la pata'', es diferente al significado de sus sustantivos y verbos.
En este ejemplo, la oraci√≥n no tiene nada que ver con una pata y significa
'morirse'. En los lenguajes formales solo existe el significado literal.
\end{description}
Los que aprenden a hablar un lenguaje natural‚Äîes decir todo el mundo‚Äîmuchas
veces tienen dificultad en adaptarse a los lenguajes formales. A veces
la diferencia entre los lenguajes formales y los naturales es comparable
a la diferencia entre la prosa y la poes√≠a:

\index{Poes√≠a} \index{Prosa}
\begin{description}
\item [{Poes√≠a:}] se utiliza una palabra por su cualidad auditiva tanto
como por su significado. El poema, en su totalidad, produce un efecto
o reacci√≥n emocional. La ambig√ºedad no es s√≥lo com√∫n, sino utilizada
a prop√≥sito.
\item [{Prosa:}] el significado literal de la palabra es m√°s importante
y la estructura contribuye m√°s al significado. La prosa se presta
m√°s al an√°lisis que la poes√≠a, pero todav√≠a contiene ambig√ºedad.
\item [{Programa:}] el significado de un programa es inequ√≠voco y literal,
y es entendido en su totalidad analizando las unidades y la estructura.
\end{description}
He aqu√≠ unas sugerencias para la lectura de un programa (y de otros
lenguajes formales). Primero, recuerde que los lenguajes formales
son mucho m√°s densos que los lenguajes naturales y, por consecuencia,
toma mas tiempo dominarlos. Adem√°s, la estructura es muy importante,
entonces no es una buena idea leerlo de pies a cabeza, de izquierda
a derecha. En lugar de √©sto, aprenda a separar las diferentes partes
en su mente, identificar las unidades e interpretar la estructura.
Finalmente, ponga atenci√≥n a los detalles. La fallas de puntuaci√≥n
y la ortograf√≠a afectar√°n negativamente la ejecuci√≥n de sus programas.

\section{El primer programa}

\label{hello} \label{hello world}

Tradicionalmente el primer programa en un lenguaje nuevo se llama
``Hola todo el mundo!'' (en ingl√©s, Hello world!) porque s√≥lo muestra
las palabras ``Hola todo el mundo'' . En el lenguaje Python es as√≠:

\inputencoding{latin9}\begin{lstlisting}
print("Hola todo el mundo!")
\end{lstlisting}
\inputencoding{utf8}
Este es un ejemplo de llamado a la funci√≥n {\em print}, la cual
no imprime nada en papel, m√°s bien muestra un valor. En este caso,
el resultado es mostrar en pantalla las palabras:

\inputencoding{latin9}\begin{lstlisting}
Hola todo el mundo!
\end{lstlisting}
\inputencoding{utf8}
Las comillas se√±alan el comienzo y el final del valor; no aparecen
en el resultado.

\index{funci√≥n print} \index{print!funci√≥n}

Hay gente que eval√∫a la calidad de un lenguaje de programaci√≥n por
la simplicidad del programa ``Hola todo el mundo!''. Si seguimos
ese criterio, Python cumple con esta meta.

\section{Glosario}
\begin{description}
\item [{Soluci√≥n de problemas:}] el proceso de formular un problema,
hallar la soluci√≥n y expresarla.
\item [{Lenguaje de alto nivel:}] un lenguaje como Python que es dise√±ado
para ser f√°cil de leer y escribir por la gente.
\item [{Lenguaje de bajo nivel:}] un lenguaje de programaci√≥n que es dise√±ado
para ser f√°cil de ejecutar para una computadora; tambi√©n se lo llama
``lenguaje de m√°quina'' o ``lenguaje ensamblador''.
\item [{Portabilidad:}] la cualidad de un programa que puede ser ejecutado
en m√°s de un tipo de computadora.
\item [{Interpretar:}] ejecutar un programa escrito en un lenguaje de alto
nivel traduci√©ndolo l√≠nea por l√≠nea.
\item [{Compilar:}] traducir un programa escrito en un lenguaje de alto
nivel a un lenguaje de bajo nivel de una vez, en preparaci√≥n para
la ejecuci√≥n posterior.
\item [{C√≥digo fuente:}] un programa escrito en un lenguaje de alto nivel
antes de ser compilado.
\item [{C√≥digo objeto:}] la salida del compilador una vez que el programa
ha sido traducido.
\item [{Programa ejecutable:}] otro nombre para el c√≥digo de objeto que
est√° listo para ser ejecutado.
\item [{Gui√≥n (script):}] un programa archivado (que va a ser interpretado).
\item [{Programa:}] un grupo de instrucciones que especifica un c√≥mputo.
\item [{Algoritmo:}] un proceso general para resolver una clase completa
de problemas.
\item [{Error (bug):}] un error en un programa.
\item [{Depuraci√≥n:}] el proceso de hallazgo y eliminaci√≥n de los tres
tipos de errores de programaci√≥n.
\item [{Sintaxis:}] la estructura de un programa.
\item [{Error sint√°ctico:}] un error estructural que hace que un programa
sea imposible de analizar sint√°cticamente (e imposible de interpretar).
\item [{Error en tiempo de ejecuci√≥n:}] un error que no ocurre hasta
que el programa ha comenzado a ejecutar e impide que el programa contin√∫e.
\item [{Excepci√≥n:}] otro nombre para un error en tiempo de ejecuci√≥n.
\item [{Error sem√°ntico:}] un error en un programa que hace que ejecute
algo que no era lo deseado.
\item [{Sem√°ntica:}] el significado de un programa.
\item [{Lenguaje natural:}] cualquier lenguaje hablado que evolucion√≥
de forma natural.
\item [{Lenguaje formal:}] cualquier lenguaje dise√±ado que tiene un prop√≥sito
espec√≠fico, como la representaci√≥n de ideas matem√°ticas o programas
de computadoras; todos los lenguajes de programaci√≥n son lenguajes
formales.
\item [{Unidad:}] uno de los elementos b√°sicos de la estructura sint√°ctica
de un programa, an√°logo a una palabra en un lenguaje natural.
\item [{An√°lisis sint√°ctico:}] la revisi√≥n de un programa y el an√°lisis
de su estructura sint√°ctica.
\item [{Funci√≥n print:}] una funci√≥n que causa que el int√©rprete de Python
muestre un valor en la pantalla.

\index{programa} \index{soluci√≥n de problemas} \index{lenguaje de alto nivel}
\index{lenguaje de bajo nivel} \index{portabilidad} \index{interpretar}
\index{compilar} \index{c√≥digo de fuente} \index{c√≥digo de objeto}
\index{c√≥digo ejecutable} \index{algoritmo} \index{error(bug)}
\index{depuraci√≥n} \index{sintaxis} \index{sem√°ntica} \index{error sint√°ctico}
\index{error en tiempo de ejecuci√≥n} \index{excepci√≥n} \index{error sem√°ntico}
\index{lenguaje formal} \index{lenguaje natural} \index{an√°lisis sint√°ctico}
\index{unidad} \index{gui√≥n} \index{funci√≥n print} \index{print!funci√≥n}
\end{description}

\section{Ejercicios}

En los ejercicios 1,2,3 y 4 escriba una oraci√≥n en espa√±ol:\\
 \\
\begin{enumerate}
\item Con estructura v√°lida pero compuesta de unidades irreconocibles.
\item Con unidades aceptables pero con estructura no v√°lida.
\item Sem√°nticamente comprensible pero sint√°cticamente incorrecta.
\item Sint√°cticamente correcta pero que contenga errores sem√°nticos.
\item Inicie la terminal de Python. Escriba 1 + 2 y luego presione la tecla
Entrar. Python eval√∫a esta expresi√≥n, presenta el resultado, y enseguida
muestra otro int√©rprete. Considerando que el s√≠mbolo {*} es el signo
de multiplicaci√≥n y el doble s√≠mbolo {*}{*} es el signo de potenciaci√≥n,
realice dos ejercicios adicionales escribiendo diferentes expresiones
y reportando lo mostrado por el int√©rprete de Python.
\item ¬øQu√© sucede si utiliza el signo de divisi√≥n (/)? ¬øSon los resultados
obtenidos los esperados? Explique.
\item Escriba 1 2 y presione la tecla Entrar. Python trata de evaluar esta
expresi√≥n, pero no puede, porque la expresi√≥n es sint√°cticamente incorrecta.
As√≠, Python responde con el siguiente mensaje de error:

\begin{verbatim}
 File "<stdin>", line 1

    1 2

      ^

SyntaxError: invalid syntax
\end{verbatim}
Muchas veces Python indica la ubicaci√≥n del error de sintaxis, sin
embargo, no siempre es precisa, por lo que no proporciona suficiente
informaci√≥n sobre cu√°l es el problema. De esta manera, el mejor ant√≠doto
es que usted aprenda la sintaxis de Python. En este caso, Python protesta
porque no encuentra signo de operaci√≥n alguno entre los n√∫meros.

Escriba una entrada que produzca un mensaje de error cuando se introduzca
en el int√©rprete de Python. Explique por qu√© no tiene una sintaxis
v√°lida.
\item Escriba \verb+print('hola')+. Python ejecuta esta sentencia que muestra
las letras h-o-l-a. N√≥tese que las comillas simples en los extremos
de la cadena no son parte de la salida mostrada. Ahora escriba \verb+print('"hola"')+
y describa y explique el resultado.
\item Escriba \verb+print(queso)+ sin comillas. ¬øQue sucede?
\item Escriba \verb+'Esta es una prueba...'+ en el int√©rprete de Python
y presione la tecla Entrar. Observe lo que pasa.
\item Ahora cree un gui√≥n de Python con el nombre prueba1.py que contenga
lo siguiente (aseg√∫rese de guardar el archivo antes de intentar ejecutarlo):
'Esta es una prueba...'

¬øQu√© pasa cuando ejecuta este gui√≥n?
\item Ahora cambie el contenido del gui√≥n a: \verb+print('Esta es una prueba...')+
y ejecutelo de nuevo.

¬øQu√© pas√≥ esta vez?

Cuando se escribe una expresi√≥n en el int√©rprete de Python, √©sta es
evaluada y el resultado es mostrado en la l√≠nea siguiente. 'Esta es
una prueba...' es una expresi√≥n, que se eval√∫a a 'Esta es una prueba...'
(de la misma manera que 42 se eval√∫a a 42). Sin embargo, la evaluaci√≥n
de expresiones en un gui√≥n no se env√≠a a la salida del programa, por
lo que es necesario mostrarla expl√≠citamente. 
\end{enumerate}

\end{document}
