%% LyX 2.2.3 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[oneside]{book}
\usepackage[utf8]{inputenc}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\synctex=-1
\usepackage{graphicx}

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\newcommand{\beforefig}{\vspace{1.3\parskip}}
\newcommand{\afterfig}{\vspace{-0.2\parskip}}

\newcommand{\beforeverb}{\vspace{0.6\parskip}}
\newcommand{\afterverb}{\vspace{0.6\parskip}}

\newcommand{\adjustpage}[1]{\enlargethispage{#1\baselineskip}}

\makeatother

\usepackage{listings}
\renewcommand{\lstlistingname}{\inputencoding{latin9}Listado de cdigo}

\begin{document}

\chapter{Iteraci贸n }

\index{iteraci贸n}

\section{Asignaci贸n m煤ltiple}

\index{asignaci贸n} \index{sentencia!asignaci贸n} \index{asignaci贸n m煤ltiple}

Puede que usted ya haya descubierto que es posible realizar m谩s de
una asignaci贸n a la misma variable. Una nueva asignaci贸n hace que
la variable existente se refiera a un nuevo valor (y deje de referirse
al viejo valor).

\inputencoding{latin9}\begin{lstlisting}
pedro = 5
print(pedro)
pedro = 7
print(pedro)
\end{lstlisting}
\inputencoding{utf8} La salida de este programa es:

\texttt{5 }

\texttt{7} 

porque la primera vez que \texttt{pedro} se imprime, tiene el valor
5, y la segunda vez tiene el valor 7.

Aqu铆 se puede ver c贸mo luce la \textbf{asignaci贸n m煤ltiple } en un
diagrama de estado:

\beforefig \centerline{\includegraphics{illustrations/assign2}}
\afterfig

Con asignaci贸n m煤ltiple es muy importante distinguir entre una asignaci贸n
y una igualdad. Como Python usa el signo igual (\texttt{=}) para la
asignaci贸n podemos caer en la tentaci贸n de interpretar a una sentencia
como \texttt{a = b} como si fuera una igualdad. 隆Y no lo es!

Primero, la igualdad es conmutativa y la asignaci贸n no lo es. Por
ejemplo, en la matem谩tica si $a=7$ entonces $7=a$. Pero en Python,
la sentencia \texttt{a = 7} es legal aunque \texttt{7 = a} no lo es.

Adem谩s, en matem谩tica, una sentencia de igualdad \textit{siempre}
es cierta. Si $a=b$ ahora, entonces $a$ siempre ser谩 igual a $b$.
En Python, una sentencia de asignaci贸n puede lograr que dos variables
sean iguales pero s贸lo por un tiempo determinado:

\inputencoding{latin9}\begin{lstlisting}
a = 5
b = a    # a y b ahora son iguales
a = 3    # a y b no son iguales ahora
\end{lstlisting}
\inputencoding{utf8} La tercera l铆nea cambia el valor de \texttt{a} pero no cambia el
valor de \texttt{b}, as铆 que ya no ser谩n iguales. En algunos lenguajes
de programaci贸n se usa un signo diferente para la asignaci贸n como
\texttt{\textless{}-} o \texttt{:=} para evitar la confusi贸n.

Aunque la asignaci贸n m煤ltiple puede ser 煤til se debe usar con precauci贸n.
Si los valores de las variables cambian frecuentemente se puede dificultar
la lectura y la depuraci贸n del c贸digo.

\section{La sentencia \texttt{while (mientras)} }

\index{sentencia while} \index{sentencia!while} \index{ciclo!while}
\index{iteraci贸n}

Los computadores se usan a menudo para automatizar tareas repetitivas.
Esto es algo que los computadores hacen bien y los seres humanos hacemos
mal.

Hemos visto dos programas, \texttt{nLineas} y \texttt{conteo}, que
usan la recursi贸n para lograr repetir, lo que tambi茅n se denomina
\textbf{iteraci贸n}. Como la iteraci贸n es tan com煤n, Python proporciona
varios elementos para facilitarla. El primero que veremos es la sentencia
\texttt{while}.

Aqu铆 presentamos a la funci贸n \texttt{conteo} usando una sentencia
\texttt{while}:

\inputencoding{latin9}\begin{lstlisting}
def conteo(n):
  while n > 0:
    print(n)
    n = n-1
  print("Despegue!")
\end{lstlisting}
\inputencoding{utf8} Como eliminamos el llamado recursivo, esta funci贸n deja de ser recursiva.

La sentencia \texttt{while} se puede leer como en el lenguaje natural.
Quiere decir, ``Mientras \texttt{n} sea mayor que 0, contin煤e desplegando
el valor de \texttt{n} y reduciendo el valor de \texttt{n} en 1. Cuando
llegue a 0, despliegue la cadena \texttt{Despegue!}''.

M谩s formalmente, el flujo de ejecuci贸n de una sentencia \texttt{while}
luce as铆:
\begin{enumerate}
\item Eval煤a la condici贸n, resultando en \texttt{False} (falso) o \texttt{True}
(cierto).
\item Si la condici贸n es falsa (False), se sale de la sentencia \texttt{while}
y contin煤a la ejecuci贸n con la siguiente sentencia (afuera del while).
\item Si la condici贸n es cierta (True), ejecute cada una de las sentencias
en el cuerpo y regrese al paso 1.
\end{enumerate}
El cuerpo comprende todas las sentencias bajo la cabecera que tienen
la misma indentaci贸n.

Este flujo se denomina \textbf{ciclo} porque el tercer paso da la
vuelta hacia el primero. Note que si la condici贸n es falsa la primera
vez que se entra al while, las sentencias internas nunca se ejecutan.

\index{condici贸n} \index{ciclo} \index{ciclo!cuerpo} \index{cuerpo!ciclo}
\index{ciclo infinito} \index{ciclo!infinito}

El cuerpo del ciclo deber铆a cambiar el valor de una o m谩s variables,
de forma que la condici贸n se haga falsa en alg煤n momento y el ciclo
termine. De otra forma, el ciclo se repetir谩 para siempre, obteniendo
un \textbf{ciclo infinito}. Una broma com煤n entre los cient铆ficos
de la computaci贸n es interpretar las instrucciones de los champ煤s,
``Aplique champ煤, aplique rinse, repita,'' como un ciclo infinito.

En el caso de \texttt{conteo}, podemos probar que el ciclo termina
porque sabemos que el valor de \texttt{n} es finito, y podemos ver
que va haci茅ndose m谩s peque帽o cada vez que el while itera (da la vuelta),
as铆 que eventualmente llegaremos a 0. En otros casos esto no es tan
f谩cil de asegurar:

\inputencoding{latin9}\begin{lstlisting}
def secuencia(n):
  while n != 1:
    print(n),
    if n%2 == 0:        # n es par
      n = n/2
    else:               # n es impar
      n = n*3+1
\end{lstlisting}
\inputencoding{utf8} La condici贸n para este ciclo es \texttt{n != 1}, as铆 que se repetir谩
hasta que \texttt{n} sea \texttt{1}, lo que har谩 que la condici贸n
sea falsa.

En cada iteraci贸n del ciclo while el programa despliega el valor de
\texttt{n} y luego chequea si es par o impar. Si es par, el valor
de \texttt{n} se divide por 2. Si es impar el valor se reemplaza por
\texttt{n{*}3+1}. Si el valor inicial (del argumento) es 3, la secuencia
que resulta es 3, 10, 5, 16, 8, 4, 2, 1.

Como \texttt{n} aumenta algunas veces y otras disminuye, no hay una
demostraci贸n obvia de que \texttt{n} llegar谩 a ser 1, o de que el
programa termina. Para algunos valores particulares de \texttt{n}
podemos demostrar la terminaci贸n. Por ejemplo, si el valor inicial
es una potencia de dos, entonces el valor de \texttt{n} ser谩 par en
cada iteraci贸n del ciclo hasta llegar a 1. El ejemplo anterior termina
con una secuencia as铆 que empieza con 16.

Dejando los valores particulares de lado, la interesante pregunta
que nos planteamos es si podemos demostrar que este programa termina
para {\em todos} los valores de \texttt{n}. Hasta ahora, 隆nadie
ha sido capaz de probarlo {\em o} refutarlo!.

\section{Tablas}

\label{tables} \index{tabla} \index{logaritmo}

Una gama de aplicaciones donde los ciclos se destacan es la de generaci贸n
de informaci贸n tabular. Antes de que los computadores existieran la
gente ten铆a que calcular logaritmos, senos, cosenos y otras funciones
matem谩ticas a mano. Para facilitar la tarea, los libros matem谩ticos
inclu铆an largas tablas con los valores de dichas funciones. La creaci贸n
de las tablas era un proceso lento y aburridor, y tend铆an a quedar
con muchos errores.

Cuando los computadores entraron en escena, una de las reacciones
iniciales fue ``Esto es maravilloso! Podemos usar los computadores
para generar las tablas, de forma que no habr铆an errores''. Eso result贸
(casi) cierto, pero poco prospectivo. Poco despu茅s los computadores
y las calculadoras se hicieron tan ubicuos que las tablas se hicieron
obsoletas.

Bueno, casi. Para algunas operaciones los computadores usan tablas
de valores para obtener una respuesta aproximada y luego hacer mas
c谩lculos para mejorar la aproximaci贸n. En algunos casos, se han encontrado
errores en las tablas subyacentes, el m谩s famoso ha sido el de la
tabla para realizar la divisi贸n en punto flotante en los procesadores
Pentium de la compa帽铆a Intel.

\index{Intel} \index{Pentium}

Aunque una tabla logar铆tmica no es tan 煤til como en el pasado, todav铆a
sirve como un buen ejemplo de iteraci贸n. El siguiente programa despliega
una secuencia de valores en la columna izquierda y sus logaritmos
en la columna derecha: \inputencoding{latin9}
\begin{lstlisting}
import math
x = 1.0
while x < 10.0:
  print(x, '\t', math.log(x))
  x = x + 1.0
\end{lstlisting}
\inputencoding{utf8}
La cadena \verb+'\t'+ representa un car谩cter \textbf{tab} (tabulador).

A medida que los caracteres y las cadenas se despliegan en la pantalla
un marcador invisible denominado \textbf{cursor} lleva pista de d贸nde
va a ir el siguiente car谩cter. Despu茅s de una sentencia \texttt{print},
el cursor va al comienzo de la siguiente l铆nea.

El car谩cter tabulador mueve el cursor hacia la derecha hasta que alcanza
un punto de parada (cada cierto n煤mero de espacios, que pueden variar
de sistema a sistema). Los tabuladores son 煤tiles para alinear columnas
de texto, como la salida del anterior programa:
\begin{verbatim}
1.0     0.0
2.0     0.69314718056
3.0     1.09861228867
4.0     1.38629436112
5.0     1.60943791243
6.0     1.79175946923
7.0     1.94591014906
8.0     2.07944154168
9.0     2.19722457734
\end{verbatim}
Si estos valores parecen extra帽os, recuerde que la funci贸n \texttt{log}
usa la base \texttt{e}. Ya que las potencias de dos son importantes
en la ciencias de la computaci贸n, a menudo deseamos calcular logaritmos
en base 2. Para este fin podemos usar la siguiente f贸rmula:

\begin{equation}
\log_{2}x=\frac{log_{e}x}{log_{e}2}
\end{equation}

Cambiando la salida del ciclo a:\inputencoding{latin9}
\begin{lstlisting}
print(x, '\t',  math.log(x)/math.log(2.0))
\end{lstlisting}
\inputencoding{utf8}\begin{verbatim}
   resulta en:
1.0     0.0
2.0     1.0
3.0     1.58496250072
4.0     2.0
5.0     2.32192809489
6.0     2.58496250072
7.0     2.80735492206
8.0     3.0
9.0     3.16992500144
\end{verbatim}
Podemos ver que 1, 2, 4, y 8 son potencias de dos porque sus logaritmos
en base 2 son n煤meros enteros. Si deseamos calcular el logaritmo de
m谩s potencias de dos podemos modificar el programa as铆:\inputencoding{latin9}
\begin{lstlisting}
x = 1.0
while x < 100.0:
  print(x, '\t', math.log(x)/math.log(2.0))
  x = x * 2.0
\end{lstlisting}
\inputencoding{utf8}
Ahora, en lugar de agregar algo a \texttt{x} en cada iteraci贸n del
ciclo, produciendo una serie aritm茅tica, multiplicamos a \texttt{x}
por algo constante, produciendo una serie geom茅trica. El resultado
es:

\index{serie aritm茅tica} \index{serie geom茅trica}
\begin{verbatim}
1.0     0.0
2.0     1.0
4.0     2.0
8.0     3.0
16.0    4.0
32.0    5.0
64.0    6.0
\end{verbatim}
Gracias a los caracteres tabuladores entre las columnas, la posici贸n
de la segunda columna no depende del n煤mero de d铆gitos en la primera.

Puede que las tablas de logaritmos no sirvan en nuestros d铆as, 隆pero
para los cient铆ficos de la computaci贸n saber las potencias de dos
s铆 es muy importante!.

\index{secuencia de escape}

El car谩cter diagonal invertido (backslash) \verb+'\'+ indica el comienzo
de una \textbf{secuencia de escape}. Estas secuencias se utilizan
para representar caracteres invisibles como tabuladores y nuevas l铆neas.
La secuencia \verb+'\n'+ representa una nueva l铆nea.

Una secuencia de escape puede empezar en cualquier posici贸n de una
cadena; en el ejemplo anterior, la secuencia de escape tabuladora
es toda la cadena.

驴C贸mo cree que se representa un diagonal invertido en una cadena?

\section{Tablas de dos dimensiones}

\index{tabla!bidimensional}

Una tabla de dos dimensiones es una en la que los valores se leen
en la intersecci贸n de una fila y una columna. Una tabla de multiplicaci贸n
es un ejemplo familiar. Digamos que usted desea imprimir una tabla
de multiplicaci贸n para los valores del 1 al 6.

Una buena forma de empezar es escribir un ciclo que imprima los m煤ltiplos
de 2, en una sola l铆nea:\inputencoding{latin9}
\begin{lstlisting}
i = 1
while i <= 6:
  print(2*i, '   ',end=' ')
  i = i + 1

print()
\end{lstlisting}
\inputencoding{utf8}
La primera l铆nea inicializa una variable llamada \texttt{i}, que act煤a
como un contador o \textbf{variable de ciclo}. A medida que se ejecuta
el ciclo, el valor de \texttt{i} se incrementa de 1 a 6. Cuando \texttt{i}
es 7, el ciclo termina. En cada iteraci贸n del ciclo despliega el valor
\texttt{2{*}i}, seguido de tres espacios.

El uso de \texttt{end=' '} en la funci贸n \texttt{print} cambia el
煤ltimo caracter que se imprime, que por defecto es el de fin de l铆nea.
Despu茅s de que el ciclo termina la segunda sentencia \texttt{print}
comienza una nueva l铆nea.

La salida del programa es:
\begin{verbatim}
2      4      6      8      10     12
\end{verbatim}
Hasta aqu铆 vamos bien. El paso siguiente es \textbf{encapsular} y
\textbf{generalizar}.

\section{Encapsulamiento y generalizaci贸n}

\label{encapsulation}

\index{encapsulamiento} \index{generalizaci贸n} \index{desarrollo de programas!encapsulamiento}
\index{desarrollo de programas!generalizaci贸n}

Encapsular es el proceso de envolver un trozo de c贸digo en una funci贸n,
permitiendo tomar ventaja de todas los beneficios que esto conlleva.
Usted ha visto dos ejemplos de encapsulamiento: \texttt{imprimirParidad}
en la Secci贸n~\ref{alternative execution}; y \texttt{esDivisible}
en la Secci贸n~\ref{boolean}.

La generalizaci贸n es tomar algo espec铆fico, tal como imprimir los
m煤ltiplos de 2, y convertirlo en algo m谩s general, tal como imprimir
los m煤ltiplos de cualquier entero.

Esta funci贸n encapsula el ciclo anterior y lo generaliza para imprimir
m煤ltiplos de un par谩metro \texttt{n}:\inputencoding{latin9}
\begin{lstlisting}
def imprimaMultiplos(n):
  i = 1
  while i <= 6:
    print(n*i, end='\t')
    i = i + 1
  print()
\end{lstlisting}
\inputencoding{utf8}
Para encapsular el ciclo, todo lo que agregamos fue la primera l铆nea
que declara el nombre de la funci贸n y la lista de par谩metros. Para
generalizar, lo que hicimos fue reemplazar el valor 2 con el par谩metro
\texttt{n}.

Si llamamos a esta funci贸n con el argumento 2, obtenemos la misma
salida de la secci贸n anterior. Con el argumento 3, la salida es:
\begin{verbatim}
3      6      9      12     15     18
\end{verbatim}
Con el argumento 4, la salida es:
\begin{verbatim}
4      8      12     16     20     24
\end{verbatim}
Ahora, usted probablemente imagine c贸mo imprimir una tabla de multiplicaci贸n
llamando a \texttt{imprimaMultiplos} repetidamente con diferentes
argumentos. De hecho, podemos usar otro ciclo:

\inputencoding{latin9}\begin{lstlisting}
i = 1
while i <= 6:
  imprimaMultiplos(i)
  i = i + 1
\end{lstlisting}
\inputencoding{utf8}
Observe lo similar que es este ciclo al ciclo interno de la funci贸n
\texttt{imprimaMultiplos}. Todo lo que hicimos fue reemplazar la sentencia
\texttt{print} con un llamado de funci贸n.

La salida de este programa es una tabla de multiplicaci贸n:
\begin{verbatim}
1      2      3      4      5      6
2      4      6      8      10     12
3      6      9      12     15     18
4      8      12     16     20     24
5      10     15     20     25     30
6      12     18     24     30     36
\end{verbatim}

\section{M谩s encapsulamiento}

Para demostrar el encapsulamiento otra vez, tomemos el c贸digo de la
secci贸n \ref{encapsulation} y envolv谩moslo en una funci贸n:\inputencoding{latin9}
\begin{lstlisting}
def imprimirTablaMultiplicacion():
  i = 1
  while i <= 6:
    imprimaMultiplos(i)
    i = i + 1
\end{lstlisting}
\inputencoding{utf8}
Este proceso es un \textbf{plan de desarrollo} com煤n. Desarrollamos
c贸digo escribiendo l铆neas afuera de cualquier funci贸n o digit谩ndolas
en el int茅rprete. Cuando funcionan, las ponemos dentro de una funci贸n.

Este plan de desarrollo es particularmente 煤til si usted no sabe,
cuando est谩 empezando a programar, c贸mo dividir el programa en funciones.
Este enfoque permite dise帽ar a medida que se escribe c贸digo.

\section{Variables locales}

\index{variable!local} \index{variable local}

Puede estar pregunt谩ndose c贸mo usamos la misma variable, \texttt{i}
en las dos funciones \texttt{imprimaMultiplos} y \texttt{imprimaTabla}.
驴No ocurren problemas cuando una de ellas cambia el valor de la variable?

La respuesta es no, porque la \texttt{i} en \texttt{imprimaMultiplos}
y la \texttt{i} en \texttt{imprimaTabla} {\em no} son la misma
variable.

Las variables creadas dentro de una definici贸n de funci贸n son locales;
no se puede acceder a ellas fuera de su funci贸n ``casa''. Esto quiere
decir que usted tiene la libertad de tener m煤ltiples variables con
el mismo nombre en tanto no pertenezcan a la misma funci贸n.

El diagrama de pila para este programa muestra que las dos variables
llamadas \texttt{i} no son la misma. Se pueden referir a valores diferentes,
y cambiar una de ellas no altera la otra.

\beforefig \centerline{\includegraphics{illustrations/stack4}}
\afterfig

El valor de \texttt{i} en \texttt{imprimaTabla} va de 1 a 6. En el
diagrama va por el valor 3. En la pr贸xima iteraci贸n del ciclo ser谩
4. En cada iteraci贸n, \texttt{imprimaTabla} llama a \texttt{imprimaMultiplos}
con el valor actual de \texttt{i} como argumento. Ese valor se le
asigna al par谩metro \texttt{n}.

Adentro de \texttt{imprimaMultiplos} el valor de \texttt{i} va de
1 a 6. En el diagrama, es 2. Cambiar esta variable no tiene efecto
en el valor de \texttt{i} en \texttt{imprimaTabla}.

Es legal y muy com煤n tener diferentes variables locales con el mismo
nombre. Particularmente, nombres como \texttt{i} y \texttt{j} se usan
frecuentemente como variables de ciclo. Si usted evita usarlas en
una funci贸n porque ya las us贸 en otra, probablemente dificultar谩 la
lectura del programa.

%\adjustpage{-2}%\pagebreak

\section{Mas generalizaci贸n}

Como otro ejemplo de generalizaci贸n, imagine que le piden un programa
que imprima una tabla de multiplicaci贸n de cualquier tama帽o; no s贸lo
la tabla de seis por seis. Podr铆a agregarse un par谩metro a \texttt{imprimaTabla}:\inputencoding{latin9}
\begin{lstlisting}
def imprimaTabla(tope):
  i = 1
  while i <= tope:
    imprimaMultiplos(i)
    i = i + 1
\end{lstlisting}
\inputencoding{utf8}
Reemplazamos el valor 6 con el par谩metro \texttt{tope}. Si llamamos
a \texttt{imprimaTabla} con el argumento 7, despliega:
\begin{verbatim}
1      2      3      4      5      6
2      4      6      8      10     12
3      6      9      12     15     18
4      8      12     16     20     24
5      10     15     20     25     30
6      12     18     24     30     36
7      14     21     28     35     42
\end{verbatim}
Esto est谩 bien, pero quiz谩s deseamos que la tabla sea cuadradacon
el mismo n煤mero de filas y columnas. Para lograrlo, a帽adimos un par谩metro
a imprimaMultiplos que especifique cu谩ntas columnas debe tener la
tabla.

S贸lo por confundir, vamos a nombrarlo \texttt{tope}, demostrando que
diferentes funciones pueden tener par谩metros con el mismo nombre (igual
que las variables locales). Aqu铆 est谩 el programa completo:\inputencoding{latin9}
\begin{lstlisting}
def imprimaMultiplos(n, tope):
  i = 1
  while i <= tope:
    print(n*i, end='\t')
    i = i + 1
  print()

def imprimaTabla(tope):
  i = 1
  while i <= tope:
    imprimaMultiplos(i, tope)
    i = i + 1
\end{lstlisting}
\inputencoding{utf8}
Note que cuando agregamos el nuevo par谩metro tuvimos que cambiar la
primera l铆nea de la funci贸n (la cabecera), y tambi茅n el lugar donde
la funci贸n se llama en \texttt{imprimaTabla}.

Como se esperaba, este programa genera una tabla cuadrada de siete-por-siete:
\begin{verbatim}
1      2      3      4      5      6      7
2      4      6      8      10     12     14
3      6      9      12     15     18     21
4      8      12     16     20     24     28
5      10     15     20     25     30     35
6      12     18     24     30     36     42
7      14     21     28     35     42     49
\end{verbatim}
Cuando se generaliza una funci贸n adecuadamente, a menudo se obtiene
un programa con capacidades que no se hab铆an planeado. Por ejemplo,
podr铆amos aprovechar el hecho de que $ab=ba$, que causa que todas
las entradas de la tabla aparezcan dos veces para ahorrar tinta imprimiendo
solamente la mitad de la tabla. Para lograrlo s贸lo se necesita cambiar
una l铆nea de \texttt{imprimaTabla}. Cambiamos:
\begin{verbatim}
    imprimaMultiplos(i, tope)
\end{verbatim}
por
\begin{verbatim}
    imprimaMultiplos(i, i)
\end{verbatim}
y se obtiene:
\begin{verbatim}
1
2      4
3      6      9
4      8      12     16
5      10     15     20     25
6      12     18     24     30     36
7      14     21     28     35     42     49
\end{verbatim}

\section{Funciones}

\index{funci贸n}

Ya hemos mencionado los ``beneficios de las funciones.'' Usted se
estar谩 preguntado cuales son estos beneficios. Aqu铆 hay algunos:
\begin{itemize}
\item Nombrar una secuencia de sentencias aumenta la legibilidad de los
programas y los hace m谩s f谩ciles de depurar.
\item Dividir un programa grande en funciones permite separar partes de
茅ste, depurarlas aisladamente, y luego componerlas en un todo coherente.
\item Las funciones facilitan la recursi贸n y la iteraci贸n.
\item Las funciones bien dise帽adas resultan ser 煤tiles para muchos programas.
Una vez que usted escribe y depura una, se puede reutilizar.
\end{itemize}

\section{Glosario}
\begin{description}
\item [{Asignaci贸n m煤ltiple:}] realizar m谩s de una asignaci贸n a una
misma variable durante la ejecuci贸n de un programa.
\item [{Iteraci贸n:}] la ejecuci贸n repetida de un grupo de sentencias, ya
sea en una funci贸n recursiva o en un ciclo.
\item [{Ciclo:}] una sentencia o grupo de sentencias que se ejecuta repetidamente
hasta que una condici贸n de terminaci贸n se cumple.
\item [{Ciclo infinito:}] ciclo en el que la condici贸n de terminaci贸n
nunca se cumple.
\item [{Cuerpo:}] las sentencias adentro de un ciclo.
\item [{Variable de ciclo:}] variable que se usa como parte de la condici贸n
de terminaci贸n de un ciclo.
\item [{Tab:}] (tabulador) car谩cter especial que causa el movimiento del
cursor al siguiente punto de parada en la l铆nea actual.
\item [{Nueva l铆nea:}] car谩cter que causa que el cursor se mueva al principio
de la siguiente l铆nea.
\item [{Cursor:}] marcador invisible que lleva pista de d贸nde se va a imprimir
el siguiente car谩cter.
\item [{Secuencia de escape:}] car谩cter de escape ($\backslash$) seguido
por uno o m谩s caracteres imprimibles que se usan para denotar un car谩cter
no imprimible.
\item [{Encapsular:}] dividir un programa grande y complejo en componentes
(como funciones) y aislarlos entre s铆 (usando variables locales, por
ejemplo).
\item [{Generalizar:}] reemplazar algo innecesariamente espec铆fico (como
un valor constante) con algo general m谩s apropiado (como una variable
o par谩metro). La generalizaci贸n aumenta la versatilidad del c贸digo,
lo hace m谩s reutilizable y en algunos casos facilita su escritura.
\item [{Plan de desarrollo:}] proceso para desarrollar un programa. En
este cap铆tulo demostramos un estilo de desarrollo basado en escribir
c贸digo que realiza c贸mputos simples y espec铆ficos, para luego encapsularlo
y generalizarlo.

\index{asignaci贸n m煤ltiple} \index{asignaci贸n!m煤ltiple} \index{iteraci贸n}
\index{ciclo!cuerpo} \index{ciclo} \index{ciclo infinito} \index{secuencia de escape}
\index{cursor} \index{tab} \index{nueva l铆nea} \index{variable de ciclo}
\index{encapsular} \index{generalizar} \index{plan de desarrollo}
\index{programas!desarrollo de}
\end{description}

\section{Ejercicios}
\begin{enumerate}
\item Siga la ejecuci贸n de la 煤ltima versi贸n de \texttt{imprimaTabla} y
descifre c贸mo trabaja. 
\item Reescriba la funci贸n \texttt{nLineas} de la Secci贸n \ref{recursion},
usando iteraci贸n en vez de recursi贸n. 
\item Escriba una sola cadena que

\beforeverb 
\begin{verbatim}
produzca
        esta
                salida.
\end{verbatim}
\afterverb
\item Escriba un programa que despliegue las potencias de 2 hasta 65,536
(esto es $2^{16}$).
\item Escriba una funci贸n \verb+muestra_numeros_triangulares(n)+ que muestre
los primeros n n煤meros triangulares. Una llamada a \verb+muestra_numeros_triangulares(5)+
producir铆a la siguiente salida: \beforeverb 

\begin{verbatim}
  1       1
  2       3
  3       6
  4       10
  5       15
  
\end{verbatim}
\afterverb
\item Muchos c谩lculos de funciones matem谩ticas se realizan con series infinitas,
por ejemplo:

$\ln{x}=\sum_{n=1}^{\infty}\frac{1}{{n}}\left(\frac{x-1}{x}\right)^{n}=\left(\frac{x-1}{x}\right)+\frac{1}{2}\left(\frac{x-1}{x}\right)^{2}+\frac{1}{3}\left(\frac{x-1}{x}\right)^{3}+\cdots$

que son aproximadas fijando un valor $n$ tal que la precisi贸n, dada
por el n煤mero de cifras significativas correctas del valor calculado,
sea buena. Escriba un programa que calcule el logaritmo natural de
un n煤mero dado basado en la formula anterior. Para esto debe probar
con varios valores de $n$ hasta que obtenga un buen n煤mero de cifras
significativas correctas comparando el resultado de su programa con
el de \verb+math.log+.
\item Busque una formula correcta para calcular el seno de un 谩ngulo y escriba
un programa para calcular este valor basado en la formula, como en
el punto anterior. Compare con \verb+math.sin+.
\item Compare los valores de $n$ que obtuvo para los puntos 6 y 7. Explique
si encuentra diferencias.
\item Escriba una funci贸n, \verb+es_primo+, que tome un solo argumento
entero y devuelva \verb+True+ cuando el argumento es un n煤mero primo
y \verb+False+ en caso contrario.
\item Agregue el c贸digo para chequeo de tipo de datos y para las prueba
unitarias a todas las funciones desarrolladas previamente.
\end{enumerate}

\end{document}
