%% LyX 2.2.3 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[oneside]{book}
\usepackage[utf8]{inputenc}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\synctex=-1
\usepackage{url}
\usepackage{listings}
\renewcommand{\lstlistingname}{\inputencoding{latin9}Listado de c祚igo}

\begin{document}

\chapter{Tuplas}

\label{tuplechap} \index{tupla}

\section{Mutabilidad y tuplas}

\index{tupla} \index{tipo de dato!tupla} \index{tipo de dato!inmutable}

Hasta aqu칤, usted ha visto dos tipos de datos compuestos: cadenas,
que est치n compuestas de caracteres; y listas, compuestas de elementos
de cualquier tipo. Una de las diferencias que notamos es que los elementos
de una lista pueden modificarse, pero los caracteres en una cadena
no. En otras palabras, las cadenas son \textbf{inmutables} y las listas
son \textbf{mutables}.

\index{mutable} \index{inmutable}

Hay otro tipo de dato en Python denominado \textbf{tupla}, que se
parece a una lista, con la excepci칩n de que es inmutable. Sint치cticamente,
una tupla es una lista de valores separados por comas:\inputencoding{latin9}
\begin{lstlisting}
>>> tupla = 'a', 'b', 'c', 'd', 'e'
\end{lstlisting}
\inputencoding{utf8}
Aunque no es necesario, se pueden encerrar entre par칠ntesis:\inputencoding{latin9}
\begin{lstlisting}
>>> tupla = ('a', 'b', 'c', 'd', 'e')
\end{lstlisting}
\inputencoding{utf8}
Para crear una tupla con un 칰nico elemento, tenemos que incluir la
coma final:\inputencoding{latin9}
\begin{lstlisting}
>>> t1 = ('a',)
>>> type(t1)
<type 'tuple'>
\end{lstlisting}
\inputencoding{utf8}
Sin la coma, Python creer칤a que \texttt{('a')} es una cadena en par칠ntesis:\inputencoding{latin9}
\begin{lstlisting}
>>> t2 = ('a')
>>> type(t2)
<type 'string'>
\end{lstlisting}
\inputencoding{utf8}
Las operaciones sobre tuplas son las mismas que vimos con las listas.
El operador corchete selecciona un elemento de la tupla.\inputencoding{latin9}
\begin{lstlisting}
>>> tupla = ('a', 'b', 'c', 'd', 'e')
>>> tupla[0]
'a'
\end{lstlisting}
\inputencoding{utf8}
Y el operador segmento selecciona un rango de elementos:\inputencoding{latin9}
\begin{lstlisting}
>>> tupla[1:3]
('b', 'c')
\end{lstlisting}
\inputencoding{utf8}
Pero si intentamos modificar un elemento de la tupla obtenemos un
error:

\index{error en tiempo de ejecuci칩n}\inputencoding{latin9}
\begin{lstlisting}
>>> tupla[0] = 'A'
TypeError: object doesn't support item assignment
\end{lstlisting}
\inputencoding{utf8}
Aunque no podemos modificar los elementos, s칤 podemos modificar toda
la tupla:\inputencoding{latin9}
\begin{lstlisting}
>>> tupla = ('A',) + tupla[1:]
>>> tupla
('A', 'b', 'c', 'd', 'e')
>>> tupla = (1,2,3)
>>> tupla
\end{lstlisting}
\inputencoding{utf8}
\section{Asignaci칩n de tuplas}

\label{tuple assignment} \index{asignaci칩n de tuplas} \index{Asignaci칩n!de tuplas}

De vez en cuando necesitamos intercambiar los valores de dos variables.
Con el operador de asignaci칩n normal tenemos que usar una variable
temporal. Por ejemplo, para intercambiar \texttt{a} y \texttt{b}:\inputencoding{latin9}
\begin{lstlisting}
>>> temp = a
>>> a = b
>>> b = temp
\end{lstlisting}
\inputencoding{utf8}
Si tenemos que intercambiar variables muchas veces, el c칩digo tiende
a ser engorroso. Python proporciona una forma de \textbf{asignaci칩n
de tuplas} que resuelve este problema:\inputencoding{latin9}
\begin{lstlisting}
>>> a, b = b, a
\end{lstlisting}
\inputencoding{utf8}
El lado izquierdo es una tupla de variables; el derecho es una tupla
de valores. Cada valor se asigna a su respectiva variable en el orden
en que se presenta. Las expresiones en el lado derecho se eval칰an
antes de cualquier asignaci칩n. Esto hace a la asignaci칩n de tuplas
una herramienta bastante vers치til.

Naturalmente, el n칰mero de variables a la izquierda y el n칰mero de
valores a la derecha deben coincidir.\inputencoding{latin9}
\begin{lstlisting}
>>> a, b, c, d = 1, 2, 3
ValueError: unpack tuple of wrong size
\end{lstlisting}
\inputencoding{utf8}
\section{Tuplas como valores de retorno}

\index{tupla} \index{valor!tupla} \index{valor de retorno!tupla}
\index{funci칩n!tupla como valor de retorno}

Las funciones pueden tener tuplas como valores de retorno. Por ejemplo,
podr칤amos escribir una funci칩n que intercambie sus dos par치metros:\inputencoding{latin9}
\begin{lstlisting}
def intercambiar(x, y):
  return y, x
\end{lstlisting}
\inputencoding{utf8}
As칤 podemos asignar el valor de retorno a una tupla con dos variables:\inputencoding{latin9}
\begin{lstlisting}
a, b = intercambiar(a, b)
\end{lstlisting}
\inputencoding{utf8}
En este caso, escribir una funci칩n \texttt{intercambio} no es muy
provechoso. De hecho, hay un peligro al tratar de encapsular \texttt{intercambio},
que consiste en el siguiente error:\inputencoding{latin9}
\begin{lstlisting}
def intercambio(x, y):      # version incorrecta
  x, y = y, x
\end{lstlisting}
\inputencoding{utf8}
Si llamamos a esta funci칩n as칤:\inputencoding{latin9}
\begin{lstlisting}
intercambio(a, b)
\end{lstlisting}
\inputencoding{utf8}
entonces \texttt{a} y \texttt{x} son dos alias para el mismo valor.
Cambiar \texttt{x} dentro de \texttt{intercambio} hace que \texttt{x}
se refiera a un valor diferente, pero no tiene efecto en la \texttt{a}
dentro de \texttt{\_\_main\_\_}. Igualmente, cambiar \texttt{y} no
tiene efecto en \texttt{b}.

Esta funci칩n se ejecuta sin errores, pero no hace lo que se pretende.
Es un ejemplo de error sem치ntico.

\index{error sem치ntico}

\section{N칰meros aleatorios}

\index{n칰mero aleatorio} \index{n칰mero!aleatorio}

La gran mayor칤a de los programas hacen lo mismo cada vez que se ejecutan,
esto es, son \textbf{determin칤sticos}. El determinismo generalmente
es una buena propiedad, ya que usualmente esperamos que los c치lculos
produzcan el mismo resultado. Sin embargo, para algunas aplicaciones
necesitamos que el computador sea impredecible. Los juegos son un
ejemplo inmediato, pero hay m치s.

Lograr que un programa sea verdaderamente no determin칤stico no es
una tarea f치cil, pero hay formas de que parezca no determin칤stico.
Una de ellas es generar n칰meros aleatorios y usarlos para determinar
la salida de un programa. Python tiene una funci칩n primitiva que genera
n칰meros \textbf{pseudoaleatorios}, que, aunque no sean aleatorios
desde el punto de vista matem치tico, sirven para nuestros prop칩sitos.

El m칩dulo \texttt{random} contiene una funci칩n llamada \texttt{random}
que retorna un n칰mero flotante entre 0.0 y 1.0. Cada vez que se llama
a \texttt{random}, se obtiene el siguiente n칰mero de una serie muy
larga. Para ver un ejemplo ejecute el siguiente ciclo:\inputencoding{latin9}
\begin{lstlisting}
import random

for i in range(10):
  x = random.random()
  print(x)
\end{lstlisting}
\inputencoding{utf8}
Para generar un n칰mero aleatorio entre 0.0 y un l칤mite superior como
\texttt{sup}, multiplique \texttt{x} por \texttt{sup}.

\section{Lista de n칰meros aleatorios}

Vamos a escribir una funci칩n llamada \texttt{listaAleatoria} que cree
una lista de n칰meros aleatorios. Recibir치 un par치metro entero que
especifique el n칰mero de elementos a generar. Primero, genera una
lista de \texttt{n} ceros. Luego cada vez que itera en un ciclo for,
reemplaza uno de los ceros por un n칰mero aleatorio. El valor de retorno
es una referencia a la lista construida:\inputencoding{latin9}
\begin{lstlisting}
def listaAleatoria(n):
  s = [0] * n
  for i in range(n):
    s[i] = random.random()
  return s
\end{lstlisting}
\inputencoding{utf8}
La probaremos con ocho elementos. Para depurar es una buena idea empezar
con pocos datos:\inputencoding{latin9}
\begin{lstlisting}
>>> listaAleatoria(8)
0.15156642489
0.498048560109
0.810894847068
0.360371157682
0.275119183077
0.328578797631
0.759199803101
0.800367163582
\end{lstlisting}
\inputencoding{utf8}
Los n칰meros generados por \texttt{random} deben distribuirse uniformemente,
lo que significa que cada valor es igualmente probable.

Si dividimos el rango de valores posibles en ``regiones'' del mismo
tama침o y contamos el n칰mero de veces que un valor aleatorio cae en
cada regi칩n, deber칤amos obtener un resultado aproximado en todas las
regiones.

Podemos probar esta hip칩tesis escribiendo un programa que divida el
rango en regiones y cuente el n칰mero de valores que caen en cada una.

\section{Conteo}

\index{conteo}

Un enfoque que funciona en problemas como 칠ste es dividir el problema
en subproblemas que se puedan resolver con un patr칩n computacional
que ya sepamos.

En este caso, necesitamos recorrer una lista de n칰meros y contar el
n칰mero de veces que un valor cae en un rango dado. Esto parece familiar.
En la Secci칩n~\ref{counter}, escribimos un programa que recorr칤a
una cadena y contaba el n칰meros de veces que aparec칤a una letra determinada.

Entonces podemos copiar el programa viejo para adaptarlo posteriormente
a nuestro problema actual. El original es:\inputencoding{latin9}
\begin{lstlisting}
cont = 0
for c in fruta:
  if c == 'a':
    cont = cont + 1
print(cont)
\end{lstlisting}
\inputencoding{utf8}
El primer paso es reemplazar \texttt{fruta} con \texttt{lista} y \texttt{c}
por \texttt{num}. Esto no cambia el programa, s칩lo lo hace m치s legible.

El segundo paso es cambiar la prueba. No queremos buscar letras. Queremos
ver si \texttt{num} est치 entre dos valores dados \texttt{inf} y \texttt{sup}.

\inputencoding{latin9}\begin{lstlisting}
cont = 0
for num in lista:
  if inf < num < sup:
    cont = cont + 1
print(cont)
\end{lstlisting}
\inputencoding{utf8}
El 칰ltimo paso consiste en encapsular este c칩digo en una funci칩n denominada
\texttt{enRegion}. Los par치metros son la lista y los valores \texttt{inf}
y \texttt{sup}.\inputencoding{latin9}
\begin{lstlisting}
def enRegion(lista, inf, sup):
  cont = 0
  for num in lista:
    if inf < num < sup:
      cont = cont + 1
  return cont
\end{lstlisting}
\inputencoding{utf8}
Copiando y modificando un programa existente fuimos capaces de escribir
esta funci칩n r치pidamente y ahorrarnos un buen tiempo de depuraci칩n.
Este plan de desarrollo se denomina \textbf{concordancia de patrones}.
Si se encuentra trabajando en un problema que ya ha resuelto antes,
reutilice la soluci칩n.

\section{Muchas regiones}

\label{muchasregiones}

Como el n칰mero de regiones aumenta, \texttt{enRegion} es un poco engorroso.
Con dos no esta tan mal:\inputencoding{latin9}
\begin{lstlisting}
inf = enRegion(a, 0.0, 0.5)
sup = enRegion(a, 0.5, 1)
\end{lstlisting}
\inputencoding{utf8} Pero con cuatro:\inputencoding{latin9}
\begin{lstlisting}
Region1 = enRegion(a, 0.0, 0.25)
Region2 = enRegion(a, 0.25, 0.5)
Region3 = enRegion(a, 0.5, 0.75)
Region4 = enRegion(a, 0.75, 1.0)
\end{lstlisting}
\inputencoding{utf8}
Hay dos problemas. Uno es que siempre tenemos que crear nuevos nombres
de variables para cada resultado. El otro es que tenemos que calcular
el rango de cada regi칩n.

Primero resolveremos el segundo problema. Si el n칰mero de regiones
est치 dado por la variable \texttt{numRegiones}, entonces, el ancho
de cada regi칩n est치 dado por la expresi칩n \texttt{1.0/numRegiones}.

Usaremos un ciclo para calcular el rango de cada regi칩n. La variable
de ciclo \texttt{i} cuenta de 1 a \texttt{numRegiones-1}:\inputencoding{latin9}
\begin{lstlisting}
ancho = 1.0 / numRegiones
for i in range(numRegiones):
  inf = i * ancho
  sup = inf + ancho
  print(inf, " hasta ", sup)
\end{lstlisting}
\inputencoding{utf8}
Para calcular el extremo inferior de cada regi칩n, multiplicamos la
variable de ciclo por el ancho. El extremo superior est치 a un \texttt{ancho}
de regi칩n de distancia.

Con \texttt{numRegiones = 8}, la salida es:
\begin{verbatim}
0.0 hasta 0.125
0.125 hasta 0.25
0.25 hasta 0.375
0.375 hasta 0.5
0.5 hasta 0.625
0.625 hasta 0.75
0.75 hasta 0.875
0.875 hasta 1.0
\end{verbatim}
Usted puede confirmar que cada regi칩n tiene el mismo ancho, que no
se solapan y que cubren el rango completo de 0.0 a 1.0.

Ahora regresemos al primer problema. Necesitamos una manera de almacenar
ocho enteros, usando una variable para indicarlos uno a uno. Usted
debe estar pensando ``춰una lista!''

Tenemos que crear la lista de regiones fuera del ciclo, porque esto
s칩lo debe ocurrir una vez. Dentro del ciclo, llamaremos a \texttt{enRegion}
repetidamente y actualizaremos el \texttt{i}칠simo elemento de la lista:\inputencoding{latin9}
\begin{lstlisting}
numRegiones = 8
Regiones = [0] * numRegiones
ancho = 1.0 / numRegiones
for i in range(numRegiones):
  inf = i * ancho
  sup = inf + ancho
  Regiones[i] = enRegion(lista, inf, sup)
print(Regiones)
\end{lstlisting}
\inputencoding{utf8}
Con una lista de 1000 valores, este c칩digo produce la siguiente lista
de conteo:
\begin{verbatim}
[138, 124, 128, 118, 130, 117, 114, 131]
\end{verbatim}
Todos estos valores est치n muy cerca a 125, que es lo que esperamos.
Al menos, est치n lo suficientemente cerca como para creer que el generador
de n칰meros pseudoaleatorios est치 funcionando bien.

\section{Una soluci칩n en una sola pasada}

\label{histograma} \index{histograma}

Aunque funciona, este programa no es tan eficiente como deber칤a. Cada
vez que llama a \texttt{enRegion}, recorre la lista entera. A medida
que el n칰mero de regiones incrementa, va a hacer muchos recorridos.

Ser칤a mejor hacer una sola pasada a trav칠s de la lista y calcular
para cada regi칩n el 칤ndice de la regi칩n en la que cae. As칤 podemos
incrementar el contador apropiado.

En la secci칩n anterior tomamos un 칤ndice \texttt{i} y lo multiplicamos
por el \texttt{ancho} para encontrar el extremo inferior de una regi칩n.
Ahora vamos a encontrar el 칤ndice de la regi칩n en la que cae.

Como este problema es el inverso del anterior, podemos intentar dividir
por \texttt{ancho} en vez de multiplicar. 춰Esto funciona!

Como \texttt{ancho = 1.0 / numRegiones}, dividir por \texttt{ancho}
es lo mismo que multiplicar por \texttt{numRegiones}. Si multiplicamos
un n칰mero en el rango 0.0 a 1.0 por \texttt{numRegiones}, obtenemos
un n칰mero en el rango de 0.0 a \texttt{numRegiones}. Si redondeamos
ese n칰mero al entero m치s cercano por debajo, obtenemos lo que queremos,
un 칤ndice de regi칩n:\inputencoding{latin9}
\begin{lstlisting}
numRegiones = 8
Regiones = [0] * numRegiones
for i in lista:
  ind = int(i * numRegiones)
  Regiones[ind] = Regiones[ind] + 1
\end{lstlisting}
\inputencoding{utf8}
Usamos la funci칩n \texttt{int} para pasar de n칰mero de punto flotante
a entero.

쮼s posible que este programa produzca un 칤ndice que est칠 fuera de
rango (por ser negativo o mayor que \texttt{len(Regiones)-1})?

Una lista como \texttt{Regiones} que almacena los conteos del n칰mero
de valores que hay en cada rango se denomina \textbf{histograma}.

\section{Glosario}
\begin{description}
\item [{Tipo inmutable:}] es un tipo de dato en el que los elementos no
pueden ser modificados. Las asignaciones a elementos o segmentos de
tipos inmutables causan errores. Las cadenas y las tuplas son inmutables.
\item [{Tipo mutable:}] tipo de dato en el que los elementos pueden ser
modificados. Todos los tipos mutables son compuestos. Las listas y
los diccionarios son mutables.
\item [{Tupla:}] tipo de dato secuencial similar a la lista, pero inmutable.
Las tuplas se pueden usar donde se requiera un tipo inmutable, por
ejemplo como llaves de un diccionario.
\item [{Asignaci칩n de tuplas:}] una asignaci칩n a todos los elementos
de una tupla en una sola sentencia. La asignaci칩n ocurre en paralelo
y no secuencialmente. Es 칰til para intercambiar valores de variables.
\item [{Determin칤stico:}] programa que hace lo mismo cada vez que se llama.
\item [{Pseudoaleatoria:}] secuencia de n칰meros que parece aleatoria, pero
en realidad es el resultado de un c칩mputo determin칤stico, bien dise침ado.
\item [{Histograma:}] lista de enteros en la que cada elemento cuenta el
n칰mero de veces que algo sucede.
\item [{Correspondencia de patrones:}] plan de desarrollo de programas
que implica identificar un patr칩n computacional familiar y copiar
la soluci칩n de un problema similar.

\index{tipo mutable} \index{tipo inmutable} \index{tupla} \index{asignaci칩n de tupla}
\index{asignaci칩n!de tupla} \index{determin칤stico} \index{pseudoaleatorio}
\index{histograma} \index{correspondencia de patrones}
\end{description}

\section{Ejercicios}

Para cada funci칩n, agregue chequeo de tipos y pruebas unitarias.
\begin{enumerate}
\item Escriba una funci칩n mas\_frecuentes que tome una cadena e imprima
las letras en orden descendente por frecuencia. Ejec칰tela con textos
de diferentes lenguajes y observe como var칤an las frecuencias de letras.
Compare sus resultados con las tablas en:

\url{http://en.wikipedia.org/wiki/Letter_frequencies}

Soluci칩n: \url{http://thinkpython.com/code/most_frequent.py}
\item Escriba un programa que lea una lista de palabras de un archivo e
imprima todos los conjuntos de palabras que son anagramas.

Este es un ejemplo de la salida del programa con palabras en ingl칠s:
\begin{verbatim}
['deltas', 'desalt', 'lasted', 'salted', 'slated', 'staled'] 
['retainers', 'ternaries'] 
['generating', 'greatening']
['resmelts', 'smelters', 'termless']
\end{verbatim}
Pista: cree un diccionario que asocie cada conjunto de letras a una
lista de palabras que puedan ser formadas con esas letras. 쮺omo se
puede representar el conjunto de letras de forma que pueda ser usado
como llave? Modifique el programa que obtuvo para que imprima en orden
descendente por tama침o los conjuntos de anagramas. En el juego Scrabble,
un 'bingo' se da cuando se juegan las 7 fichas, junto con otra letra
en el tablero, para formar una palabra de 8 letras. 쯈ue conjunto
de 8 letras forma los bingos mas posibles?

Soluci칩n: \url{http://thinkpython.com/code/anagram_sets.py}
\item Dos palabras forma un 'par de metatesis' si se puede transformar una
en otra intercambiando dos letras. Por ejemplo, 'conversaci칩n' y 'conservaci칩n'.
Escriba un programa que encuentre todos los pares de metatesis en
el diccionario. Pista: no pruebe todos los pares.

Soluci칩n: \url{http://thinkpython.com/code/metathesis.py}

Cr칠dito: el ejercicio est치 inspirado por un ejemplo de \url{http://puzzlers.org}
\item 쮺ual es la palabra mas larga que sigue siendo v치lida a medida que
se remueven una a una sus letras? Por ejemplo, en ingl칠s, 'sprite'
sin la 'r' es 'spite', que sin la 'e', es 'spit', que sin la 's' es
'pit', que sin la 'p' es 'it' que sin la 't' es 'i'. Las letras se
pueden remover de cualquier posici칩n, pero no se pueden reordenar.

Escriba un programa que encuentre todas las palabras que pueden reducirse
de esta forma y que encuentre la mas larga.

Pistas:

Escriba una funci칩n que tome una palabra y calcule todas las palabras
que pueden formarse al removerle una letra. Estas son las palabras
'hijas'. Recursivamente, una palabra es reducible si alguno de sus
hijas es reducible. El caso base lo da la cadena vac칤a.

Soluci칩n: \url{http://thinkpython.com/code/reducible.py} 
\end{enumerate}

\end{document}
