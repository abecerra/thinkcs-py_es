%% LyX 2.2.3 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[oneside]{book}
\usepackage[utf8]{inputenc}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\synctex=-1
\usepackage{graphicx}

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\newcommand{\beforefig}{\vspace{1.3\parskip}}
\newcommand{\afterfig}{\vspace{-0.2\parskip}}
\newcommand{\adjustpage}[1]{\enlargethispage{#1\baselineskip}}

\makeatother

\usepackage{listings}
\renewcommand{\lstlistingname}{\inputencoding{latin9}Listado de cdigo}

\begin{document}

\chapter{Funciones }

\label{floatchap}

\section{Llamadas a funciones}

\label{functionchap} \index{llamada a funci贸n} \index{llamada!funci贸n}

Usted ya ha visto un ejemplo de una \textbf{llamada a funci贸n}:

\inputencoding{latin9}\begin{lstlisting}
>>> type("32")
str
\end{lstlisting}
\inputencoding{utf8}
El nombre de la funci贸n es \texttt{type}, y despliega el tipo de un
valor o variable. El valor o variable, que se denomina el \textbf{argumento}
de la funci贸n, tiene que encerrarse entre par茅ntesis. Es usual decir
que una funci贸n ``toma'' un argumento y ``retorna'' un resultado.
El resultado se denomina el \textbf{valor de retorno}.

\index{argumento} \index{valor de retorno}

En lugar de imprimir el valor de retorno, podemos asignarlo a una
variable:

\inputencoding{latin9}\begin{lstlisting}
>>> b = type("32")
>>> print(b)
<class 'string'>
\end{lstlisting}
\inputencoding{utf8} 

Otro ejemplo es la funci贸n \texttt{id} que toma un valor o una variable
y retorna un entero que act煤a como un identificador 煤nico:

\inputencoding{latin9}\begin{lstlisting}
>>> id(3)
134882108
>>> b = 3
>>> id(b)
134882108
\end{lstlisting}
\inputencoding{utf8} Cada valor tiene un \texttt{id} que es un n煤mero 煤nico relacionado
con el lugar en la memoria en el que est谩 almacenado. El \texttt{id}
de una variable es el \texttt{id} del valor al que la variable se
refiere.

\section{Conversi贸n de tipos}

\index{conversi贸n!tipo} \index{conversi贸n}

Python proporciona una colecci贸n de funciones que convierten valores
de un tipo a otro. La funci贸n \texttt{int} toma cualquier valor y
lo convierte a un entero, si es posible, de lo contrario se queja:

\inputencoding{latin9}\begin{lstlisting}
>>> int("32")
32
>>> int("Hola")
ValueError: invalid literal for int() with base 10: Hola
\end{lstlisting}
\inputencoding{utf8} \texttt{int} tambi茅n puede convertir valores de punto flotante a
enteros, pero hay que tener en cuenta que va a eliminar la parte decimal:

\inputencoding{latin9}\begin{lstlisting}
>>> int(3.99999)
3
>>> int(-2.3)
-2
\end{lstlisting}
\inputencoding{utf8} La funci贸n \texttt{float} convierte enteros y cadenas a n煤meros de
punto flotante:

\inputencoding{latin9}\begin{lstlisting}
>>> float(32)
32.0
>>> float("3.14159")
3.14159
\end{lstlisting}
\inputencoding{utf8} Finalmente, la funci贸n \texttt{str} convierte al tipo cadena (\texttt{string}):

\inputencoding{latin9}\begin{lstlisting}
>>> str(32)
'32'
>>> str(3.14149)
'3.14149'
\end{lstlisting}
\inputencoding{utf8} Puede parecer extra帽o el hecho de que Python distinga el valor entero
\texttt{1} del valor en punto flotante \texttt{1.0}. Pueden representar
el mismo n煤mero pero tienen diferentes tipos. La raz贸n para esto es
que su representaci贸n interna en la memoria del computador es distinta.

\section{Coerci贸n de tipos}

\index{coerci贸n de tipos} \index{coerci贸n!tipo} \index{divisi贸n entera}
\index{divisi贸n!entera}

Podemos sacar provecho de las reglas de conversi贸n autom谩tica de tipos,
que se denominan \textbf{coerci贸n de tipos}. Para los operadores matem谩ticos,
si alg煤n operando es un n煤mero \texttt{flotante}, el otro se convierte
autom谩ticamente a \texttt{flotante}:

\inputencoding{latin9}\begin{lstlisting}
>>> minuto = 59
>>> minuto / 60.0
0.983333333333
\end{lstlisting}
\inputencoding{utf8}
As铆 que haciendo el denominador flotante, forzamos a Python a realizar
divisi贸n en punto flotante.

\section{Funciones matem谩ticas}

\index{funci贸n matem谩tica} \index{funci贸n!matem谩tica}

En matem谩tica usted probablemente ha visto funciones como el \texttt{seno}
y el \texttt{logaritmo}, y ha aprendido a evaluar expresiones como
\texttt{sen(pi/2)} y \texttt{log(1/x)}. Primero, se eval煤a la expresi贸n
entre par茅ntesis (el argumento). Por ejemplo, \texttt{pi/2} es aproximadamente
1.571, y \texttt{1/x} es 0.1 (si \texttt{x} tiene el valor 10.0).

Entonces, se eval煤a la funci贸n, ya sea mirando el resultado en una
tabla o calculando varias operaciones. El \texttt{seno} de 1.571 es
1, y el \texttt{logaritmo} de 0.1 es -1 (asumiendo que \texttt{log}
indica el logaritmo en base 10).

Este proceso puede aplicarse repetidamente para evaluar expresiones
m谩s complicadas como \texttt{log(1/sen(pi/2))}. Primero se eval煤a
el argumento de la funci贸n m谩s interna, luego la funci贸n, y se contin煤a
as铆.

Python tiene un m贸dulo matem谩tico que proporciona la mayor铆a de las
funciones matem谩ticas. Un m贸dulo es un archivo que contiene una colecci贸n
de funciones relacionadas.

\index{m贸dulo}

Antes de que podamos usar funciones de un m贸dulo, tenemos que importarlas:

\inputencoding{latin9}\begin{lstlisting}
>>> import math
\end{lstlisting}
\inputencoding{utf8} Para llamar a una de las funciones, tenemos que especificar el nombre
del m贸dulo y el nombre de la funci贸n, separados por un punto. Este
formato se denomina \textbf{notaci贸n punto}.

\index{notaci贸n punto}

\inputencoding{latin9}\begin{lstlisting}
>>> decibel = math.log10(17.0)
>>> angulo = 1.5
>>> altura = math.sin(angulo)
\end{lstlisting}
\inputencoding{utf8} La primera sentencia le asigna a \texttt{decibel} el logaritmo de
17, en base \texttt{10}. Tambi茅n hay una funci贸n llamada \texttt{log}
que usa la base logar铆tmica \texttt{e}.

La tercera sentencia encuentra el seno del valor de la variable \texttt{angulo}.
\texttt{sin} y las otras funciones trigonom茅tricas (\texttt{cos},
\texttt{tan}, etc.) reciben sus argumentos en radianes. Para convertir
de grados a radianes hay que dividir por 360 y multiplicar por \texttt{2{*}pi}.
Por ejemplo, para encontrar el seno de 45 grados, primero calculamos
el 谩ngulo en radianes y luego tomamos el seno:

\inputencoding{latin9}\begin{lstlisting}
>>> grados = 45
>>> angulo = grados * 2 * math.pi / 360.0
>>> math.sin(angulo)
\end{lstlisting}
\inputencoding{utf8} La constante \texttt{pi} tambi茅n hace parte del m贸dulo matem谩tico.
Si usted recuerda geometr铆a puede verificar el resultado compar谩ndolo
con la ra铆z cuadrada de 2 dividida por 2:

\inputencoding{latin9}\begin{lstlisting}
>>> math.sqrt(2) / 2.0
0.707106781187
\end{lstlisting}
\inputencoding{utf8} 

\section{Composici贸n}

\index{composici贸n} \index{funci贸n!composici贸n}

As铆 como las funciones matem谩ticas, las funciones de Python pueden
componerse, de forma que una expresi贸n sea parte de otra. Por ejemplo,
usted puede usar cualquier expresi贸n como argumento a una funci贸n:

\inputencoding{latin9}\begin{lstlisting}
>>> x = math.cos(angulo + math.pi/2)
\end{lstlisting}
\inputencoding{utf8}
Esta sentencia toma el valor de \texttt{pi}, lo divide por 2, y suma
este resultado al valor de \texttt{angulo}. Despu茅s, la suma se le
pasa como argumento a la funci贸n coseno (\texttt{cos}).

Tambi茅n se puede tomar el resultado de una funci贸n y pasarlo como
argumento a otra:\inputencoding{latin9}
\begin{lstlisting}
>>> x = math.exp(math.log(10.0))
\end{lstlisting}
\inputencoding{utf8}
Esta sentencia halla el logaritmo en base \texttt{e} de 10 y luego
eleva \texttt{e} a dicho resultado. El resultado se asigna a \texttt{x}.

\section{Agregando nuevas funciones}

Hasta aqu铆 solo hemos usado las funciones que vienen con Python, pero
tambi茅n es posible agregar nuevas funciones. Crear nuevas funciones
para resolver nuestros problemas particulares es una de las capacidades
mas importantes de un lenguaje de programaci贸n de prop贸sito general.

En el contexto de la programaci贸n, una \textbf{funci贸n} es una secuencia
de sentencias que ejecuta una operaci贸n deseada y tiene un nombre.
Esta operaci贸n se especifica en una \textbf{definici贸n de funci贸n}.
Las funciones que hemos usado hasta ahora ya han sido definidas para
nosotros. Esto es bueno, porque nos permite usarlas sin preocuparnos
de los detalles de sus definiciones.

\index{funci贸n} \index{funci贸n definici贸n} \index{definici贸n!funci贸n}

La sintaxis para una definici贸n de funci贸n es:

\inputencoding{latin9}\begin{lstlisting}
def NOMBRE( LISTA DE PARAMETROS ):
  SENTENCIAS
\end{lstlisting}
\inputencoding{utf8} Usted puede inventar los nombres que desee para sus funciones con
tal de que no use una palabra reservada. La lista de par谩metros especifica
que informaci贸n, si es que la hay, se debe proporcionar a fin de usar
la nueva funci贸n.

Se puede incluir cualquier n煤mero de sentencias dentro de la funci贸n,
pero tienen que sangrarse o indentarse a partir de la margen izquierda.
La pr谩ctica est谩ndar de Python es usar 4 espacios.

Las primeras funciones que vamos a escribir no tienen par谩metros,
as铆 que la sintaxis luce as铆:

\inputencoding{latin9}\begin{lstlisting}
def nuevaLinea():
  print()
\end{lstlisting}
\inputencoding{utf8} Esta funci贸n se llama \texttt{nuevaLinea}. Los par茅ntesis vac铆os
indican que no tiene par谩metros. Contiene solamente una sentencia,
que produce como salida una l铆nea vac铆a. Eso es lo que ocurre cuando
se usa el comando \texttt{print} sin argumentos.

La sintaxis para llamar la nueva funci贸n es la misma que para las
funciones predefinidas en Python:

\inputencoding{latin9}\begin{lstlisting}
print("Primera Linea.")
nuevaLinea()
print("Segunda Linea.")
\end{lstlisting}
\inputencoding{utf8} La salida para este programa es:
\begin{verbatim}
Primera Linea.

Segunda Linea.
\end{verbatim}
Note el espacio extra entre las dos l铆neas. 驴Qu茅 pasa si deseamos
m谩s espacio entre las l铆neas? Podemos llamar la misma funci贸n repetidamente:

\inputencoding{latin9}\begin{lstlisting}
print("Primera Linea.")
nuevaLinea()
nuevaLinea()
nuevaLinea()
print("Segunda Linea.")
\end{lstlisting}
\inputencoding{utf8} 

O podemos escribir una nueva funci贸n llamada \texttt{tresLineas} que
imprima tres l铆neas:

\inputencoding{latin9}\begin{lstlisting}
def tresLineas():
  nuevaLinea()
  nuevaLinea()
  nuevaLinea()

print("Primera Linea.")
tresLineas()
print("Segunda Linea.")
\end{lstlisting}
\inputencoding{utf8} Esta funci贸n contiene tres sentencias, y todas est谩n sangradas por
dos espacios. Como la pr贸xima sentencia, \texttt{}\inputencoding{latin9}\lstinline!print("Primera Linea")!\inputencoding{utf8},
no est谩 sangrada, Python la interpreta afuera de la funci贸n.

Hay que enfatizar dos hechos sobre este programa:
\begin{enumerate}
\item Usted puede llamar la misma funci贸n repetidamente. De hecho, es una
pr谩ctica muy com煤n y 煤til.
\item Usted puede llamar una funci贸n dentro de otra funci贸n; en este caso
\texttt{tresLineas} llama a \texttt{nuevaLinea}.
\end{enumerate}
Hasta este punto, puede que no parezca claro porque hay que tomarse
la molestia de crear todas estas funciones. De hecho, hay muchas razones,
y este ejemplo muestra dos:
\begin{itemize}
\item Crear una nueva funci贸n le da a usted la oportunidad de nombrar un
grupo de sentencias. Las funciones pueden simplificar un programa
escondiendo un c谩lculo complejo detr谩s de un comando 煤nico que usa
palabras en lenguaje natural, en lugar de un c贸digo arcano.
\item Crear una nueva funci贸n puede recortar el tama帽o de un programa eliminando
el c贸digo repetitivo. Por ejemplo, una forma m谩s corta de imprimir
nueve l铆neas consecutivas consiste en llamar la funci贸n \texttt{tresLineas}
tres veces.
\end{itemize}

\section{Definiciones y uso}

Uniendo los fragmentos de la secci贸n 3.6, el programa completo luce
as铆:

\inputencoding{latin9}\begin{lstlisting}
def nuevaLinea():
  print()

def tresLineas():
  nuevaLinea()
  nuevaLinea()
  nuevaLinea()

print("Primera Linea.")
tresLineas()
print("Segunda Linea.")
\end{lstlisting}
\inputencoding{utf8} Este programa contiene dos definiciones de funciones: \texttt{nuevaLinea}
y \texttt{tresLineas}. Las definiciones de funciones se ejecutan como
las otras sentencias, pero su efecto es crear nuevas funciones. Las
sentencias, dentro de la funci贸n, no se ejecutan hasta que la funci贸n
sea llamada, y la definici贸n no genera salida.

Como usted puede imaginar, se tiene que crear una funci贸n antes de
ejecutarla. En otras palabras, la definici贸n de funci贸n tiene que
ejecutarse antes de llamarla por primera vez.

\section{Flujo de ejecuci贸n}

\index{flujo de ejecuci贸n}

Con el objetivo de asegurar que una funci贸n se defina antes de su
primer uso usted tiene que saber el orden en el que las sentencias
se ejecutan, lo que denominamos \textbf{flujo de ejecuci贸n}.

La ejecuci贸n siempre empieza con la primera sentencia del programa.
Las sentencias se ejecutan una a una, desde arriba hacia abajo.

Las definiciones de funciones no alteran el flujo de ejecuci贸n del
programa, recuerde que las sentencias que est谩n adentro de las funciones
no se ejecutan hasta que 茅stas sean llamadas. Aunque no es muy com煤n,
usted puede definir una funci贸n adentro de otra. En este caso, la
definici贸n interna no se ejecuta hasta que la otra funci贸n se llame.

Las llamadas a funci贸n son como un desv铆o en el flujo de ejecuci贸n.
En lugar de continuar con la siguiente sentencia, el flujo salta a
la primera l铆nea de la funci贸n llamada, ejecuta todas las sentencias
internas, y regresa para continuar donde estaba previamente.

Esto suena sencillo, hasta que tenemos en cuenta que una funci贸n puede
llamar a otra. Mientras se est谩 ejecutando una funci贸n, el programa
puede ejecutar las sentencias en otra funci贸n. Pero, mientras se est谩
ejecutando la nueva funci贸n, 隆el programa puede tener que ejecutar
\textit{otra} funci贸n!.

Afortunadamente, Python lleva la pista de donde est谩 fielmente, as铆
que cada vez que una funci贸n termina, el programa contin煤a su ejecuci贸n
en el punto donde se la llam贸. Cuando llega al fin del programa, la
ejecuci贸n termina.

驴Cual es la moraleja de esta s贸rdida historia? Cuando lea un programa,
no lo haga de arriba hacia abajo. En lugar de 茅sto, siga el flujo
de ejecuci贸n.

\section{Par谩metros y argumentos}

\label{parameters} \index{par谩metro} \index{funci贸n!par谩metro}
\index{argumento} \index{funci贸n!argumento}

Algunas de las funciones primitivas que usted ha usado requieren argumentos,
los valores que controlan el trabajo de la funci贸n. Por ejemplo, si
usted quiere encontrar el seno de un n煤mero, tiene que indicar cual
es el n煤mero. As铆 que, \texttt{sin} toma un valor num茅rico como argumento.

Algunas funciones toman m谩s de un argumento. Por ejemplo \texttt{pow}
(potencia) toma dos argumentos, la base y el exponente. Dentro de
una funci贸n, los valores que se pasan se asignan a variables llamadas
\textbf{par谩metros}.

Aqu铆 hay un ejemplo de una funci贸n definida por el programador que
toma un par谩metro:

\inputencoding{latin9}\begin{lstlisting}
def imprimaDoble(pedro):
  print(pedro, pedro)
\end{lstlisting}
\inputencoding{utf8} Esta funci贸n toma un argumento y lo asigna a un par谩metro llamado
\texttt{pedro}. El valor del par谩metro (en este momento no tenemos
idea de lo que ser谩) se imprime dos veces, y despu茅s, se imprime una
l铆nea vac铆a. El nombre \texttt{pedro} se escogi贸 para sugerir que
el nombre que se le asigna a un par谩metro queda a su libertad; pero,
en general, usted desea escoger algo mas ilustrativo que \texttt{pedro}.

La funci贸n \texttt{imprimaDoble} funciona para cualquier tipo que
pueda imprimirse:

\inputencoding{latin9}\begin{lstlisting}
>>> imprimaDoble('Spam')
Spam Spam
>>> imprimaDoble(5)
5 5
>>> imprimaDoble(3.14159)
3.14159 3.14159
\end{lstlisting}
\inputencoding{utf8} En el primer llamado de funci贸n el argumento es una cadena. En el
segundo es un entero. En el tercero es un flotante (\texttt{float}).

Las mismas reglas de composici贸n que se aplican a las funciones primitivas,
se aplican a las definidas por el programador, as铆 que podemos usar
cualquier clase de expresi贸n como un argumento para \texttt{imprimaDoble}:

\inputencoding{latin9}\begin{lstlisting}
>>> imprimaDoble('Spam'*4)
SpamSpamSpamSpam SpamSpamSpamSpam
>>> imprimaDoble(math.cos(math.pi))
-1.0 -1.0
\end{lstlisting}
\inputencoding{utf8} Como de costumbre, la expresi贸n se eval煤a antes de que la funci贸n
se ejecute as铆 que \texttt{imprimaDoble} retorna \texttt{SpamSpamSpamSpam
SpamSpamSpamSpam} en lugar de \texttt{'Spam'{*}4 'Spam'{*}4}.

Tambi茅n podemos usar una variable como argumento:

\inputencoding{latin9}\begin{lstlisting}
>>> m = 'Oh, mundo cruel.'
>>> imprimaDoble(m)
Oh, mundo cruel. Oh, mundo cruel.
\end{lstlisting}
\inputencoding{utf8} Observe algo muy importante, el nombre de la variable que pasamos
como argumento (\texttt{m}) no tiene nada que ver con el nombre del
par谩metro (\texttt{pedro}). No importa como se nombraba el valor originalmente
(en el lugar donde se hace el llamado); en la funci贸n \texttt{imprimaDoble},
la seguimos llamando de la misma manera \texttt{pedro}.

\section{Las variables y los par谩metros son locales}

\index{variable local} \index{variable!local}

Cuando usted crea una \textbf{variable local} en una funci贸n, solamente
existe dentro de ella, y no se puede usar por fuera. Por ejemplo:

\inputencoding{latin9}\begin{lstlisting}
def concatenarDoble(parte1, parte2):
  cat = parte1 + parte2
  imprimaDoble(cat)
\end{lstlisting}
\inputencoding{utf8} Esta funci贸n toma dos argumentos, los concatena, y luego imprime
el resultado dos veces. Podemos llamar a la funci贸n con dos cadenas:

\inputencoding{latin9}\begin{lstlisting}
>>> cantar1 = "Pie Jesu domine, "
>>> cantar2 = "Dona eis requiem."
>>> concatenarDoble(cantar1, cantar2)
Pie Jesu domine, Dona eis requiem. Pie Jesu domine, Dona 
eis requiem.
\end{lstlisting}
\inputencoding{utf8}
Cuando \texttt{concatenarDoble} termina, la variable \texttt{cat}
se destruye. Si intent谩ramos imprimirla obtendr铆amos un error:

\inputencoding{latin9}\begin{lstlisting}
>>> print(cat)
NameError: cat
\end{lstlisting}
\inputencoding{utf8} Los par谩metros tambi茅n son locales. Por ejemplo, afuera de la funci贸n
\texttt{imprimaDoble}, no existe algo como \texttt{pedro}. Si usted
intenta usarlo Python se quejar谩.

\section{Diagramas de pila}

\label{stackdiagram} \index{diagrama de pila} \index{marco de funci贸n}
\index{marco}

Para llevar pista de los lugares en que pueden usarse las variables
es 煤til dibujar un \textbf{diagrama de pila}. Como los diagramas de
estados, los diagramas de pila muestran el valor de cada variable
y adem谩s muestran a que funci贸n pertenece cada una.

Cada funci贸n se representa por un \textbf{marco}. Un marco es una
caja con el nombre de una funci贸n al lado y los par谩metros y variables
adentro. El diagrama de pila para el ejemplo anterior luce as铆:

\adjustpage{-4} \beforefig \centerline{\includegraphics{illustrations/stack}}
\afterfig

El orden de la pila muestra el flujo de ejecuci贸n. \texttt{imprimaDoble}
fue llamada por \texttt{concatenarDoble}, y \texttt{concatenarDoble}
fue llamada por \texttt{\_\_main\_\_}, que es un nombre especial para
la funci贸n m谩s superior (la principal, que tiene todo programa). Cuando
usted crea una variable afuera de cualquier funci贸n, pertenece a \texttt{\_\_main\_\_}.

Cada par谩metro se refiere al mismo valor que su argumento correspondiente.
As铆 que \texttt{parte1} tiene el mismo valor que \texttt{cantar1},
\texttt{parte2} tiene el mismo valor que \texttt{cantar2}, y \texttt{pedro}
tiene el mismo valor que \texttt{cat}.

Si hay un error durante una llamada de funci贸n, Python imprime el
nombre de 茅sta, el nombre de la funci贸n que la llam贸, y as铆 sucesivamente
hasta llegar a \texttt{\_\_main\_\_}.

Por ejemplo, si intentamos acceder a \texttt{cat} desde \texttt{imprimaDoble},
obtenemos un \texttt{error de nombre (NameError)}:
\begin{verbatim}
Traceback (innermost last):
  File "test.py", line 13, in __main__
    concatenarDoble(cantar1, cantar2)
  File "test.py", line 5, in concatenarDoble
    imprimaDoble(cat)
  File "test.py", line 9, in imprimaDoble
    print(cat)
NameError: cat
\end{verbatim}
Esta lista de funciones se denomina un \textbf{trazado inverso}. Nos
informa en qu茅 archivo de programa ocurri贸 el error, en qu茅 l铆nea,
y qu茅 funciones se estaban ejecutando en ese momento. Tambi茅n muestra
la l铆nea de c贸digo que caus贸 el error.

\index{trazado inverso}

Note la semejanza entre el trazado inverso y el diagrama de pila.
Esto no es una coincidencia.

\section{Funciones con resultados}

Usted ya puede haber notado que algunas de las funciones que estamos
usando, como las matem谩ticas, entregan resultados. Otras funciones,
como \texttt{nuevaLinea}, ejecutan una acci贸n pero no entregan un
resultado. Esto genera algunas preguntas:
\begin{enumerate}
\item 驴Qu茅 pasa si usted llama a una funci贸n y no hace nada con el resultado
(no lo asigna a una variable o no lo usa como parte de una expresi贸n
mas grande)?
\item 驴Qu茅 pasa si usted usa una funci贸n sin un resultado como parte de
una expresi贸n, tal como \texttt{nuevaLinea() + 7}?
\item 驴Se pueden escribir funciones que entreguen resultados, o estamos
limitados a funciones tan simples como \texttt{nuevaLinea} y \texttt{imprimaDoble}?
\end{enumerate}
La respuesta a la tercera pregunta es afirmativa y lo lograremos en
el cap铆tulo \ref{funcReturn}.

\section{Glosario}
\begin{description}
\item [{Llamada a funci贸n:}] sentencia que ejecuta una funci贸n. Consiste
en el nombre de la funci贸n seguido por una lista de argumentos encerrados
entre par茅ntesis.
\item [{Argumento:}] valor que se le da a una funci贸n cuando se la est谩
llamando. Este valor se le asigna al par谩metro correspondiente en
la funci贸n.
\item [{Valor de retorno:}] es el resultado de una funci贸n. Si una llamada
a funci贸n se usa como una expresi贸n, el valor de 茅sta es el valor
de retorno de la funci贸n.
\item [{Conversi贸n de tipo:}] sentencia expl铆cita que toma un valor de
un tipo y calcula el valor correspondiente de otro tipo.
\item [{Coerci贸n de tipos:}] conversi贸n de tipo que se hace autom谩ticamente
de acuerdo a las reglas de coerci贸n del lenguaje de programaci贸n.
\item [{M贸dulo:}] archivo que contiene una colecci贸n de funciones y clases
relacionadas.
\item [{Notaci贸n punto:}] sintaxis para llamar una funci贸n que se encuentra
en otro m贸dulo, especificando el nombre m贸dulo seguido por un punto
y el nombre de la funci贸n (sin dejar espacios intermedios).
\item [{Funci贸n:}] es la secuencia de sentencias que ejecuta alguna operaci贸n
煤til y que tiene un nombre definido. Las funciones pueden tomar o
no tomar par谩metros y pueden entregar o no entregar un resultado.
\item [{Definici贸n de funci贸n:}] sentencia que crea una nueva funci贸n
especificando su nombre, par谩metros y las sentencias que ejecuta.
\item [{Flujo de ejecuci贸n:}] orden en el que las sentencias se ejecutan
cuando un programa corre.
\item [{Par谩metro:}] nombre usado dentro de una funci贸n para referirse
al valor que se pasa como argumento.
\item [{Variable local:}] variable definida dentro de una funci贸n. Una
variable local solo puede usarse dentro de su funci贸n.
\item [{Diagrama de pila:}] es la representaci贸n gr谩fica de una pila de
funciones, sus variables, y los valores a los que se refieren.
\item [{Marco:}] una caja en un diagrama de pila que representa un llamado
de funci贸n. Contiene las variables locales y los par谩metros de la
funci贸n.
\item [{Trazado inverso:}] lista de las funciones que se estaban ejecutando
y que se imprime cuando ocurre un error en tiempo de ejecuci贸n.

\index{llamada a funci贸n} \index{valor de retorno} \index{argumento}
\index{coerci贸n} \index{m贸dulo} \index{notaci贸n punto} \index{funci贸n}
\index{definici贸n de funci贸n} \index{flujo de ejecuci贸n} \index{par谩metro}
\index{variable local} \index{diagrama de pila} \index{marco de funci贸n}
\index{marco} \index{trazado inverso}
\end{description}

\section{Ejercicios}
\begin{enumerate}
\item Con un editor de texto cree un gui贸n de Python que se llame pruebame3.py.
Escriba en este archivo una funci贸n que se llame \verb+nueveLineas+
que use la funci贸n \verb+tresLineas+ para mostrar nueve l铆neas en
blanco. Enseguida agregue una funci贸n que se llame \verb+limpiaPantalla+
que muestre veinticinco l铆neas en blanco. La 煤ltima instrucci贸n en
su programa debe ser una llamada a \verb+limpiaPantalla+.
\item Mueva la 煤ltima instrucci贸n del archivo pruebame3.py al inicio del
programa, de forma tal que la llamada a la funci贸n \verb+limpiaPantalla+
est茅 antes que la definici贸n de funci贸n. Ejecute el programa y registre
qu茅 mensaje de error obtiene. 驴Puede establecer una regla sobre las
definiciones de funciones y las llamadas a funci贸n que describa la
posici贸n relativa entre ellas en el programa?
\item Escriba una funci贸n que imprima la distancia que hay entre dos puntos
ubicados sobre el eje X de un plano cartesiano conociendo sus coordenadas
horizontales.
\item Escriba una funci贸n que imprima la distancia que hay entre dos puntos
ubicados sobre el eje Y de un plano cartesiano conociendo sus coordenadas
verticales.
\item Escriba una funci贸n que imprima la distancia que hay entre dos puntos
en un plano coordenado, recordando el teorema de Pit谩goras.
\item Tome la soluci贸n del 煤ltimo ejercicio del cap铆tulo anterior y convi茅rtala
en una funci贸n que imprima la nota definitiva de su curso de programaci贸n.
\end{enumerate}

\end{document}
