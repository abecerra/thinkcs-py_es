
\chapter{Cadenas }

\label{strings}

\section{Un tipo de dato compuesto}

\index{tipo de dato compuesto} \index{tipo de dato!compuesto}

Hasta aqu√≠ hemos visto tres tipos de datos: \texttt{int}, \texttt{float}
y \texttt{string}. Las cadenas son cualitativamente diferentes de
los otros dos tipos porque est√°n compuestas de piezas m√°s peque√±as‚Äîlos
caracteres.

\index{car√°cter}

Los tipos que comprenden piezas m√°s peque√±as se denominan \textbf{tipos
de datos compuestos}. Dependiendo de lo que hagamos podemos tratar
un tipo compuesto como unidad o podemos acceder a sus partes. Esta
ambig√ºedad es provechosa.

\index{operador corchete} \index{operador!corchete}

El operador corchete selecciona un car√°cter de una cadena.

\inputencoding{latin9}\begin{lstlisting}
>>> fruta = "banano"
>>> letra = fruta[1]
>>> print(letra)	
\end{lstlisting}
\inputencoding{utf8}
La expresi√≥n \texttt{fruta{[}1{]}} selecciona el car√°cter n√∫mero 1
de \texttt{fruta}. La variable \texttt{letra} se refiere al resultado.
Cuando desplegamos \texttt{letra}, obtenemos una peque√±a sorpresa:
\begin{verbatim}
a
\end{verbatim}
La primera letra de ``banano'' no es \texttt{a}. ¬°A menos que usted
sea un cient√≠fico de la computaci√≥n! Por razones perversas, los cient√≠ficos
de la computaci√≥n empiezan a contar desde cero. La letra n√∫mero 0
de \texttt{``banano''} es \texttt{b}. La letra 1 es a, y la letra
2 es n.

Si usted desea la primera letra de una cadena se pone 0, o cualquier
expresi√≥n con el valor 0, dentro de los corchetes:\inputencoding{latin9}
\begin{lstlisting}
>>> letra = fruta[0]
>>> print(letra)
b
\end{lstlisting}
\inputencoding{utf8}
La expresi√≥n en corchetes se denomina \textbf{√≠ndice}. Un √≠ndice especifica
un miembro de un conjunto ordenado, en este caso el conjunto de caracteres
de la cadena. El √≠ndice {\em indica} cual elemento desea usted,
por eso se llama as√≠. Puede ser cualquier expresi√≥n entera.

\index{√≠ndice}

\section{Longitud}

\index{cadena!longitud} \index{error de tiempo de ejecuci√≥n}

La funci√≥n \texttt{len} retorna el n√∫mero de caracteres en una cadena:

\inputencoding{latin9}\begin{lstlisting}
>>> fruta = "banano"
>>> len(fruta)
6
\end{lstlisting}
\inputencoding{utf8} Para acceder a la √∫ltima letra de una cadena usted podr√≠a caer en
algo como esto:\inputencoding{latin9}
\begin{lstlisting}
longitud = len(fruta)
ultima = fruta[longitud]       # ERROR!
\end{lstlisting}
\inputencoding{utf8}
Y no funcionar√°. Causa un error en tiempo de ejecuci√≥n, \texttt{IndexError: string
index out of range}. La raz√≥n yace en que no hay una letra 6 en ``banano''.
Como empezamos a contar desde cero, las seis letras se numeran de
0 a 5. En general, para obtener la √∫ltima letra, tenemos que restar
1 a la \texttt{longitud}:

\index{error en tiempo de ejecuci√≥n}

\inputencoding{latin9}\begin{lstlisting}
longitud = len(fruta)
ultima = fruta[longitud-1]
\end{lstlisting}
\inputencoding{utf8}
Alternativamente, podemos usar √≠ndices negativos, que cuentan hacia
atr√°s desde el fin de la cadena. La expresi√≥n \texttt{fruta{[}-1{]}}
retorna la √∫ltima letra \texttt{fruta{[}-2{]}} retorna la pen√∫ltima,
y as√≠ sucesivamente.

\index{√≠ndice!negativo}

\section{Recorridos en cadenas y el ciclo \texttt{for}}

\label{for} 

\index{recorridos} \index{ciclo!recorrido} \index{ciclo for} \index{ciclo!ciclo for}

Muchos c√°lculos implican procesar una cadena car√°cter por car√°cter.
A menudo empiezan al inicio, seleccionan cada car√°cter en cada paso,
le hacen algo y contin√∫an hasta el final. Este patr√≥n de procesamiento
se denomina \textbf{recorrido}. Hay una forma de realizarlo con la
sentencia \texttt{while}:\inputencoding{latin9}
\begin{lstlisting}
indice = 0
while indice < len(fruta):
  letra = fruta[indice]
  print(letra)
  indice = indice + 1
\end{lstlisting}
\inputencoding{utf8}
Este ciclo recorre la cadena y despliega cada letra en una l√≠nea independiente.
La condici√≥n del ciclo es \texttt{indice < len(fruta)}, as√≠ que cuando
\texttt{indice} se hace igual a la longitud de la cadena, la condici√≥n
es falsa, y el cuerpo del ciclo no se ejecuta. El √∫ltimo car√°cter
accedido es el que tiene el √≠ndice \texttt{len(fruta)-1}, es decir,
el √∫ltimo.

Usar un √≠ndice para recorrer un conjunto de valores es tan com√∫n que
Python tiene una sintaxis alternativa m√°s simple‚Äîel ciclo \texttt{for}
:

\inputencoding{latin9}\begin{lstlisting}
for caracter in fruta:
   print(caracter)
\end{lstlisting}
\inputencoding{utf8}
Cada vez que el ciclo itera, el pr√≥ximo car√°cter en la cadena se asigna
a la variable \texttt{caracter}. El ciclo contin√∫a hasta que no quedan
m√°s caracteres.

\index{concatenaci√≥n} \index{lexicogr√°fico} \index{McCloskey, Robert}
\index{Make Way for Ducklings@{\em Make Way for Ducklings}}

El siguiente ejemplo muestra c√≥mo usar la concatenaci√≥n y un ciclo
\texttt{for} para generar una serie en orden lexicogr√°fico. Lexicogr√°fico
se refiere a una lista en la que los elementos aparecen en orden alfab√©tico.
Por ejemplo, en el libro {\em Make Way for Ducklings} de Robert
McCloskey, los nombres de los patos son Jack, Kack, Lack, Mack, Nack,
Ouack, Pack, and Quack. Este ciclo los despliega en orden:\inputencoding{latin9}
\begin{lstlisting}
prefijos = "JKLMNOPQ"
sufijo = "ack"

for letra in prefijos:
  print(letra + sufijo)
\end{lstlisting}
\inputencoding{utf8}
La salida de este programa es:\inputencoding{latin9}
\begin{lstlisting}
Jack
Kack
Lack
Mack
Nack
Oack
Pack
Qack
\end{lstlisting}
\inputencoding{utf8}
Por supuesto que hay un error, ya que ``Ouack'' y ``Quack'' no
est√°n bien deletreados.

\section{Segmentos de cadenas }

\label{slice} \index{segmento} \index{cadena!segmento}

Una porci√≥n de una cadena de caracteres se denomina \textbf{segmento}.
Seleccionar un segmento es similar a seleccionar un car√°cter:\inputencoding{latin9}
\begin{lstlisting}
>>> s = "Pedro, Pablo, y Maria"
>>> print(s[0:5])
Pedro
>>> print(s[7:12])
Pablo
>>> print(s[16:21])
Maria
\end{lstlisting}
\inputencoding{utf8}
El operador \texttt{{[}n:m{]}} retorna la parte de la cadena que va
desde el car√°cter n hasta el m, incluyendo el primero y excluyendo
el √∫ltimo. Este comportamiento es contraintuitivo, tiene m√°s sentido
si se imagina que los √≠ndices van {\em antes} de los caracteres,
como en el siguiente diagrama:

\beforefig \centerline{\includegraphics{illustrations/banana}}
\afterfig

Si usted omite el primer √≠ndice (antes de los puntos seguidos), el
segmento comienza en el inicio de la cadena. Si se omite el segundo
√≠ndice, el segmento va hasta el final. Entonces:\inputencoding{latin9}
\begin{lstlisting}
>>> fruta  = "banano"
>>> fruta[:3]
'ban'
>>> f[3:]
'ano'
\end{lstlisting}
\inputencoding{utf8} ¬øQue cree que significa \texttt{s{[}:{]}}?

\section{Comparaci√≥n de cadenas}

\index{comparaci√≥n de cadenas} \index{comparaci√≥n!de cadenas}

El operador de comparaci√≥n funciona con cadenas. Para ver si dos cadenas
son iguales:\inputencoding{latin9}
\begin{lstlisting}
if palabra == "banana":
  print("No hay bananas!")
\end{lstlisting}
\inputencoding{utf8}Las otras operaciones de comparaci√≥n son √∫tiles para poner las palabras
en orden alfab√©tico:\inputencoding{latin9}
\begin{lstlisting}
if palabra < "banana":
  print("Su palabra," + palabra + ", va antes que banana.")
elif palabra > "banana":
  print("Su palabra," + palabra + ", va despuÈs de banana.")
else:
  print("No hay banana!")
\end{lstlisting}
\inputencoding{utf8}
Sin embargo, usted debe ser consciente de que Python no maneja las
letras min√∫sculas y may√∫sculas de la misma forma en que lo hace la
gente. Todas las letras may√∫sculas vienen antes de las min√∫sculas.
Si palabra vale ``Zebra'' la salida ser√≠a:
\begin{verbatim}
Su palabra, Zebra, va antes que banana.
\end{verbatim}
Este problema se resuelve usualmente convirtiendo las cadenas a un
formato com√∫n, todas en min√∫sculas por ejemplo, antes de hacer la
comparaci√≥n. Un problema m√°s dif√≠cil es lograr que el programa reconozca
que una zebra no es una fruta.

\section{Las cadenas son inmutables}

\index{mutable} \index{cadena inmutable} \index{cadena!inmutable}

Uno puede caer en la trampa de usar el operador \texttt{{[}{]}} al
lado izquierdo de una asignaci√≥n con la intenci√≥n de modificar un
car√°cter en una cadena. Por ejemplo:\inputencoding{latin9}
\begin{lstlisting}
saludo = "Hola mundo"
saludo[0] = 'J'            # ERROR!
print(saludo)
\end{lstlisting}
\inputencoding{utf8} En lugar de desplegar \texttt{Jola mundo!}, se produce un error en
tiempo de ejecuci√≥n \texttt{TypeError: object doesn't support item
assignment}.

\index{error en tiempo de ejecuci√≥n}

Las cadenas son \textbf{inmutables}, lo que quiere decir que no se
puede cambiar una cadena existente. Lo m√°ximo que se puede hacer es
crear otra cadena que cambia un poco a la original:\inputencoding{latin9}
\begin{lstlisting}
saludo = "Hola mundo!"
nuevoSaludo = 'J' + saludo[1:]
print(nuevoSaludo)
\end{lstlisting}
\inputencoding{utf8}
La soluci√≥n consiste en concatenar la primera nueva letra con un segmento
de \texttt{saludo}. Esto no tiene efecto sobre la primera cadena,
usted puede chequearlo.

\index{concatenaci√≥n}

\section{Una funci√≥n \texttt{buscar} }

\label{find} \index{recorrido} \index{recorrido eureka} \index{patr√≥n}
\index{patr√≥n computacional}

¬øQu√© hace la siguiente funci√≥n?

\inputencoding{latin9}\begin{lstlisting}
def buscar(cad, c):
  indice = 0
  while indice < len(cad):
    if cad[indice] == c:
      return indice
    indice = indice + 1
  return -1
\end{lstlisting}
\inputencoding{utf8} De cierta manera \texttt{buscar} es el opuesto del operador \texttt{{[}{]}}.
En vez de tomar un √≠ndice y extraer el car√°cter correspondiente, toma
un car√°cter y encuentra el √≠ndice donde √©ste se encuentra. Si no se
encuentra el car√°cter en la cadena, la funci√≥n retorna \texttt{-1}.

Este es el primer ejemplo de una sentencia \texttt{return} dentro
de un ciclo. Si se cumple que \texttt{cadena{[}indice{]} == c}, la
funci√≥n retorna inmediatamente, rompiendo el ciclo prematuramente.

Si el car√°cter no est√° en la cadena, el programa completa todo el
ciclo y retorna \texttt{-1}.

Este patr√≥n computacional se denomina recorrido ``eureka'', ya que
tan pronto encontremos lo que buscamos, gritamos ``Eureka!'' y dejamos
de buscar.

\section{Iterando y contando}

\label{counter} \index{contador} \index{patr√≥n}

El siguiente programa cuenta el n√∫mero de veces que la letra \texttt{a}
aparece en una cadena:\inputencoding{latin9}
\begin{lstlisting}
fruta = "banano"
cont = 0
for car in fruta:
  if car == 'a':
    cont = cont + 1
print(cont)
\end{lstlisting}
\inputencoding{utf8} Este programa demuestra otro patr√≥n computacional denominado \textbf{contador}.
La variable \texttt{cont} se inicializa a 0 y se incrementa cada vez
que se encuentre una \texttt{a}. ( \textbf{incrementar} es a√±adir
uno; es el opuesto de \textbf{decrementar}, y no tienen nada que ver
con ``excremento,'' que es un sustantivo.) Cuando el ciclo finaliza,
\texttt{cont} contiene el resultado‚Äîel n√∫mero total de \texttt{a}'s.

\section{Algunos m√©todos de las cadenas}

\index{cadenas!m√©todos} \index{m√©todo} \index{m√©todo!invocaci√≥n}
\index{m√©todos!cadenas} \index{m√©todos sobre cadenas} \index{invocar m√©todos}

Un \textbf{m√©todo} es similar a una funci√≥n, acepta par√°metros y devuelve
un valor, pero la sintaxis es diferente. Por ejemplo, las cadenas
tienen un m√©todo denominado \texttt{find} que hace lo mismo que buscar.
Para llamarlo tenemos que especificar la cadena, o la variable que
contiene la cadena, usando la notaci√≥n punto, en la que el m√©todo
se escribe despu√©s del punto. La llamada a un m√©todo tambi√©n se denomina
\textbf{invocaci√≥n}; en este caso, dir√≠amos que estamos invocando
\texttt{find} sobre la cadena \texttt{fruta}.

\inputencoding{latin9}\begin{lstlisting}
>>> fruta = "banano"
>>> ind = fruta.find("a")
>>> print(ind)
1
\end{lstlisting}
\inputencoding{utf8}
El m√©todo \texttt{find} es m√°s general que buscar, tambi√©n puede buscar
subcadenas, no solo caracteres:\inputencoding{latin9}
\begin{lstlisting}
>>> "banano".find("na")
2
\end{lstlisting}
\inputencoding{utf8}
Tambi√©n tiene un argumento adicional que especifica el √≠ndice desde
el que debe empezar la b√∫squeda:\inputencoding{latin9}
\begin{lstlisting}
>>> "banana".find("na",3) 
4
\end{lstlisting}
\inputencoding{utf8}
Igualmente, puede tomar dos argumentos adicionales que especifican
un rango de √≠ndices:\inputencoding{latin9}
\begin{lstlisting}
>>> "bob".find("b",1,2) 
-1
\end{lstlisting}
\inputencoding{utf8}
Aqu√≠ la b√∫squeda fall√≥ porque la letra {\em b} no est√° en en el
rango de √≠ndices de \texttt{1} a \texttt{2} (recuerde que no se incluye
el √∫ltimo √≠ndice, el \texttt{2}).

\section{El m√≥dulo \texttt{string y} clasificaci√≥n de caracteres}

\index{m√≥dulo} \index{m√≥dulo string}

\label{in} \index{clasificaci√≥n de caracteres} \index{clasificaci√≥n!de caracteres}
\index{may√∫sculas} \index{min√∫sculas} \index{espacios en blanco}

Con frecuencia es √∫til examinar un car√°cter y decidir si est√° en may√∫sculas
o en min√∫sculas, o si es un d√≠gito. El m√≥dulo \texttt{string} proporciona
varias constantes que sirven para lograr estos objetivos.

La cadena \texttt{string.lowercase} contiene todas las letras que
el sistema considera como min√∫sculas. Igualmente, \texttt{string.uppercase}
contiene todas las letras may√∫sculas. Intente lo siguiente y vea por
s√≠ mismo:\inputencoding{latin9}
\begin{lstlisting}
>>> import string
>>> print(string.ascii_lowercase)
>>> print(string.ascii_uppercase)
>>> print(string.digits)
\end{lstlisting}
\inputencoding{utf8}Podemos usar estas constantes y el m√©todo \texttt{find} para clasificar
los caracteres. Por ejemplo, si \texttt{c.find(lowercase)} retorna
un valor distinto de \texttt{-1}, entonces \texttt{c} debe ser una
letra min√∫scula:\inputencoding{latin9}
\begin{lstlisting}
import string

def esMinuscula(c):
  return string.ascii_lowercase.find(c) != -1
\end{lstlisting}
\inputencoding{utf8}
Otra alternativa la da el operador \texttt{in} que determina si un
car√°cter aparece en una cadena:\inputencoding{latin9}
\begin{lstlisting}
def esMinuscula(c):
  return c in string.ascii_lowercase
\end{lstlisting}
\inputencoding{utf8} Y otra alternativa m√°s, con el operador de comparaci√≥n:\inputencoding{latin9}
\begin{lstlisting}
def esMinuscula(c):
  return 'a' <= c <= 'z'
\end{lstlisting}
\inputencoding{utf8}
Si \texttt{c} est√° entre {\em a} y {\em z}, debe ser una letra
min√∫scula.

Otra constante definida en el m√≥dulo \texttt{string} puede sorprenderlo
cuando la imprima:\inputencoding{latin9}
\begin{lstlisting}
>>> print(string.whitespace)
\end{lstlisting}
\inputencoding{utf8}
Un car√°cter de los que pertenecen a \textbf{whitespace} mueve el cursor
sin imprimir nada. Crean un espacio en blanco que se puede evidenciar
entre caracteres. La constante \texttt{string.whitespace} contiene
todos los caracteres que representan espacios en blanco: espacio,
tab (\verb+\t+), y nueva l√≠nea (\verb+\n+).

\index{m√≥dulo string} \index{m√≥dulo!string}

Hay otras funciones √∫tiles en el m√≥dulo string, pero este libro no
es un manual de referencia. Para esto usted puede consultar la referencia
de las bibliotecas de Python ({\em Python Library Reference}).
Adem√°s, hay un gran c√∫mulo de documentaci√≥n en el sitio web de Python
\texttt{www.python.org}.

\index{Python Library Reference@{\em Python Library Reference}}

\section{Glosario}
\begin{description}
\item [{Tipo de dato compuesto:}] un tipo de dato en el que los valores
est√°n compuestos por componentes o elementos, que, a su vez, son valores.
\item [{Recorrido:}] iteraci√≥n sobre todos los elementos de un conjunto
ejecutando una operaci√≥n similar en cada uno.
\item [{√çndice:}] variable o valor que se usa para seleccionar un miembro
de un conjunto ordenado, tal como los caracteres de una cadena. Tambi√©n
se puede usar el t√©rmino \texttt{posici√≥n} como sin√≥nimo de √≠ndice.
\item [{Segmento:}] parte de una cadena, especificada por un rango de √≠ndices.
\item [{Mutable:}] un tipo de dato compuesto a cuyos elementos pueden asignarseles
nuevos valores.
\item [{Contador:}] una variable que se usa para contar algo, usualmente
se inicializa en cero y se incrementa posteriormente dentro de un
ciclo.
\item [{Incrementar:}] agregar uno al valor de una variable
\item [{Decrementar:}] restar uno al valor de una variable
\item [{Espacio en blanco:}] cualquiera de los caracteres que mueven el
cursor sin imprimir nada visible. La constante \texttt{string.whitespace}
contiene todos los caracteres que representan espacios en blanco.

\index{tipo de dato compuesto} \index{recorrido} \index{√≠ndice}
\index{segmento} \index{mutable} \index{contador} \index{incrementar}
\index{decrementar} \index{espacio en blanco}
\end{description}

\section{Ejercicios}

Para cada funci√≥n, agregue chequeo de tipos y pruebas unitarias.
\begin{enumerate}
\item Escriba una funci√≥n que tome una cadena como argumento y despliegue
las letras al rev√©s, una por cada l√≠nea.
\item Modifique el programa de la secci√≥n \ref{for} para corregir el error
con los patos Ouack y Quack.
\item Modifique la funci√≥n \texttt{buscar} de forma que reciba un tercer
par√°metro, el √≠ndice en la cadena donde debe empezar a buscar.
\item Encapsule el c√≥digo de la secci√≥n \ref{counter} en una funci√≥n llamada
\texttt{contarLetras}, y general√≠cela de forma que reciba la cadena
y la letra como par√°metros.
\item Reescriba la funci√≥n que obtuvo en el punto anterior de forma que
en lugar de recorrer la cadena, llame a la funci√≥n \texttt{buscar}
que recibe tres par√°metros.
\item Discuta qu√© versi√≥n de \texttt{esMinuscula} cree que es la m√°s r√°pida.
¬øPuede pensar en otra raz√≥n distinta de la velocidad para preferir
alguna de ellas sobre las otras?
\item Cree un archivo llamado \verb+cadenas.py+ y escriba lo siguiente
en √©l:

\inputencoding{latin9}\begin{lstlisting}
  def invertir(s):
    """
      >>> invertir('feliz')
      'zilef'
      >>> invertir('Python')
      'nohtyP'
      >>> invertir("")
      ''
      >>> invertir("P")
      'P'
    """

  if __name__ == '__main__':
    import doctest
    doctest.testmod()
\end{lstlisting}
\inputencoding{utf8} Agregue un cuerpo a la funci√≥n invertir que haga que pase las pruebas
unitarias.

Agregue al archivo \verb+cadenas.py+ cuerpos a cada una de las siguientes
funciones, una a la vez.
\item Reflejar:\inputencoding{latin9}
\begin{lstlisting}
  def reflejar(s):
    """
      >>> reflejar("bien")
      'bienneib'
      >>> reflejar("sÌ")
      'sÌÌs'
      >>> reflejar('Python')
      'PythonnohtyP'
      >>> reflejar("")
      ''
      >>> reflejar("a")
      'aa'
    """
\end{lstlisting}
\inputencoding{utf8}\item Eliminar letra:\inputencoding{latin9}
\begin{lstlisting}
  def elimina_letra(letra, cadena):
    """
      >>> elimina_letra('a', 'manzana')
      'mnzn'
      >>> elimina_letra('a', 'banana')
      'bnn'
      >>> elimina_letra('z', 'banana')
      'banana'
      >>> elimina_letra('i', 'Mississippi')
      'Msssspp'
    """
\end{lstlisting}
\inputencoding{utf8}\item Es pal√≠ndromo:\inputencoding{latin9}
\begin{lstlisting}
  def es_palindromo(s):
    """
      >>> es_palindromo('abba')
      True
      >>> es_palindromo('abab')
      False
      >>> es_palindromo('tenet')
      True
      >>> es_palindromo('banana')
      False
      >>> es_palindromo('zorra arroz')
      True
    """
\end{lstlisting}
\inputencoding{utf8}\item Cuenta el n√∫mero de ocurrencias:\inputencoding{latin9}
\begin{lstlisting}
  def cuenta(sub, s):
    """
      >>> cuenta('is', 'Mississippi')
      2
      >>> cuenta('an', 'banana')
      2
      >>> cuenta('ana', 'banana')
      2
      >>> cuenta('nana', 'banana')
      1
      >>> cuenta('nanan', 'banana')
      0
    """
\end{lstlisting}
\inputencoding{utf8}\item Eliminar la primera ocurrencia: \inputencoding{latin9}
\begin{lstlisting}
  def elimina(sub, s):
    """
      >>> elimina('an', 'banana')
      'bana'
      >>> elimina('cic', 'bicicleta')
      'bileta'
      >>> elimina('iss', 'Mississippi')
      'Missippi'
      >>> elimina('huevo', 'bicicleta')
      'bicicleta'
    """
\end{lstlisting}
\inputencoding{utf8}\item Eliminar todas las ocurrencias:\inputencoding{latin9}
\begin{lstlisting}
  def elimina_todo(sub, s):
    """
      >>> elimina_todo('an', 'banana')
      'ba'
      >>> elimina_todo('cic', 'bicicleta')
      'bileta'
      >>> elimina_todo('iss', 'Mississippi')
      'Mippi'
      >>> elimina_todo('huevos', 'bicicleta')
      'bicicleta'
    """
\end{lstlisting}
\inputencoding{utf8}\end{enumerate}

