%% LyX 2.2.3 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[oneside]{book}
\usepackage[utf8]{inputenc}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage{listings}
\renewcommand{\lstlistingname}{\inputencoding{latin9}Listado de cdigo}

\begin{document}

\chapter{Clases y funciones}

\label{time} \index{funci贸n} \index{m茅todo}

\section{Hora}

Como otro ejemplo de tipo de dato definido por el usuario definiremos
una clase llamada \texttt{Hora}:\inputencoding{latin9}
\begin{lstlisting}
class Hora:
  pass
\end{lstlisting}
\inputencoding{utf8}
Ahora podemos crear un nuevo objeto \texttt{Hora} y asignarle atributos
para las horas, minutos y segundos:\inputencoding{latin9}
\begin{lstlisting}
tiempo = Hora()
tiempo.hora = 11
tiempo.minutos = 59
tiempo.segundos = 30
\end{lstlisting}
\inputencoding{utf8}
El diagrama para el objeto \texttt{Hora} luce as铆:

\beforefig \centerline{\includegraphics{illustrations/time}} \afterfig

\section{Funciones puras}

\index{funci贸n pura} \index{tipo funci贸n!pura}

En las siguientes secciones escribiremos dos versiones de una funci贸n
denominada \texttt{sumarHoras}, que calcule la suma de dos \texttt{Horas}.
Esto demostrar谩 dos clases de funciones: las puras y los modificadores.

La siguiente es una versi贸n de \texttt{sumarHoras}:

\inputencoding{latin9}\begin{lstlisting}
def sumarHoras(t1, t2):
  sum = Hora()
  sum.hora = t1.hora + t2.hora
  sum.minutos = t1.minutos + t2.minutos
  sum.segundos = t1.segundos + t2.segundos
  return sum
\end{lstlisting}
\inputencoding{utf8} La funci贸n crea un nuevo objeto \texttt{Hora}, inicializa sus atributos
y retorna una referencia hacia el nuevo objeto. Esto se denomina \textbf{funci贸n
pura}, porque no modifica ninguno de los objetos que se le pasaron
como par谩metro ni tiene efectos laterales, como desplegar un valor
o leer entrada del usuario.

Aqu铆 hay un ejemplo de uso de esta funci贸n. Crearemos dos objetos
\texttt{Hora}: \texttt{horaPan}, que contiene el tiempo que le toma
a un panadero hacer pan y \texttt{horaActual}, que contiene la hora
actual. Luego usaremos \texttt{sumarHoras} para averiguar a qu茅 hora
estar谩 listo el pan. Si no ha terminado la funci贸n \texttt{imprimirHora}
a煤n, adel谩ntese a la Secci贸n \ref{printTime} antes de intentar esto:

\inputencoding{latin9}\begin{lstlisting}
>>> horaActual = Hora()
>>> horaActual.hora = 9
>>> horaActual.minutos = 14
>>> horaActual.segundos =  30

>>> horaPan = Hora()
>>> horaPan.hora =  3
>>> horaPan.minutos =  35
>>> horaPan.segundos =  0

>>> horaComer = sumarHoras(horaActual, horaPan)
>>> imprimirHora(horaComer)
\end{lstlisting}
\inputencoding{utf8} La salida de este programa es \texttt{12:49:30}, que est谩 correcta.
Por otro lado, hay casos en los que no funciona bien. 驴Puede pensar
en uno?

El problema radica en que esta funci贸n no considera los casos donde
el n煤mero de segundos o minutos suman m谩s de sesenta. Cuando eso ocurre
tenemos que ``acarrear'' los segundos extra a la columna de minutos.
Tambi茅n puede pasar lo mismo con los minutos.

Aqu铆 hay una versi贸n correcta:\inputencoding{latin9}
\begin{lstlisting}
def sumarHoras(t1, t2):
  sum = Hora()
  sum.hora = t1.hora + t2.hora
  sum.minutos = t1.minutos + t2.minutos
  sum.segundos = t1.segundos + t2.segundos

  if sum.segundos >= 60:
    sum.segundos = sum.segundos - 60
    sum.minutos = sum.minutos + 1

  if sum.minutos >= 60:
    sum.minutos = sum.minutos - 60
    sum.hora = sum.hora + 1

  return sum
\end{lstlisting}
\inputencoding{utf8}
Aunque ahora ha quedado correcta, ha empezado a agrandarse. M谩s adelante
sugeriremos un enfoque alternativo que produce un c贸digo m谩s corto.

\section{Modificadoras}

\label{increment} \index{modificadora} \index{tipo funci贸n!modificadora}

A veces es deseable que una funci贸n modifique uno o varios de los
objetos que recibe como par谩metros. Usualmente, el c贸digo que hace
el llamado a la funci贸n conserva una referencia a los objetos que
est谩 pasando, as铆 que cualquier cambio que la funci贸n les haga ser谩
evidenciado por dicho c贸digo. Este tipo de funciones se denominan
\textbf{modificadoras}.

\texttt{incrementar}, que agrega un n煤mero de segundos a un objeto
\texttt{Hora}, se escribir铆a m谩s naturalmente como funci贸n modificadora.
Un primer acercamiento a la funci贸n lucir铆a as铆:\inputencoding{latin9}
\begin{lstlisting}
def incrementar(h, segundos):
  h.segundos = h.segundos + segundos

  if h.segundos >= 60:
    h.segundos = h.segundos - 60
    h.minutos = h.minutos + 1

  if h.minuto >= 60:
    h.minutos = h.minutos - 60
    h.hora = h.hora + 1

  return h
\end{lstlisting}
\inputencoding{utf8}
La primera l铆nea ejecuta la operaci贸n b谩sica, las siguientes consideran
los casos especiales que ya hab铆amos visto.

驴Es correcta esta funci贸n? 驴Que pasa si el par谩metro \texttt{segundos}
es mucho m谩s grande que sesenta? En ese caso, no s贸lo es suficiente
a帽adir uno, tenemos que sumar de uno en uno hasta que \texttt{segundos}
sea menor que sesenta. Una soluci贸n consiste en reemplazar las sentencias
\texttt{if} por sentencias \texttt{while}:\inputencoding{latin9}
\begin{lstlisting}
def incrementar(hora, segundos):
  hora.segundos = hora.segundos + segundos

  while hora.segundos >= 60:
    hora.segundos = hora.segundos - 60
    hora.minutos = hora.minutos + 1

  while hora.minutos >= 60:
    hora.minutos = hora.minutos - 60
    hora.hora = hora.hora + 1

  return hora

  time.segundos = time.segundos + segundos
\end{lstlisting}
\inputencoding{utf8}
Ahora, la funci贸n s铆 es correcta, aunque no sigue el proceso m谩s eficiente.

\section{驴Cual es el mejor estilo?}

\index{estilo de programaci贸n funcional}

Todo lo que puede hacerse con modificadoras tambi茅n se puede hacer
con funciones puras. De hecho, algunos lenguajes de programaci贸n s贸lo
permiten funciones puras. La evidencia apoya la tesis de que los programas
que usan solamente funciones puras se desarrollan m谩s r谩pido y son
menos propensos a errores que los programas que usan modificadoras.
Sin embargo, las funciones modificadoras, a menudo, son convenientes
y, a menudo, los programas funcionales puros son menos eficientes.

En general, le recomendamos que escriba funciones puras cada vez que
sea posible y recurrir a las modificadoras solamente si hay una ventaja
en usar este enfoque. Esto se denomina un \textbf{estilo de programaci贸n
funcional}.

\section{Desarrollo con prototipos vs. planificaci贸n}

\label{convert} \index{desarrollo con prototipos}

En este cap铆tulo mostramos un enfoque de desarrollo de programas que
denominamos \textbf{desarrollo con prototipos}. Para cada problema
escribimos un bosquejo (o prototipo) que ejecutar谩 el c谩lculo b谩sico
y lo probar谩 en unos cuantos casos de prueba, corrigiendo errores
a medida que surgen.

Aunque este enfoque puede ser efectivo, puede conducirnos a c贸digo
innecesariamente complicado ya que considera muchos casos especialesy
poco confiableya que es dif铆cil asegurar que hemos descubierto todos
los errores.

Una alternativa es el \textbf{desarrollo planificado}, en el que la
profundizaci贸n en el dominio del problema puede darnos una comprensi贸n
profunda que facilita bastante la programaci贸n. En el caso anterior,
comprendimos que un objeto \texttt{Hora} realmente es un n煤mero de
tres d铆gitos en base 60! El componente \texttt{segundos} contiene
las ``unidades,'' el componente \texttt{minutos} la ``columna de
sesentas,'' y el componente \texttt{hora} contiene la ``columna
de tres mil seiscientos.''

Cuando escribimos \texttt{sumarHoras} e \texttt{incrementar}, realmente
est谩bamos haciendo una suma en base 60, raz贸n por la cual ten铆amos
que efectuar un acarreo de una columna a la siguiente.

Esta observaci贸n sugiere otro enfoque al problemapodemos convertir
un objeto \texttt{Hora} en un n煤mero 煤nico y aprovecharnos del hecho
de que el computador sabe realizar aritm茅tica. La siguiente funci贸n
convierte un objeto \texttt{Hora} en un entero:\inputencoding{latin9}
\begin{lstlisting}
def convertirASegundos(t):
  minutos = t.hora * 60 + t.minutos
  segundos = minutos * 60 + t.segundos
  return segundos
\end{lstlisting}
\inputencoding{utf8}
Ahora necesitamos una forma de convertir desde entero a un objeto
\texttt{Hora}:\inputencoding{latin9}
\begin{lstlisting}
def crearHora(segundos):
  h = Hora()
  h.hora = segundos/3600
  segundos = segundos - h.hora * 3600
  h.minutos = segundos/60
  segundos = segundos - h.minutos * 60
  h.segundos = segundos
  return h
\end{lstlisting}
\inputencoding{utf8}
Usted debe pensar unos minutos para convencerse de que esta t茅cnica
s铆 convierte, de una base a otra, correctamente. Asumiendo que ya
est谩 convencido, se pueden usar las funciones anteriores para reescribir
\texttt{sumarHoras}:

\inputencoding{latin9}\begin{lstlisting}
def sumarHoras(t1, t2):
  segundos = convertirASegundos(t1) + convertirASegundos(t2)
  return crearHora(segundos)
\end{lstlisting}
\inputencoding{utf8} Esta versi贸n es mucho m谩s corta que la original, y es mucho m谩s f谩cil
de demostrar que es correcta (asumiendo, como de costumbre, que las
funciones que llama son correctas).

\section{Generalizaci贸n}

\index{generalizaci贸n}

Desde cierto punto de vista, convertir de base 60 a base 10 y viceversa
es m谩s dif铆cil que calcular solamente con horas. La conversi贸n de
bases es m谩s abstracta, mientras que nuestra intuici贸n para manejar
horas est谩 m谩s desarrollada.

Pero si tenemos la intuici贸n de tratar las horas como n煤meros en base
60 y hacemos la inversi贸n de escribir las funciones de conversi贸n
(\texttt{convertirASegundos} y \texttt{crearHora}), obtenemos un programa
m谩s corto, legible, depurable y confiable.

Tambi茅n facilita la adici贸n de m谩s caracter铆sticas. Por ejemplo, piense
en el problema de restar dos \texttt{Hora}s para averiguar el tiempo
que transcurre entre ellas. La soluci贸n ingenua har铆a resta llevando
pr茅stamos. En cambio, usar las funciones de conversi贸n ser铆a mas f谩cil.

Ir贸nicamente, algunas veces el hacer de un problema algo m谩s dif铆cil
(o m谩s general) lo hace m谩s f谩cil (porque hay menos casos especiales
y menos oportunidades para caer en errores).

\section{Algoritmos}

\index{algoritmo}

Cuando usted escribe una soluci贸n general para una clase de problemas,
en vez de encontrar una soluci贸n espec铆fica a un solo problema, ha
escrito un \textbf{algoritmo}. Mencionamos esta palabra antes, pero
no la definimos cuidadosamente. No es f谩cil de definir, as铆 que intentaremos
dos enfoques.

Primero, considere algo que no es un algoritmo. Cuando usted aprendi贸
a multiplicar d铆gitos, probablemente memoriz贸 la tabla de multiplicaci贸n.
De hecho, usted memoriz贸 100 soluciones espec铆ficas. Este tipo de
conocimiento no es algor铆tmico.

Pero si usted fuera ``perezoso,'' probablemente aprendi贸 a hacer
trampa por medio de algunos trucos. Por ejemplo, para encontrar el
producto entre $n$ y 9, usted puede escribir $n-1$ como el primer
d铆gito y $10-n$ como el segundo. Este truco es una soluci贸n general
para multiplicar cualquier d铆gito por el 9. 隆Este es un algoritmo!

Similarmente, las t茅cnicas que aprendi贸 para hacer suma con acarreo
( llevando para la columna hacia la derecha), resta con pr茅stamos,
y divisi贸n larga, todas son algoritmos. Una de las caracter铆sticas
de los algoritmos es que no requieren inteligencia para ejecutarse.
Son procesos mec谩nicos en el que cada paso sigue al anterior de acuerdo
con un conjunto de reglas sencillas.

En nuestra opini贸n, es vergonzoso que los seres humanos pasemos tanto
tiempo en la escuela aprendiendo a ejecutar algoritmos que, literalmente,
no requieren inteligencia.

Por otro lado, el proceso de dise帽ar algoritmos es interesante, intelectualmente
desafiante y una parte central de lo que denominamos programaci贸n.

Algunas cosas que la gente hace naturalmente sin dificultad o pensamiento
consciente, son las mas dif铆ciles de expresar algor铆tmicamente. Entender
el lenguaje natural es una de ellas. Todos lo hacemos, pero hasta
ahora nadie ha sido capaz de explicar {\em como} lo hacemos, al
menos no con un algoritmo.

\section{Glosario}
\begin{description}
\item [{Funci贸n pura:}] funci贸n que no modifica ninguno de los objetos
que recibe como par谩metros. La mayor铆a de las funciones puras son
fruct铆feras.
\item [{Modificadora:}] funci贸n que cambia uno o varios de los objetos
que recibe como par谩metros. La mayor铆a de los modificadoras no retornan
nada.
\item [{Estilo de programaci贸n funcional}] estilo de dise帽o de programas
en el que la mayor铆a de funciones son puras.
\item [{Desarrollo con prototipos:}] es la forma de desarrollar programas
empezando con un prototipo que empieza a mejorarse y probarse gradualmente.
\item [{Desarrollo planeado:}] es la forma de desarrollar programas que
implica un conocimiento de alto nivel sobre el problema y mas planeaci贸n
que el desarrollo incremental o el desarrollo con prototipos.
\item [{Algoritmo:}] conjunto de instrucciones para resolver una clase
de problemas por medio de un proceso mec谩nico, no inteligente.

\index{funci贸n pura} \index{modificadora} \index{estilo de programaci贸n funcional}
\index{desarrollo incremental} \index{desarrollo!incremental} \index{desarrollo planeado}
\index{desarrollo!planeado} \index{algoritmo}
\end{description}

\section{Ejercicios}
\begin{enumerate}
\item Reescriba la funci贸n \texttt{incrementar} de forma que no contenga
ciclos y siga siendo correcta.
\item Reescriba \texttt{incrementar} usando convertirASegundos y crearHora.
\item Reescriba \texttt{incrementar} como una funci贸n pura, y escriba llamados
a funciones de las dos versiones.
\item Escriba una funci贸n \texttt{imprimirHora} que reciba un objeto \texttt{Hora}
como argumento y lo imprima de la forma \texttt{horas:minutos:segundos}.
\item Escriba una funci贸n booleana \texttt{despues} que reciba dos objetos
\texttt{Hora}, \texttt{t1} y \texttt{t2} como argumentos, y retorne
cierto si \texttt{t1} va despu茅s de \texttt{t2} cronol贸gicamente y
falso en caso contrario.
\end{enumerate}

\end{document}
