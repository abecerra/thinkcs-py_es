
\chapter{Archivos y excepciones}

\index{archivos}

Cuando un programa se est√° ejecutando, sus datos est√°n en la memoria.
Cuando un programa termina, o se apaga el computador, los datos de
la memoria desaparecen. Para almacenar los datos de forma permanente
se deben poner en un \textbf{archivo}. Normalmente los archivos se
guardan en un disco duro, disquete o CD-ROM.

Cuando hay un gran n√∫mero de archivos, suelen estar organizados en
\textbf{directorios} (tambi√©n llamados ``carpetas''). Cada archivo
se identifica con un nombre √∫nico, o una combinaci√≥n de nombre de
archivo y nombre de directorio.

Leyendo y escribiendo archivos, los programas pueden intercambiar
informaci√≥n entre ellos y generar formatos imprimibles como PDF.

Trabajar con archivos se parece mucho a hacerlo con libros. Para usar
un libro, hay que abrirlo. Cuando uno ha terminado, hay que cerrarlo.
Mientras el libro est√° abierto, se puede escribir en √©l o leer de
√©l. En cualquier caso, uno sabe en qu√© lugar del libro se encuentra.
Casi siempre se lee un libro seg√∫n su orden natural, pero tambi√©n
se puede ir saltando de p√°gina en p√°gina.

Todo esto sirve tambi√©n para los archivos. Para abrir un archivo,
se especifica su nombre y se indica si se desea leer o escribir.

La apertura de un archivo crea un objeto archivo. En este ejemplo,
la variable \texttt{f} apunta al nuevo objeto archivo.\inputencoding{latin9}
\begin{lstlisting}
>>> f = open("test.dat","w")
>>> print(f)
<open file 'test.dat', mode 'w' at fe820>
\end{lstlisting}
\inputencoding{utf8}
La funci√≥n open toma dos argumentos: el primero, es el nombre del
archivo y el segundo, el modo. El modo {\verb+"w"+} significa que
lo estamos abriendo para escribir.

Si no hay un archivo llamado \texttt{test.dat} se crear√°. Si ya hay
uno, el archivo que estamos escribiendo lo reemplazar√°.

Al imprimir el objeto archivo, vemos el nombre del archivo, el modo
y la localizaci√≥n del objeto.

Para escribir datos en el archivo invocamos al m√©todo \texttt{write}
sobre el objeto archivo:\inputencoding{latin9}
\begin{lstlisting}
>>> f.write("Ya es hora")
>>> f.write("de cerrar el archivo")
\end{lstlisting}
\inputencoding{utf8}
El cierre del archivo le dice al sistema que hemos terminado de escribir
y deja el archivo listo para leer:\inputencoding{latin9}
\begin{lstlisting}
>>> f.close()
\end{lstlisting}
\inputencoding{utf8}
Ya podemos abrir el archivo de nuevo, esta vez para lectura, y poner
su contenido en una cadena. Esta vez el argumento de modo es {\verb+"r"+},
para lectura:\inputencoding{latin9}
\begin{lstlisting}
>>> f = open("test.dat","r")
\end{lstlisting}
\inputencoding{utf8}
Si intentamos abrir un archivo que no existe, recibimos un mensaje
de error:

\index{error en tiempo de ejecuci√≥n}\inputencoding{latin9}
\begin{lstlisting}
>>> f = open("test.cat","r")
IOError: [Errno 2] No such file or directory: 'test.cat'
\end{lstlisting}
\inputencoding{utf8}
Como era de esperar, el m√©todo \texttt{read} lee datos del archivo.
Sin argumentos, lee el archivo completo:\inputencoding{latin9}
\begin{lstlisting}
>>> texto = f.read()
>>> print(texto)
Ya es horade cerrar el archivo
\end{lstlisting}
\inputencoding{utf8}
No hay un espacio entre ``hora'' y ``de'' porque no escribimos
un espacio entre las cadenas. \texttt{read} tambi√©n puede aceptar
un argumento que le indica cu√°ntos caracteres leer:\inputencoding{latin9}
\begin{lstlisting}
>>> f = open("test.dat","r")
>>> print(f.read(7))
Ya es h
\end{lstlisting}
\inputencoding{utf8}
Si no quedan suficientes caracteres en el archivo, \texttt{read} devuelve
los que haya. Cuando llegamos al final del archivo, \texttt{read}
devuelve una cadena vac√≠a:\inputencoding{latin9}
\begin{lstlisting}
>>> print(f.read(1000006))
orade cerrar el archivo
>>> print(f.read())

>>>
\end{lstlisting}
\inputencoding{utf8}
La siguiente funci√≥n copia un archivo, leyendo y escribiendo los caracteres
de cincuenta en cincuenta. El primer argumento es el nombre del archivo
original; el segundo es el nombre del archivo nuevo:\inputencoding{latin9}
\begin{lstlisting}
def copiaArchivo(archViejo, archNuevo):
  f1 = open(archViejo, "r")
  f2 = open(archNuevo, "w")
  while True:
    texto = f1.read(50)
    if texto == "":
      break
    f2.write(texto)
  f1.close()
  f2.close()
  return
\end{lstlisting}
\inputencoding{utf8}
La sentencia \texttt{break} es nueva. Su ejecuci√≥n interrumpe el ciclo;
el flujo de la ejecuci√≥n pasa a la primera sentencia despu√©s del while.

\index{sentencia break} \index{sentencia!break}

En este ejemplo, el ciclo \texttt{while} es infinito porque la condici√≥n
\texttt{True} siempre es verdadera. La {\em √∫nica} forma de salir
del ciclo es ejecutar \texttt{break}, lo que sucede cuando \texttt{texto}
es una cadena vac√≠a, y esto pasa cuando llegamos al final del archivo.

\section{Archivos de texto}

\index{archivo de texto} \index{archivo!texto}

Un \textbf{archivo de texto} contiene caracteres imprimibles y espacios
organizados en l√≠neas separadas por caracteres de salto de l√≠nea.
Como Python est√° dise√±ado espec√≠ficamente para procesar archivos de
texto, proporciona m√©todos que facilitan esta tarea.

Para hacer una demostraci√≥n, crearemos un archivo de texto con tres
l√≠neas de texto separadas por saltos de l√≠nea:\inputencoding{latin9}
\begin{lstlisting}
>>> f = open("test.dat","w")
>>> f.write("lÌnea uno\nlÌnea dos\nlÌnea tres\n")
>>> f.close()
\end{lstlisting}
\inputencoding{utf8}
El m√©todo \texttt{readline} lee todos los caracteres hasta, e incluyendo,
el siguiente salto de l√≠nea:\inputencoding{latin9}
\begin{lstlisting}
>>> f = open("test.dat","r")
>>> print(f.readline())
lÌnea uno

>>>
\end{lstlisting}
\inputencoding{utf8}
\texttt{readlines} devuelve todas las l√≠neas que queden como una lista
de cadenas:\inputencoding{latin9}
\begin{lstlisting}
>>> print(f.readlines())
['lÌnea dos\012', 'lÌnea tres\012']
\end{lstlisting}
\inputencoding{utf8}
En este caso, la salida est√° en forma de lista, lo que significa que
las cadenas aparecen con comillas y el car√°cter de salto de l√≠nea
aparece como la secuencia de escape \texttt{012}.

Al final del archivo, \texttt{readline} devuelve una cadena vac√≠a
y \texttt{readlines} devuelve una lista vac√≠a:\inputencoding{latin9}
\begin{lstlisting}
>>> print(f.readline())

>>> print(f.readlines())
[]
\end{lstlisting}
\inputencoding{utf8}
Lo que sigue es un ejemplo de un programa de proceso de l√≠neas. \texttt{filtraArchivo}
hace una copia de \texttt{archViejo}, omitiendo las l√≠neas que comienzan
por \texttt{\#}:\inputencoding{latin9}
\begin{lstlisting}
def filtraArchivo(archViejo, archNuevo):
  f1 = open(archViejo, "r")
  f2 = open(archNuevo, "w")
  while 1:
    texto = f1.readline()
    if texto == "":
      break
    if texto[0] == '#':
      continue
    f2.write(texto)
  f1.close()
  f2.close()
  return
\end{lstlisting}
\inputencoding{utf8}
La sentencia \texttt{continue} termina la iteraci√≥n actual del ciclo,
pero sigue haciendo las que le faltan. El flujo de ejecuci√≥n pasa
al principio del ciclo, comprueba la condici√≥n y contin√∫a normalmente.

\index{sentencia continue} \index{sentencia!continue}

As√≠, si \texttt{texto} es una cadena vac√≠a, el ciclo termina. Si el
primer car√°cter de \texttt{texto} es una almohadilla \texttt{(\#)},
el flujo de ejecuci√≥n va al principio del ciclo. S√≥lo si ambas condiciones
fallan copiamos \texttt{texto} en el archivo nuevo.

\section{Escribir variables}

\index{operador de formato} \index{cadena de formato} \index{operador!formato}

El argumento de \texttt{write} debe ser una cadena, as√≠ que si queremos
poner otros valores en un archivo, tenemos que convertirlos previamente
en cadenas. La forma m√°s f√°cil de hacerlo es con la funci√≥n \texttt{str}:\inputencoding{latin9}
\begin{lstlisting}
>>> x = 52
>>> f.write (str(x))
\end{lstlisting}
\inputencoding{utf8}
Una alternativa es usar el \textbf{operador de formato} \texttt{\%}.
Cuando aplica a enteros, \texttt{\%} es el operador de m√≥dulo. Pero
cuando el primer operando es una cadena, \texttt{\%} es el operador
de formato.

El primer operando es la \textbf{cadena de formato}, y el segundo,
una tupla de expresiones. El resultado es una cadena que contiene
los valores de las expresiones, formateados de acuerdo con la cadena
de formato.

A modo de ejemplo simple, la \textbf{secuencia de formato} {\verb+"%d"+}
significa que la primera expresi√≥n de la tupla deber√≠a formatearse
como un entero. Aqu√≠ la letra {\em d} quiere decir ``decimal'':\inputencoding{latin9}
\begin{lstlisting}
>>> motos = 52
>>> "%d" % motos
'52'
\end{lstlisting}
\inputencoding{utf8}
El resultado es la cadena \texttt{'52'}, que no debe confundirse con
el valor entero \texttt{52}.

Una secuencia de formato puede aparecer en cualquier lugar de la cadena
de formato, de modo que podemos incrustar un valor en una frase:\inputencoding{latin9}
\begin{lstlisting}
>>> motos = 52
>>> "En julio vendimos %d motos." % motos
'En julio vendimos 52 motos.'
\end{lstlisting}
\inputencoding{utf8}
La secuencia de formato {\verb+"%f"+} formatea el siguiente elemento
de la tupla como un n√∫mero en punto flotante, y {\verb+"%s"+} formatea
el siguiente elemento como una cadena:\inputencoding{latin9}
\begin{lstlisting}
>>> "En %d dias ganamos %f millones de %s." % (4,1.2,'pesos')
'En 4 dias ganamos 1.200000 millones de pesos.'
\end{lstlisting}
\inputencoding{utf8}
Por defecto, el formato de punto flotante imprime seis decimales.

El n√∫mero de expresiones en la tupla tiene que coincidir con el n√∫mero
de secuencias de formato de la cadena. Igualmente, los tipos de las
expresiones deben coincidir con las secuencias de formato:

\index{error en tiempo de ejecuci√≥n}\inputencoding{latin9}
\begin{lstlisting}
>>> "%d %d %d" % (1,2)
TypeError: not enough arguments for format string
>>> "%d" % 'dolares'
TypeError: illegal argument type for built-in operation
\end{lstlisting}
\inputencoding{utf8}
En el primer ejemplo no hay suficientes expresiones; en el segundo,
la expresi√≥n es de un tipo incorrecto.

Para tener m√°s control sobre el formato de los n√∫meros, podemos detallar
el n√∫mero de d√≠gitos como parte de la secuencia de formato:\inputencoding{latin9}
\begin{lstlisting}
>>> "%6d" % 62
'    62'
>>> "%12f" % 6.1
'    6.100000'
\end{lstlisting}
\inputencoding{utf8}
El n√∫mero tras el signo de porcentaje es el n√∫mero m√≠nimo de espacios
que ocupar√° el n√∫mero. Si el valor necesita menos d√≠gitos, se a√±aden
espacios en blanco delante del n√∫mero. Si el n√∫mero de espacios es
negativo, se a√±aden los espacios tras el n√∫mero:\inputencoding{latin9}
\begin{lstlisting}
>>> "%-6d" % 62
'62    '
\end{lstlisting}
\inputencoding{utf8}
Tambi√©n podemos especificar el n√∫mero de decimales para los n√∫meros
en coma flotante:\inputencoding{latin9}
\begin{lstlisting}
>>> "%12.2f" % 6.1
'        6.10'
\end{lstlisting}
\inputencoding{utf8}
En este ejemplo, el resultado ocupa doce espacios e incluye dos d√≠gitos
tras la coma. Este formato es √∫til para imprimir cantidades de dinero
con las comas alineadas.

\index{diccionario}

Imagine, por ejemplo, un diccionario que contiene los nombres de los
estudiantes como clave y las tarifas horarias como valores. He aqu√≠
una funci√≥n que imprime el contenido del diccionario como de un informe
formateado:\inputencoding{latin9}
\begin{lstlisting}
def informe (tarifas) :
  estudiantes = tarifas.keys()
  estudiantes.sort()
  for estudiante in estudiantes :
    print("%-20s %12.02f"%(estudiante, tarifas[estudiante]))
\end{lstlisting}
\inputencoding{utf8}
Para probar la funci√≥n, crearemos un peque√±o diccionario e imprimiremos
el contenido:\inputencoding{latin9}
\begin{lstlisting}
>>> tarifas = {'maria': 6.23, 'jose': 5.45, 'jesus': 4.25}
>>> informe (tarifas)
jose                         5.45
jesus                        4.25
maria                        6.23
\end{lstlisting}
\inputencoding{utf8}
Controlando el ancho de cada valor nos aseguramos de que las columnas
van a quedar alineadas, siempre que los nombre tengan menos de veinti√∫n
caracteres y las tarifas sean menos de mil millones la hora.

\section{Directorios}

\index{directorio}

Cuando se crea un archivo nuevo abri√©ndolo y escribiendo, este va
a quedar en el directorio en uso (aqu√©l en el que se estuviese al
ejecutar el programa). Del mismo modo, cuando se abre un archivo para
leerlo, Python lo busca en el directorio en uso.

Si usted quiere abrir un archivo de cualquier otro sitio, tiene que
especificar la \textbf{ruta} del archivo, que es el nombre del directorio
(o carpeta) donde se encuentra este:\inputencoding{latin9}
\begin{lstlisting}
>>>   f = open("/usr/share/dict/words","r")
>>>   print(f.readline())
Aarhus
\end{lstlisting}
\inputencoding{utf8}
Este ejemplo abre un archivo denominado \texttt{words}, que se encuentra
en un directorio llamado \texttt{dict}, que est√° en \texttt{share},
en en \texttt{usr}, que est√° en el directorio de nivel superior del
sistema, llamado \texttt{/}.

\index{ruta} \index{delimitador}

No se puede usar \texttt{/} como parte del nombre de un archivo; est√°
reservado como delimitador entre nombres de archivo y directorios.

El archivo \texttt{/usr/share/dict/words} contiene una lista de palabras
en orden alfab√©tico, la primera de las cuales es el nombre de una
universidad danesa.

\section{Encurtido}

\index{encurtido}

Para poner valores en un archivo, se deben convertir a cadenas. Usted
ya ha visto c√≥mo hacerlo con \texttt{str}:\inputencoding{latin9}
\begin{lstlisting}
>>> f.write (str(12.3))
>>> f.write (str([1,2,3]))
\end{lstlisting}
\inputencoding{utf8} El problema es que cuando se vuelve a leer el valor, se obtiene una
cadena. Se ha perdido la informaci√≥n del tipo de dato original. En
realidad, no se puede distinguir d√≥nde termina un valor y d√≥nde comienza
el siguiente:

\inputencoding{latin9}\begin{lstlisting}
>>>   f.readline()
'12.3[1, 2, 3]'
\end{lstlisting}
\inputencoding{utf8} La soluci√≥n es el \textbf{encurtido}, llamado as√≠ porque ``encurte''
estructuras de datos. El m√≥dulo \texttt{pickle} contiene las √≥rdenes
necesarias. Para usarlo, se importa \texttt{pickle} y luego se abre
el archivo de la forma habitual:\inputencoding{latin9}
\begin{lstlisting}
>>> import pickle
>>> f = open("test.pck","w")
\end{lstlisting}
\inputencoding{utf8}
Para almacenar una estructura de datos, se usa el m√©todo \texttt{dump}
y luego se cierra el archivo de la forma habitual:\inputencoding{latin9}
\begin{lstlisting}
>>> pickle.dump(12.3, f)
>>> pickle.dump([1,2,3], f)
>>> f.close()
\end{lstlisting}
\inputencoding{utf8}
Ahora podemos abrir el archivo para leer y cargar las estructuras
de datos que volcamos ah√≠:

\inputencoding{latin9}\begin{lstlisting}
>>> f = open("test.pck","r")
>>> x = pickle.load(f)
>>> x
12.3
>>> type(x)
<type 'float'>
>>> y = pickle.load(f)
>>> y
[1, 2, 3]
>>> type(y)
<type 'list'>
\end{lstlisting}
\inputencoding{utf8} Cada vez que invocamos \texttt{load} obtenemos un valor del archivo
completo con su tipo original.

\section{Excepciones}

\index{sentencia try} \index{sentencia!try} \index{lanzar una excepci√≥n}
\index{manejar una excepci√≥n} \index{sentencia except} \index{sentencia!except}
\index{excepci√≥n}

Siempre que ocurre un error en tiempo de ejecuci√≥n, se crea una \textbf{excepci√≥n}.
Normalmente el programa se para y Python presenta un mensaje de error.

Por ejemplo, la divisi√≥n por cero crea una excepci√≥n:\inputencoding{latin9}
\begin{lstlisting}
>>> print(55/0)
ZeroDivisionError: integer division or modulo
\end{lstlisting}
\inputencoding{utf8}
Un elemento no existente en una lista hace lo mismo:\inputencoding{latin9}
\begin{lstlisting}
>>> a = []
>>> print(a[5])
IndexError: list index out of range
\end{lstlisting}
\inputencoding{utf8}
O el acceso a una clave que no est√° en el diccionario:\inputencoding{latin9}
\begin{lstlisting}
>>> b = {}
>>> print(b['quÈ'])
KeyError: quÈ
\end{lstlisting}
\inputencoding{utf8}
En cada caso, el mensaje de error tiene dos partes: el tipo de error
antes de los dos puntos y detalles sobre el error despu√©s de los dos
puntos. Normalmente, Python tambi√©n imprime una traza de d√≥nde se
encontraba el programa, pero la hemos omitido en los ejemplos.

\index{traza}

A veces queremos realizar una operaci√≥n que podr√≠a provocar una excepci√≥n,
pero no queremos que se pare el programa. Podemos \textbf{manejar}
la excepci√≥n usando las sentencias \texttt{try} y \texttt{except}.

Por ejemplo, podemos preguntar al usuario por el nombre de un archivo
y luego intentar abrirlo. Si el archivo no existe, no queremos que
el programa se aborte; queremos manejar la excepci√≥n.\inputencoding{latin9}
\begin{lstlisting}
nombreArch = raw_input('Introduce un nombre de archivo: ')
try:
  f = open (nombreArch, "r")
except:
  print('No hay ning˙n archivo que se llame', nombreArch)
\end{lstlisting}
\inputencoding{utf8}
La sentencia \texttt{try} ejecuta las sentencias del primer bloque.
Si no se produce ninguna excepci√≥n, pasa por alto la sentencia \texttt{except}.
Si ocurre cualquier excepci√≥n, ejecuta las sentencias de la rama \texttt{except}
y despu√©s contin√∫a.

Podemos encapsular esta capacidad en una funci√≥n: \texttt{existe},
que acepta un nombre de archivo y devuelve verdadero si el archivo
existe y falso si no:\inputencoding{latin9}
\begin{lstlisting}
def existe(nombreArch):
  try:
    f = open(nombreArch)
    f.close()
    return True
  except:
    return False
\end{lstlisting}
\inputencoding{utf8}Se pueden usar m√∫ltiples bloques \texttt{except} para manejar diferentes
tipos de excepciones. El {\em Manual de Referencia de Python} contiene
los detalles.

Si su programa detecta una condici√≥n de error, se puede lanzar (\textbf{raise}
en ingl√©s) una excepci√≥n. Aqu√≠ hay un ejemplo que acepta una entrada
del usuario y comprueba si es 17. Suponiendo que 17 no es una entrada
v√°lida por cualquier raz√≥n, lanzamos una excepci√≥n.\inputencoding{latin9}
\begin{lstlisting}
# -*- coding: utf-8 -*-
def tomaNumero () :                 
  x = input ('Elige un n˙mero: ')   
  if x == 17 :
    raise 'ErrorNumeroMalo', '17 es un mal n˙mero'
  return x
\end{lstlisting}
\inputencoding{utf8}
La sentencia \texttt{raise} acepta dos argumentos: el tipo de excepci√≥n
e informaci√≥n espec√≠fica acerca del error. \texttt{ErrorNumeroMalo}
es un nuevo tipo de excepci√≥n que hemos inventado para esta aplicaci√≥n.

Si la funci√≥n llamada \texttt{tomaNumero} maneja el error, el programa
puede continuar; en caso contrario, Python imprime el mensaje de error
y sale:\inputencoding{latin9}
\begin{lstlisting}
>>> tomaNumero ()
Elige un n˙mero: 17
ErrorNumeroMalo: 17 es un mal n˙mero
\end{lstlisting}
\inputencoding{utf8}
El mensaje de error incluye el tipo de excepci√≥n y la informaci√≥n
adicional proporcionada.

\section{Glosario}

\index{archivo} \index{archivo de texto} \index{sentencia break}
\index{sentencia!break} \index{sentencia continue} \index{sentencia!continue}
\index{operador de formato} \index{cadena de formato} \index{operador!formato}
\index{directorio} \index{encurtido} \index{try} \index{lanzar excepci√≥n}
\index{manejar excepci√≥n} \index{sentencia except} \index{excepci√≥n}
\begin{description}
\item [{Archivo:}] entidad con nombre, normalmente almacenada en un disco
duro, disquete o CD-ROM, que contiene una secuencia de caracteres.
\item [{Directorio:}] colecci√≥n de archivos, con nombre, tambi√©n llamado
carpeta.
\item [{Ruta:}] secuencia de nombres de directorio que especifica la localizaci√≥n
exacta de un archivo.
\item [{Archivo de texto:}] un archivo que contiene caracteres imprimibles
organizados en l√≠neas separadas por caracteres de salto de l√≠nea.
\item [{Sentencia break:}] es una sentencia que provoca que el flujo de
ejecuci√≥n salga de un ciclo.
\item [{Sentencia continue:}] sentencia que provoca que termine la iteraci√≥n
actual de un ciclo. El flujo de la ejecuci√≥n va al principio del ciclo,
eval√∫a la condici√≥n, y procede en consecuencia.
\item [{Operador de formato:}] el operador \texttt{\%} toma una cadena
de formato y una tupla de expresiones y entrega una cadena que incluye
las expresiones, formateadas de acuerdo con la cadena de formato.
\item [{Cadena de formato:}] una cadena que contiene caracteres imprimibles
y secuencias de formato que indican c√≥mo dar formato a valores.
\item [{Secuencia de formato:}] secuencia de caracteres que comienza con
\texttt{\%} e indica c√≥mo dar formato a un valor.
\item [{Encurtir:}] escribir el valor de un dato en un archivo junto con
la informaci√≥n sobre su tipo de forma que pueda ser reconstituido
m√°s tarde.
\item [{Excepci√≥n:}] error que ocurre en tiempo de ejecuci√≥n.
\item [{Manejar:}] impedir que una excepci√≥n detenga un programa utilizando
las sentencias \texttt{except} y \texttt{try}.
\item [{Lanzar:}] causar una excepci√≥n usando la sentencia \texttt{raise}.
\end{description}

\section{Ejercicios}

Para cada funci√≥n, agregue chequeo de tipos y pruebas unitarias.
\begin{enumerate}
\item Escriba una funci√≥n que use \texttt{tomaNumero} para leer un n√∫mero
del teclado y que maneje la excepci√≥n \texttt{ErrorNumeroMalo}
\item Escriba una funci√≥n que reciba el nombre de un archivo y averig√ºe
si contiene una cadena de ADN v√°lida. Es decir, cada car√°cter del
archivo es A,C,T, √≥ G.
\item Generalice la funci√≥n anterior para trabajar con cualquier biosecuencia
(ARN, ADN, prote√≠na).
\item Escriba una funci√≥n que permita escribir una matriz, implementada
como una lista de listas, en un archivo.
\item Escriba una funci√≥n que permita leer una matriz, implementada como
una lista de listas, de un archivo.
\item Escriba una funci√≥n que permita escribir una matriz dispersa, implementada
con un diccionario, en un archivo.
\item Escriba una funci√≥n que permita leer una matriz dispersa, implementada
con un diccionario, de un archivo.
\end{enumerate}

