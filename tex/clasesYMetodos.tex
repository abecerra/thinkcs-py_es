
\chapter{Clases y m√©todos}

\section{Caracter√≠sticas de orientaci√≥n a objetos}

\index{lenguaje de programaci√≥n orientado a objetos} \index{programaci√≥n orientada a objetos}

Python es un \textbf{lenguaje de programaci√≥n orientado a objetos},
lo que quiere decir que proporciona caracter√≠sticas que soportan la
\textbf{programaci√≥n orientada a objetos}.

No es f√°cil definir la programaci√≥n orientada a objetos, pero ya hemos
notado algunos de sus elementos clave:
\begin{itemize}
\item Los programas se construyen a partir de definiciones de objetos y
definiciones de funciones; la mayor√≠a de los c√≥mputos se hacen con
base en objetos.
\item Cada definici√≥n de objetos corresponde a alg√∫n concepto o cosa del
mundo real, y las funciones que operan sobre esos objetos corresponden
a las maneras en que los conceptos o cosas reales interact√∫an.
\end{itemize}
Por ejemplo, la clase \texttt{Hora}, definida en el Cap√≠tulo~\ref{time},
corresponde a la forma en que la gente registra las horas del d√≠a
y las funciones que definimos corresponden a la clase de cosas que
la gente hace con horas. Similarmente, las clases \texttt{Punto} y
\texttt{Rectangulo} corresponden a los conocidos conceptos geom√©tricos

Hasta aqu√≠, no hemos aprovechado las caracter√≠sticas que Python proporciona
para soportar la programaci√≥n orientada a objetos. De hecho, estas
caracter√≠sticas no son necesarias. La mayor√≠a s√≥lo proporciona una
sintaxis alternativa para cosas que ya hemos logrado; pero, en muchos
casos, esta forma alternativa es m√°s concisa y comunica de una manera
mas precisa la estructura de los programas.

Por ejemplo, en el programa \texttt{Hora} no hay una conexi√≥n obvia
entre la definici√≥n de clase y las definiciones de funciones. Despu√©s
de examinarlo un poco, es evidente que todas las funciones toman como
par√°metro al menos un objeto \texttt{Hora}.

Esta observaci√≥n es la motivaci√≥n para los \textbf{m√©todos}. Ya hemos
visto algunos m√©todos como \texttt{keys} y \texttt{values}, que llamamos
sobre diccionarios. Cada m√©todo se asocia con una clase y est√° pensado
para invocarse sobre instancias de dicha clase.

\index{m√©todo} \index{funci√≥n} \index{instancia!objeto} \index{objeto instancia}

Los m√©todos son como las funciones, pero con dos diferencias:
\begin{itemize}
\item Los m√©todos se definen adentro de una definici√≥n de clase, a fin de
marcar expl√≠citamente la relaci√≥n entre la clase y √©stos.
\item La sintaxis para llamar o invocar un m√©todo es distinta que para las
funciones.
\end{itemize}
En las siguientes secciones tomaremos las funciones de los cap√≠tulos
anteriores y las transformaremos en m√©todos. Esta transformaci√≥n es
totalmente mec√°nica; se puede llevar a cabo siguiendo una secuencia
de pasos. Si usted se siente c√≥modo al transformar de una forma a
la otra, ser√° capaz de escoger lo mejor de cada lado para resolver
los problemas que tenga a la mano.

\section{\texttt{imprimirHora}}

\label{printTime} \index{imprimir!objetos}

En el cap√≠tulo~\ref{time}, definimos una clase denominada \texttt{Hora}
y usted escribi√≥ una funci√≥n denominada \texttt{imprimirHora}, que
luc√≠a as√≠:\inputencoding{latin9}
\begin{lstlisting}
class Hora:
  pass

def imprimirHora(h):
  print(str(h.hora) + ":" + 
        str(h.minutos) + ":" + 
        str(h.segundos))
\end{lstlisting}
\inputencoding{utf8}
Para llamar esta funci√≥n, le pasamos un objeto \texttt{Hora} como
par√°metro:\inputencoding{latin9}
\begin{lstlisting}
>>> horaActual = Hora()
>>> horaActual.hora = 9
>>> horaActual.minutos = 14
>>> horaActual.segundos = 30
>>> imprimirHora(horaActual)
\end{lstlisting}
\inputencoding{utf8}
Para convertir \texttt{imprimirHora} en un m√©todo todo lo que tenemos
que hacer es ponerla adentro de la definici√≥n de clase. Note como
ha cambiado la indentaci√≥n.

\inputencoding{latin9}\begin{lstlisting}
class Hora:
  def imprimirHora(h):
    print( str(h.hora) + ":" + 
          str(h.minutos) + ":" + 
          str(h.segundos))
\end{lstlisting}
\inputencoding{utf8} Ahora podemos llamar a \texttt{imprimirHora} usando la notaci√≥n punto.

\index{notaci√≥n punto}\inputencoding{latin9}
\begin{lstlisting}
>>> horaActual.imprimirHora()
\end{lstlisting}
\inputencoding{utf8}
Como de costumbre, el objeto en el que el m√©todo se llama aparece
antes del punto y el nombre del m√©todo va a la derecha. El objeto
al cual se invoca el m√©todo se asigna al primer par√°metro, as√≠ que
\texttt{horaActual} se asigna al par√°metro \texttt{h}.

Por convenci√≥n, el primer par√°metro de un m√©todo se denomina \texttt{self}
(en ingl√©s, eso es algo como ``s√≠ mismo''). La raz√≥n para hacerlo
es un poco tortuosa, pero se basa en una met√°fora muy √∫til.

La sintaxis para una llamada de funci√≥n, \texttt{imprimirHora(horaActual)},
sugiere que la funci√≥n es el agente activo. Dice algo como ``Hey,
\texttt{imprimirHora}! Aqu√≠ hay un objeto para que imprimas''.

En la programaci√≥n orientada a objetos, los objetos son los agentes
activos. Una invocaci√≥n como \texttt{horaActual.imprimirHora()} dice
algo como ``Hey, objeto \texttt{horaActual}! Por favor, impr√≠mase
a s√≠ mismo!''.

Este cambio de perspectiva parece ser s√≥lo ``cortes√≠a'', pero puede
ser √∫til. En los ejemplos que hemos visto no lo es. Pero, el transferir
la responsabilidad desde las funciones hacia los objetos hace posible
escribir funciones m√°s vers√°tiles y facilita la reutilizaci√≥n y el
mantenimiento de c√≥digo.

\section{Otro ejemplo}

Convirtamos \texttt{incrementar} (de la Secci√≥n~\ref{increment})
en un m√©todo. Para ahorrar espacio, omitiremos los m√©todos que ya
definimos, pero usted debe conservarlos en su programa:\inputencoding{latin9}
\begin{lstlisting}
class Hora:
  # Las definiciones anteriores van aquÌ...
  
  def incrementar(self, segundos):
    self.segundos = self.segundos + segundos

    if self.segundos >= 60:
      self.segundos = self.segundos - 60
      self.minutos = self.minutos + 1

    if self.minutos >= 60:
      self.minutos = self.minutos - 60
      self.hora = self.hora + 1

    return self
\end{lstlisting}
\inputencoding{utf8} La transformaci√≥n es totalmente mec√°nica ‚Äîponemos la definici√≥n del
m√©todo adentro de la clase y cambiamos el nombre del primer par√°metro.

Ahora podemos llamar a \texttt{incrementar} como m√©todo:\inputencoding{latin9}
\begin{lstlisting}
horaActual.incrementar(500)
\end{lstlisting}
\inputencoding{utf8}
Nuevamente, el objeto con el cual se invoca el m√©todo se asigna al
primer par√°metro, \texttt{self}. El segundo par√°metro, \texttt{segundos}
recibe el valor \texttt{500}.

\section{Un ejemplo m√°s complejo}

El m√©todo \texttt{despues} es un poco m√°s complejo ya que opera sobre
dos objetos \texttt{Hora}, no s√≥lo uno. Solamente podemos convertir
uno de los par√°metros a \texttt{self}; el otro contin√∫a igual:

\inputencoding{latin9}\begin{lstlisting}
class Hora:
  # Las definiciones anteriores van aqui...

  def despues(self, hora2):
    if self.hora > hora2.hora:
      return True
    if self.hora < hora2.hora:
      return False

    if self.minutos > hora2.minutos:
      return True
    if self.minutos < hora2.minutos:
      return False

    if self.segundos > hora2.segundos:
      return True
    return False
\end{lstlisting}
\inputencoding{utf8} Llamamos a este m√©todo sobre un objeto y le pasamos el otro como
argumento:\inputencoding{latin9}
\begin{lstlisting}
if horaComer.despues(horaActual):
  print("El pan estar· listo para comer en un momento.")
\end{lstlisting}
\inputencoding{utf8}
Casi se puede leer el llamado en lenguaje natural:``Si la hora para
Comer viene despu√©s de la hora Actual, entonces ...''.

\section{Argumentos opcionales}

Hemos visto varias funciones primitivas que toman un n√∫mero variable
de argumentos. Por ejemplo, \texttt{string.find} puede tomar dos,
tres o cuatro.

Es posible escribir funciones con listas de argumentos opcionales.
Por ejemplo, podemos mejorar nuestra versi√≥n de \texttt{buscar} para
que sea tan sofisticada como \texttt{string.find}.

Esta es la versi√≥n original que introdujimos en la Secci√≥n~\ref{find}:

\pagebreak{}

\inputencoding{latin9}\begin{lstlisting}
def buscar(cad, c):
  indice = 0
  while indice < len(cad):
    if cad[indice] == c:
      return indice
    indice = indice + 1
  return -1
\end{lstlisting}
\inputencoding{utf8} Esta es la nueva versi√≥n, mejorada:\inputencoding{latin9}
\begin{lstlisting}
def buscar(cad, c,ini=0):
  indice = ini
  while indice < len(cad):
    if cad[indice] == c:
      return indice
    indice = indice + 1
  return -1
\end{lstlisting}
\inputencoding{utf8}
El tercer par√°metro, \texttt{ini}, es opcional, ya que tiene un valor
por defecto, \texttt{0}. Si llamamos a \texttt{buscar} con dos argumentos,
se usa el valor por defecto y la b√∫squeda se hace desde el principio
de la cadena:\inputencoding{latin9}
\begin{lstlisting}
>>> buscar("apple", "p")
1
\end{lstlisting}
\inputencoding{utf8}
Si se pasa el tercer par√°metro, este \textbf{sobreescribe} el valor
por defecto:\inputencoding{latin9}
\begin{lstlisting}
>>> buscar("apple", "p", 2)
2
>>> buscar("apple", "p", 3)
-1
\end{lstlisting}
\inputencoding{utf8}
\section{El m√©todo de inicializaci√≥n}

\index{m√©todo de inicializaci√≥n} \index{m√©todo!de inicializaci√≥n}

El \textbf{de inicializaci√≥n} es un m√©todo especial que se llama cuando
se crea un objeto. El nombre de este m√©todo es \texttt{\_\_init\_\_}
(dos caracteres de subrayado, seguidos por \texttt{init}, y luego
dos caracteres de subrayado m√°s). Un m√©todo de inicializaci√≥n para
la clase \texttt{Hora} se presenta a continuaci√≥n:\inputencoding{latin9}
\begin{lstlisting}
class Hora:
  def __init__(self, hora=0, minutos=0, segundos=0):
    self.hora = hora
    self.minutos = minutos
    self.segundos = segundos
\end{lstlisting}
\inputencoding{utf8}
No hay conflicto entre el atributo \texttt{self.hora} y el par√°metro
\texttt{hora}. La notaci√≥n punto especifica a qu√© variable nos estamos
refiriendo.

\index{notaci√≥n punto}

Cuando llamamos al m√©todo constructor de \texttt{Hora}, los argumentos
se pasan a \texttt{init}:\inputencoding{latin9}
\begin{lstlisting}
>>> horaActual = Hora(9, 14, 30)
>>> horaActual.imprimirHora()
>>> 9:14:30
\end{lstlisting}
\inputencoding{utf8}
Como los par√°metros son opcionales, se pueden omitir:\inputencoding{latin9}
\begin{lstlisting}
>>> horaActual = Hora()
>>> horaActual.imprimirHora()
>>> 0:0:0
\end{lstlisting}
\inputencoding{utf8}
O podemos pasar solo un par√°metro:\inputencoding{latin9}
\begin{lstlisting}
>>> horaActual = Hora(9)
>>> horaActual.imprimirHora()
>>> 9:0:0
\end{lstlisting}
\inputencoding{utf8}
O, s√≥lo los dos primeros:\inputencoding{latin9}
\begin{lstlisting}
>>> horaActual = Hora(9, 14)
>>> horaActual.imprimirHora()
>>> 9:14:0
\end{lstlisting}
\inputencoding{utf8}
Finalmente, podemos proporcionar algunos par√°metros, nombr√°ndolos
expl√≠citamente:\inputencoding{latin9}
\begin{lstlisting}
>>> horaActual = Hora(segundos = 30, hora = 9)
>>> horaActual.imprimirHora()
>>> 9:0:30
\end{lstlisting}
\inputencoding{utf8}
\section{Reconsiderando la clase Punto}

\index{clase Punto} \index{clase!Punto}

Reescribamos la clase \texttt{Punto} de la Secci√≥n~\ref{point} en
un estilo m√°s orientado a objetos:\inputencoding{latin9}
\begin{lstlisting}
class Punto:
  def __init__(self, x=0, y=0):
    self.x = x
    self.y = y

  def __str__(self):
    return '(' + str(self.x) + ', ' + str(self.y) + ')'
\end{lstlisting}
\inputencoding{utf8}
El m√©todo de inicializaci√≥n toma los valores $x$ y $y$ como par√°metros
opcionales, el valor por defecto que tienen es 0.

El m√©todo \texttt{\_\_str\_\_}, retorna una representaci√≥n de un objeto
\texttt{Punto} en forma de cadena de texto. Si una clase proporciona
un m√©todo denominado \texttt{\_\_str\_\_}, √©ste sobreescribe el comportamiento
por defecto de la funci√≥n primitiva \texttt{str}.\inputencoding{latin9}
\begin{lstlisting}
>>> p = Punto(3, 4)
>>> str(p)
'(3, 4)'
\end{lstlisting}
\inputencoding{utf8}
Imprimir un objeto \texttt{Punto} impl√≠citamente invoca a \texttt{\_\_str\_\_}
o sobre √©ste, as√≠ que definir a \texttt{\_\_str\_\_} tambi√©n cambia
el comportamiento de la sentencia \texttt{print}:\inputencoding{latin9}
\begin{lstlisting}
>>> p = Punto(3, 4)
>>> print(p)
(3, 4)
\end{lstlisting}
\inputencoding{utf8}
Cuando escribimos una nueva clase, casi siempre empezamos escribiendo
\texttt{\_\_init\_\_}, ya que facilita la instanciaci√≥n de objetos,
y \texttt{\_\_str\_\_}, que casi siempre es esencial para la depuraci√≥n.

\section{Sobrecarga de operadores}

\label{operator overloading} \index{operadores sobrecarga de} \index{operadores!sobrecarga}
\index{producto punto} \index{multiplicaci√≥n escalar}

Algunos lenguajes hacen posible cambiar la definici√≥n de los operadores
primitivos cuando se aplican sobre tipos definidos por el programador.
Esta caracter√≠stica se denomina \textbf{sobrecarga de operadores}.
Es especialmente √∫til para definir tipos de datos matem√°ticos.

Por ejemplo, para sobrecargar el operador suma, \texttt{+}, proporcionamos
un m√©todo denominado \texttt{\_\_add\_\_}:\inputencoding{latin9}
\begin{lstlisting}
class Punto:
  # los mÈtodos definidos previamente van aquÌ...

  def __add__(self, otro):
    return Punto(self.x + otro.x, self.y + otro.y)
\end{lstlisting}
\inputencoding{utf8}
Como de costumbre, el primer par√°metro es el objeto con el cual se
invoca el m√©todo. El segundo par√°metro se denomina con la palabra
\texttt{otro} para marcar la distinci√≥n entre √©ste y \texttt{self}.
Para sumar dos \texttt{Punto}s, creamos y retornamos un nuevo \texttt{Punto}
que contiene la suma de las coordenadas en el eje $x$ y la suma de
las coordenadas en el eje $y$.

Ahora, cuando aplicamos el operador \texttt{+} a dos objetos \texttt{Punto},
Python hace el llamado del m√©todo \texttt{\_\_add\_\_}:\inputencoding{latin9}
\begin{lstlisting}
>>>   p1 = Punto(3, 4)
>>>   p2 = Punto(5, 7)
>>>   p3 = p1 + p2
>>>   print(p3)
(8, 11)
\end{lstlisting}
\inputencoding{utf8}
La expresi√≥n \texttt{p1 + p2} es equivalente a \texttt{p1.\_\_add\_\_(p2)},
pero luce mucho mas elegante.

Hay varias formas de sobrecargar el comportamiento del operador multiplicaci√≥n:
definiendo un m√©todo \texttt{\_\_mul\_\_}, o \texttt{\_\_rmul\_\_},
o ambos.

Si el operando izquierdo de \texttt{{*}} es un \texttt{Punto}, Python
invoca a \texttt{\_\_mul\_\_}, asumiendo que el otro operando tambi√©n
es un \texttt{Punto}. Calcula el \textbf{producto escalar} de los
dos puntos de acuerdo a las reglas del √°lgebra lineal:\inputencoding{latin9}
\begin{lstlisting}
def __mul__(self, otro):
  return self.x * otro.x + self.y * otro.y
\end{lstlisting}
\inputencoding{utf8}
Si el operando izquierdo de \texttt{{*}} es un tipo primitivo y el
operando derecho es un \texttt{Punto}, Python llama a \texttt{\_\_rmul\_\_},
que ejecuta la \textbf{multiplicaci√≥n escalar }:\inputencoding{latin9}
\begin{lstlisting}
def __rmul__(self, otro):
  return Punto(otro * self.x,  otro * self.y)
\end{lstlisting}
\inputencoding{utf8}
El resultado ahora es un nuevo \texttt{Punto} cuyas coordenadas son
m√∫ltiplos de las originales. Si \texttt{otro} pertenece a un tipo
que no se puede multiplicar por un n√∫mero de punto flotante, la funci√≥n
\texttt{\_\_rmul\_\_} producir√° un error.

Este ejemplo ilustra las dos clases de multiplicaci√≥n:\inputencoding{latin9}
\begin{lstlisting}
>>> p1 = Punto(3, 4)
>>> p2 = Punto(5, 7)
>>> print(p1 * p2)
43
>>> print(2 * p2)
(10, 14)
\end{lstlisting}
\inputencoding{utf8} ¬øQue pasa si tratamos de evaluar \texttt{p2 {*} 2}? Ya que el primer
par√°metro es un \texttt{Punto}, Python llama a \texttt{\_\_mul\_\_}
con \texttt{2} como segundo argumento. Dentro de \texttt{\_\_mul\_\_},
el programa intenta acceder al valor \texttt{x} de \texttt{otro},
lo que falla porque un n√∫mero entero no tiene atributos:

\inputencoding{latin9}\begin{lstlisting}
>>> print(p2 * 2)
AttributeError: 'int' object has no attribute 'x'
\end{lstlisting}
\inputencoding{utf8} Desafortunadamente, el mensaje de error es un poco opaco. Este ejemplo
demuestra una de las dificultades de la programaci√≥n orientada a objetos.
Algunas veces es dif√≠cil saber qu√© c√≥digo est√° ejecut√°ndose.

Para un ejemplo completo de sobrecarga de operadores vea el cap√≠tulo
\ref{overloading}.

\section{Polimorfismo}

\index{polimorfismo}

La mayor√≠a de los m√©todos que hemos escrito s√≥lo funcionan para un
tipo de dato espec√≠fico. Cuando se crea un nuevo tipo de objeto, se
escriben m√©todos que operan sobre ese tipo.

Pero hay ciertas operaciones que se podr√≠an aplicar a muchos tipos,
un ejemplo de √©stas son las operaciones aritm√©ticas de las secciones
anteriores. Si muchos tipos soportan el mismo conjunto de operaciones,
usted puede escribir funciones que trabajen con cualquiera de estos
tipos.

Por ejemplo la operaci√≥n \texttt{multsuma} (que se usa en el √°lgebra
lineal) toma tres par√°metros, multiplica los primeros dos y luego
suma a esto el tercero. En Python se puede escribir as√≠:

\inputencoding{latin9}\begin{lstlisting}
def multsuma (x, y, z):
  return x * y + z
\end{lstlisting}
\inputencoding{utf8} Este m√©todo funcionar√° para cualesquier valores de \texttt{x} e \texttt{y}
que puedan multiplicarse, y para cualquier valor de \texttt{z} que
pueda sumarse al producto.

Podemos llamarla sobre n√∫meros:

\inputencoding{latin9}\begin{lstlisting}
>>> multsuma (3, 2, 1)
7
\end{lstlisting}
\inputencoding{utf8} O sobre \texttt{Punto}s:\inputencoding{latin9}
\begin{lstlisting}
>>> p1 = Punto(3, 4)
>>> p2 = Punto(5, 7)
>>> print(multsuma (2, p1, p2))
(11, 15)
>>> print(multsuma (p1, p2, 1))
44
\end{lstlisting}
\inputencoding{utf8}
En el primer caso, el \texttt{Punto} se multiplica por un escalar
y luego se suma a otro \texttt{Punto}. En el segundo caso, el producto
punto produce un valor num√©rico, as√≠ que el tercer par√°metro tambi√©n
tiene que ser un n√∫mero.

Una funci√≥n como √©sta, que puede tomar par√°metros con tipos distintos
se denomina \textbf{polim√≥rfica}.

Otro ejemplo es la funci√≥n \texttt{derechoyAlReves}, que imprime una
lista dos veces, al derecho y al rev√©s:

\inputencoding{latin9}\begin{lstlisting}
def derechoyAlReves(l):
  import copy
  r = copy.copy(l)
  r.reverse()
  print(str(l) + str(r))
\end{lstlisting}
\inputencoding{utf8} Como el m√©todo \texttt{reverse} es una funci√≥n modificadora, tenemos
que tomar la precauci√≥n de hacer una copia de la lista antes de llamarlo.
De esta forma la lista que llega como par√°metro no se modifica.

Aqu√≠ hay un ejemplo que aplica \texttt{derechoyAlReves} a una lista:

\inputencoding{latin9}\begin{lstlisting}
>>> miLista = [1, 2, 3, 4]
>>> derechoyAlReves(miLista)
[1, 2, 3, 4][4, 3, 2, 1]
\end{lstlisting}
\inputencoding{utf8} Por supuesto que funciona para listas, esto no es sorprendente. Lo
que ser√≠a sorprendente es que pudi√©ramos aplicarla a un \texttt{Punto}.

Para determinar si una funci√≥n puede aplicarse a un nuevo tipo de
dato usamos la regla fundamental del polimorfismo:
\begin{quote}
\textbf{Si todas las operaciones adentro de la funci√≥n pueden aplicarse
al otro tipo, la funci√≥n puede aplicarse al tipo.} 
\end{quote}
Las operaciones que usa el m√©todo son \texttt{copy}, \texttt{reverse},
y \texttt{print}.

\texttt{copy} funciona para cualquier objeto, y como ya hemos escrito
un m√©todo \texttt{\_\_str\_\_} para los \texttt{Punto}s, lo √∫nico
que nos falta es el m√©todo \texttt{reverse} dentro de la clase \texttt{Punto}:

\inputencoding{latin9}\begin{lstlisting}
def reverse(self):
  self.x , self.y = self.y, self.x
\end{lstlisting}
\inputencoding{utf8} Entonces podemos aplicar \texttt{derechoyAlReves} a objetos \texttt{Punto}:

\inputencoding{latin9}\begin{lstlisting}
>>>   p = Punto(3, 4)
>>>   derechoyAlReves(p)
(3, 4)(4, 3)
\end{lstlisting}
\inputencoding{utf8} El mejor tipo de polimorfismo es el que no se pretend√≠a lograr, aquel
en el que se descubre que una funci√≥n escrita puede aplicarse a un
tipo para el cual no se hab√≠a planeado hacerlo.

\section{Glosario}
\begin{description}
\item [{Lenguaje orientado a objetos:}] lenguaje que tiene caracter√≠sticas,
como las clases definidas por el usuario y la herencia, que facilitan
la programaci√≥n orientada a objetos.
\item [{Programaci√≥n orientada a objetos:}] estilo de programaci√≥n en
el que los datos y las operaciones que los manipulan se organizan
en clases y m√©todos.
\item [{M√©todo:}] funci√≥n que se define adentro de una clase y se llama
sobre instancias de √©sta.
\item [{Sobreescribir:}] reemplazar un valor preexistente. Por ejemplo,
se puede reemplazar un par√°metro por defecto con un argumento particular
y un m√©todo ya definido, proporcionando un nuevo m√©todo con el mismo
nombre.
\item [{M√©todo de inicializaci√≥n:}] m√©todo especial que se llama autom√°ticamente
cuando se crea un nuevo objeto. Inicializa los atributos del objeto.
\item [{Sobrecarga de operadores:}] extender el significado de los operadores
primitivos (\texttt{+}, \texttt{-}, \texttt{{*}}, \texttt{>}, \texttt{<},
etc.) de forma que acepten tipos definidos por el usuario.
\item [{Producto punto:}] operaci√≥n del √°lgebra lineal que multiplica
dos \texttt{Punto}s y produce un valor num√©rico.
\item [{Multiplicaci√≥n escalar:}] operaci√≥n del √°lgebra lineal que multiplica
cada una de las coordenadas de un \texttt{Punto} por un valor num√©rico.
\item [{Polim√≥rfica:}] funci√≥n que puede operar sobre varios tipos de datos.
Si todas las operaciones que se llaman dentro de la funci√≥n se le
pueden aplicar al tipo de dato, entonces la funci√≥n puede aplic√°rsela
al tipo.

\index{lenguaje de programaci√≥n orientado a objetos} \index{m√©todo}
\index{m√©todo de inicializaci√≥n} \index{sobreescribir} \index{sobrecarga}
\index{sobrecarga de operadores} \index{producto punto} \index{multiplicaci√≥n escalar}
\index{polim√≥rfica}
\end{description}

\section{Ejercicios}
\begin{enumerate}
\item Convierta \texttt{convertirASegundos} (de la Secci√≥n~\ref{convert})
a un m√©todo de la clase \texttt{Hora}.
\item A√±ada un cuarto par√°metro \texttt{fin} a la funci√≥n \texttt{buscar}
que especifique hasta donde continuar la b√∫squeda.

Advertencia: Este ejercicio tiene una cascarita. El valor por defecto
de \texttt{fin} deber√≠a ser \texttt{len(cad)}, pero esto no funciona.
Los valores por defecto se eval√∫an en el momento de definici√≥n de
las funciones, no cuando se llaman. Cuando se define \texttt{buscar},
\texttt{cad} no existe todav√≠a, as√≠ que no se puede obtener su longitud.
\item Agregue un m√©todo \texttt{\_\_sub\_\_(self, otro)} que sobrecargue
el operador resta de la clase \texttt{Punto}, y pru√©belo.
\end{enumerate}

