
\chapter{Variables, expresiones y sentencias}

\section{Valores y tipos}

\index{valor} \index{tipo} \index{cadena}

Un \textbf{valor} es una de las cosas fundamentales‚Äîcomo una letra
o un n√∫mero‚Äîque un programa manipula. Los valores que hemos visto
hasta ahorra son \texttt{2} (el resultado cuando a√±adimos \texttt{1
+ 1}, y {\verb+"Hola todo el Mundo!"+}.

Los valores pertenecen a diferentes \textbf{tipos}: \texttt{2} es
un entero, y {\verb+"Hola, Mundo!"+} es una \textbf{cadena}, llamada
as√≠ porque contiene una ``cadena'' de letras. Usted (y el int√©rprete)
pueden identificar cadenas porque est√°n encerradas entre comillas.

La funci√≥n de impresi√≥n tambi√©n trabaja con enteros.

\inputencoding{latin9}\begin{lstlisting}
>>> print(4)
4
\end{lstlisting}
\inputencoding{utf8} 

Si no est√° seguro del tipo que un valor tiene, el int√©rprete le puede
decir.

\inputencoding{latin9}\begin{lstlisting}
>>> type("Hola, Mundo!")
str
>>> type(17)
int
\end{lstlisting}
\inputencoding{utf8} 

Sin despertar ninguna sorpresa, las cadenas pertenecen al tipo \texttt{\textbf{str}}\texttt{ing
(cadena)} y los enteros pertenecen al tipo \texttt{\textbf{int}}\texttt{eger}.
Menos obvio, los n√∫meros con cifras decimales pertenecen a un tipo
llamado \texttt{float}, porque √©stos se representan en un formato
denominado \textbf{punto flotante}.

\index{tipo} \index{cadena} \index{tipo!cadena} \index{int} \index{tipo!int}
\index{float} \index{tipo!float}

\inputencoding{latin9}\begin{lstlisting}
>>> type(3.2)
float
\end{lstlisting}
\inputencoding{utf8}
¬øQu√© ocurre con valores como {\verb+"17"+} y {\verb+"3.2"+}?
Parecen n√∫meros, pero est√°n encerrados entre comillas como las cadenas.

\inputencoding{latin9}\begin{lstlisting}
>>> type("17")
str
>>> type("3.2")
str
\end{lstlisting}
\inputencoding{utf8}
Ellos son cadenas.

Cuando usted digita un n√∫mero grande, podr√≠a estar tentado a usar
comas para separar grupos de tres d√≠gitos, como en \texttt{1,000,000}.
Esto no es un n√∫mero entero legal en Python, pero esto si es legal:

\inputencoding{latin9}\begin{lstlisting}
>>> print(1,000,000)
1 0 0
\end{lstlisting}
\inputencoding{utf8}
¬°Bueno, eso no es lo que esper√°bamos!. Resulta que \texttt{1,000,000}
es una tupla, algo que encontraremos en el Cap√≠tulo \ref{tuplechap}.
De momento, recuerde no poner comas en sus n√∫meros enteros.

\section{Variables}

\index{variable} \index{asignaci√≥n} \index{sentencia!asignaci√≥n}

Una de las caracter√≠sticas m√°s poderosas en un lenguaje de programaci√≥n
es la capacidad de manipular \textbf{variables}. Una variable es un
nombre que se refiere a un valor.

La \textbf{sentencia de asignaci√≥n} crea nuevas variables y les da
valores:

\inputencoding{latin9}\begin{lstlisting}
>>> mensaje = "øQuÈ Onda?"
>>> n = 17
>>> pi = 3.14159
\end{lstlisting}
\inputencoding{utf8}
Este ejemplo hace tres asignaciones: la primera asigna la cadena {\verb+"¬øQu√© Onda?"+}
a una nueva variable denominada \texttt{mensaje}, la segunda le asigna
el entero \texttt{17} a \texttt{n} y la tercera le asigna el n√∫mero
de punto flotante \texttt{3.14159} a \texttt{pi}.

\index{diagrama de estados}

Una manera com√∫n de representar variables en el papel es escribir
el nombre de la variable con una flecha apuntando a su valor. Esta
clase de dibujo se denomina \textbf{diagrama de estados} porque muestra
el estado de cada una de las variables (piense en los valores como
el estado mental de las variables). Este diagrama muestra el resultado
de las sentencias de asignaci√≥n anteriores:

\beforefig \centerline{\includegraphics{illustrations/state2}}
\afterfig

La funci√≥n \texttt{print} tambi√©n funciona con variables.

\inputencoding{latin9}\begin{lstlisting}
>>> print(mensaje)
Que Onda?
>>> print(n)
17
>>> print(pi)
3.14159
\end{lstlisting}
\inputencoding{utf8} 

En cada caso el resultado es el valor de la variable. Las variables
tambi√©n tienen tipos; nuevamente, le podemos preguntar al int√©rprete
cuales son.

\inputencoding{latin9}\begin{lstlisting}
>>> type(mensaje)
str
>>> type(n)
int
>>> type(pi)
float
\end{lstlisting}
\inputencoding{utf8} 

El tipo de una variable es el mismo del valor al que se refiere.

\section{Nombres de variables y palabras reservadas}

\index{palabra reservada} \index{palabra!reservada}

Los programadores, generalmente, escogen nombres significativos para
sus variables ‚Äîque especifiquen para qu√© se usa la variable.

Estos nombres pueden ser arbitrariamente largos. Pueden contener letras
y n√∫meros, pero tienen que empezar con una letra. Aunque es legal
usar letras may√∫sculas, por convenci√≥n no lo hacemos. Si usted lo
hace, recuerde que la capitalizaci√≥n importa, \texttt{Pedro} y \texttt{pedro}
son variables diferentes.

El car√°cter subrayado (\texttt{\_}) puede aparecer en un nombre. A
menudo se usa en nombres con m√∫ltiples palabras, tales como \texttt{mi\_nombre}
√≥ \texttt{precio\_del\_caf√©\_en\_china}.

\index{car√°cter subrayado}

Si usted le da un nombre ilegal a una variable obtendr√° un error sint√°ctico:

\inputencoding{latin9}\begin{lstlisting}
>>> 76trombones = "gran desfile"
SyntaxError: invalid syntax
>>> mas$ = 1000000
SyntaxError: invalid syntax
>>> class = "introducciÛn a la programaciÛn"
SyntaxError: invalid syntax
\end{lstlisting}
\inputencoding{utf8}
\texttt{76trombones} es ilegal porque no empieza con una letra.\\
\texttt{mas\$} es ilegal porque contiene un car√°cter ilegal, el s√≠mbolo
\$.\\
¬øQu√© sucede con \texttt{class}?

Resulta que \texttt{class} es una de las \textbf{palabras reservadas
(keywords)} de Python. Las palabras reservadas definen las reglas
del lenguaje y su estructura, y no pueden ser usadas como nombres
de variables.

\index{palabra reservada}

Python tiene veintiocho palabras reservadas:

\inputencoding{latin9}\begin{lstlisting}
and       continue  else      for       import    not       
assert    def       except    from      in        or        
break     del       exec      global    is        pass      
class     elif      finally   if        lambda    print     
raise     return    try       while
\end{lstlisting}
\inputencoding{utf8} 

Usted puede mantener esta lista a mano. Si el int√©rprete se queja
por alguno de sus nombres de variables, y usted no sabe por qu√©, b√∫squelo
en esta lista.

\section{Sentencias}

Una sentencia es una instrucci√≥n que el int√©rprete de Python puede
ejecutar. Hemos visto una clase de sentencias: la asignaci√≥n. Invocar
una funci√≥n predefinida, como \texttt{print}, tambi√©n es una sentencia.

Cuando usted digita una sentencia en la l√≠nea de comandos, Python
la ejecuta y despliega el resultado, si hay alguno. Las asignaciones
no producen un resultado.

Un gui√≥n usualmente contiene una secuencia de sentencias. Si hay m√°s
de una, los resultados aparecen uno a uno a medida que las sentencias
se ejecutan.

Por ejemplo, el gui√≥n

\inputencoding{latin9}\begin{lstlisting}
print(1)
x = 2
print(x)
\end{lstlisting}
\inputencoding{utf8} produce la salida:
\begin{verbatim}
1
2
\end{verbatim}
Observe nuevamente que la sentencia de asignaci√≥n no produce salida.

\section{Evaluando expresiones}

Una expresi√≥n es una combinaci√≥n de valores, variables y operadores.
Si usted digita una expresi√≥n en la l√≠nea de comandos, el int√©rprete
la \textbf{eval√∫a} y despliega su resultado:

\inputencoding{latin9}\begin{lstlisting}
>>> 1 + 1
2
\end{lstlisting}
\inputencoding{utf8} 

Un valor, por si mismo, se considera como una expresi√≥n, lo mismo
ocurre para las variables.

\inputencoding{latin9}\begin{lstlisting}
>>> 17
17
>>> x
2
\end{lstlisting}
\inputencoding{utf8} 

Aunque es un poco confuso, evaluar una expresi√≥n no es lo mismo que
imprimir o desplegar un valor.

\inputencoding{latin9}\begin{lstlisting}
>>> mensaje = "Como le va, Doc?"
>>> mensaje
"Como le va, Doc?"
>>> print(mensaje)
Como le va, Doc?
\end{lstlisting}
\inputencoding{utf8} 

Cuando Python muestra el valor de una expresi√≥n que ha evaluado, utiliza
el mismo formato que se usar√≠a para entrar un valor. En el caso de
las cadenas, esto implica que se incluyen las comillas. Cuando se
usa la funci√≥n print, el efecto es distinto como usted ya lo ha evidenciado.

En un gui√≥n, una expresi√≥n, por s√≠ misma, es una sentencia legal,
pero no realiza nada. El gui√≥n:

\inputencoding{latin9}\begin{lstlisting}
17
3.2
"Hola, Mundo!"
1 + 1
\end{lstlisting}
\inputencoding{utf8} 

no produce ninguna salida. ¬øC√≥mo cambiar√≠a el gui√≥n de manera que
despliegue los valores de las cuatro expresiones?

\section{Operadores y operandos}

\index{operador} \index{operando} \index{expresi√≥n}

Los \textbf{operadores} son s√≠mbolos especiales que representan c√≥mputos,
como la suma y la multiplicaci√≥n. Los valores que el operador usa
se denominan \textbf{operandos}.

Los siguientes son expresiones v√°lidas en Python, cuyo significado
es m√°s o menos claro: 

\inputencoding{latin9}\begin{lstlisting}
20+32       hora-1   hora*60+minuto   
minuto/60   5**2     (5+9)*(15-7)
\end{lstlisting}
\inputencoding{utf8}\begin{verbatim}

\end{verbatim}
Los s√≠mbolos \texttt{+}, \texttt{-}, y \texttt{/}, y los par√©ntesis
para agrupar, significan en Python lo mismo que en la matem√°tica.
El asterisco (\texttt{{*}}) es el s√≠mbolo para la multiplicaci√≥n,
y \texttt{{*}{*}} es el s√≠mbolo para la exponenciaci√≥n. Cuando el
nombre de una variable aparece en lugar de un operando, se reemplaza
por su valor antes de calcular la operaci√≥n.

La suma, resta, multiplicaci√≥n y exponenciaci√≥n realizan lo que usted
esperar√≠a, pero la divisi√≥n usando el operador // podr√≠a sorprenderlo.
La siguiente operaci√≥n tiene un resultado inesperado:

\inputencoding{latin9}\begin{lstlisting}
>>> minuto = 59
>>> minuto//60
0
\end{lstlisting}
\inputencoding{utf8}
El valor de \texttt{minuto} es 59, y 59 dividido por 60 es 0.98333,
no 0. La raz√≥n para esta discrepancia radica en que Python est√° realizando
\textbf{divisi√≥n entera}.

\index{divisi√≥n entera}

Cuando los dos operandos son enteros el resultado tambi√©n debe ser
un entero; y, por convenci√≥n, la divisi√≥n entera siempre redondea
{\em hacia abajo}, incluso en casos donde el siguiente entero est√°
muy cerca.

Recuerde que si divide con / obtendr√° un numero flotante (los cuales
veremos con mayor detalle en el cap√≠tulo \ref{floatchap}) y si lo
hace con // obtendr√° un n√∫mero entero. 

\section{Orden de las operaciones}

\index{orden de las operaciones} \index{reglas de precedencia}

Cuando hay m√°s de un operador en una expresi√≥n, el orden de evaluaci√≥n
depende de las \textbf{reglas de precedencia}. Python sigue las mismas
reglas de precedencia a las que estamos acostumbrados para sus operadores
matem√°ticos. El acr√≥nimo \textbf{PEMDAS} es √∫til para recordar el
orden de las operaciones:
\begin{itemize}
\item Los \textbf{P}ar√©ntesis tienen la precedencia m√°s alta y pueden usarse
para forzar la evaluaci√≥n de una expresi√≥n de la manera que usted
desee. Ya que las expresiones en par√©ntesis se eval√∫an primero, \texttt{2
{*} (3-1)} es 4, y \texttt{(1+1){*}{*}(5-2)} es 8. Usted tambi√©n puede
usar par√©ntesis para que una expresi√≥n quede m√°s legible, como en
\texttt{(minuto {*} 100) / 60}, aunque esto no cambie el resultado.
\item La \textbf{E}xponenciaci√≥n tiene la siguiente precedencia m√°s alta,
as√≠ que \texttt{2{*}{*}1+1} es 3 y no 4, y \texttt{3{*}1{*}{*}3} es
3 y no 27.
\item La \textbf{M}ultiplicaci√≥n y la \textbf{D}ivisi√≥n tienen la misma
precedencia, aunque es m√°s alta que la de la \textbf{A}dici√≥n y la
\textbf{S}ubtracci√≥n, que tambi√©n tienen la misma precedencia. As√≠
que \texttt{2{*}3-1} da 5 en lugar de 4, y \texttt{2//3-1} es \texttt{-1},
no \texttt{1} (recuerde que en divisi√≥n entera, \texttt{2//3=0}).
\item Los operadores con la misma precedencia se eval√∫an de izquierda a
derecha. Recordando que \texttt{minuto=59}, en la expresi√≥n \texttt{minuto{*}100/60};
la multiplicaci√≥n se hace primero, resultando \texttt{5900/60}, lo
que a su vez da \texttt{98.33333333333333}.
\end{itemize}

\section{Operaciones sobre cadenas}

\index{operaci√≥n sobre cadenas}

En general, usted no puede calcular operaciones matem√°ticas sobre
cadenas, incluso si las cadenas lucen como n√∫meros. Las siguientes
operaciones son ilegales (asumiendo que \texttt{mensaje} tiene el
tipo \texttt{cadena}):

\inputencoding{latin9}\begin{lstlisting}
 mensaje-1   "Hola"/123   mensaje*"Hola"   "15"+2
\end{lstlisting}
\inputencoding{utf8}
Sin embargo, el operador \texttt{+} funciona con cadenas, aunque no
calcula lo que usted esperar√≠a. Para las cadenas, el operador \texttt{+}
representa la \textbf{concatenaci√≥n}, que significa unir los dos operandos
enlaz√°ndolos en el orden en que aparecen. Por ejemplo:

\index{concatenaci√≥n}

\inputencoding{latin9}\begin{lstlisting}
fruta = "banano"
bienCocinada = " pan con nueces"
print(fruta + bienCocinada)
\end{lstlisting}
\inputencoding{utf8}
La salida de este programa es \texttt{banano pan con nueces}. El espacio
antes de la palabra \texttt{pan} es parte de la cadena y sirve para
producir el espacio entre las cadenas concatenadas.

El operador \texttt{{*}} tambi√©n funciona con las cadenas; hace una
repetici√≥n. Por ejemplo, \texttt{'Fun'{*}3} es \texttt{'FunFunFun'.}
Uno de los operandos tiene que ser una cadena, el otro tiene que ser
un entero.

Estas interpretaciones de \texttt{+} y \texttt{{*}} tienen sentido
por la analog√≠a con la suma y la multiplicaci√≥n. As√≠ como \texttt{4{*}3}
es equivalente a \texttt{4+4+4}, esperamos que \verb+"Fun"*3+ sea
lo mismo que {\verb/"Fun"+"Fun"+"Fun"/}, y lo es. Sin embargo,
las operaciones de concatenaci√≥n y repetici√≥n sobre cadenas tienen
una diferencia significativa con las operaciones de suma y multiplicaci√≥n.
¬øPuede usted pensar en una propiedad que la suma y la multiplicaci√≥n
tengan y que la concatenaci√≥n y repetici√≥n no?

\section{Composici√≥n}

\index{composici√≥n}

Hasta aqu√≠ hemos considerado a los elementos de un programa‚Äîvariables,
expresiones y sentencias‚Äîaisladamente, sin especificar c√≥mo combinarlos.

Una de las caracter√≠sticas mas √∫tiles de los lenguajes de programaci√≥n
es su capacidad de tomar peque√±os bloques para \textbf{componer} con
ellos. Por ejemplo, ya que sabemos c√≥mo sumar n√∫meros y c√≥mo imprimirlos;
podemos hacer las dos cosas al mismo tiempo:

\inputencoding{latin9}\begin{lstlisting}
>>> print(17 + 3)
20
\end{lstlisting}
\inputencoding{utf8} De hecho, la suma tiene que calcularse antes que la impresi√≥n, as√≠
que las acciones no est√°n ocurriendo realmente al mismo tiempo. El
punto es que cualquier expresi√≥n que tenga n√∫meros, cadenas y variables
puede ser usada en una sentencia de impresi√≥n (\texttt{print}). Usted
ha visto un ejemplo de esto:

\inputencoding{latin9}\begin{lstlisting}
print("N˙mero de minutos desde media noche: ",  \
  hora*60+minuto)
\end{lstlisting}
\inputencoding{utf8} El caracter \textbackslash{} permite continuar en la siguiente l√≠nea.
Lo usaremos cuando las expresiones sean muy largas. Usted tambi√©n
puede poner expresiones arbitrarias en el lado derecho de una sentencia
de asignaci√≥n:

\inputencoding{latin9}\begin{lstlisting}
porcentaje = (minuto * 100) / 60
\end{lstlisting}
\inputencoding{utf8} Esto no parece nada impresionante ahora, pero vamos a ver otros ejemplos
en los que la composici√≥n hace posible expresar c√°lculos complejos
organizada y concisamente.

Advertencia: hay restricciones sobre los lugares en los que se pueden
usar las expresiones. Por ejemplo, el lado izquierdo de una asignaci√≥n
tiene que ser un nombre de {\em variable}, no una expresi√≥n. As√≠
que esto es ilegal: \texttt{minuto+1 = hora}.

\section{Comentarios}

\index{comentario}

A medida que los programas se hacen m√°s grandes y complejos, se vuelven
m√°s dif√≠ciles de leer. Los lenguajes formales son densos; y, a menudo,
es dif√≠cil mirar una secci√≥n de c√≥digo y saber qu√© hace, o por qu√©
lo hace.

Por esta raz√≥n, es una muy buena idea a√±adir notas a sus programas
para explicar, en lenguaje natural, lo que hacen. Estas notas se denominan
\textbf{comentarios }y se marcan con el s√≠mbolo \texttt{\#}:

\inputencoding{latin9}\begin{lstlisting}
# calcula el porcentaje de la hora que ha pasado
porcentaje = (minuto * 100) / 60
\end{lstlisting}
\inputencoding{utf8} En este caso, el comentario aparece en una l√≠nea completa. Tambi√©n
pueden ir comentarios al final de una l√≠nea:

\inputencoding{latin9}\begin{lstlisting}
porcentaje = (minute * 100) // 60 # div entera
\end{lstlisting}
\inputencoding{utf8}
todo lo que sigue desde el \texttt{\#} hasta el fin de la l√≠nea se
ignora‚Äîno tiene efecto en el programa. El mensaje es para el programador
que escribe el programa o para alg√∫n programador que podr√≠a usar este
c√≥digo en el futuro. En este caso, le recuerda al lector el sorprendente
comportamiento de la divisi√≥n entera en Python.

\section{Glosario}
\begin{description}
\item [{Valor:}] un n√∫mero o una cadena (u otra cosa que se introduzca
m√°s adelante) que puede ser almacenado en una variable o calculado
en una expresi√≥n.
\item [{Tipo:}] conjunto de valores. El tipo del valor determina c√≥mo se
puede usar en expresiones. Hasta aqu√≠, los tipos que usted ha visto
son enteros (tipo \texttt{int}), n√∫meros de punto flotante (tipo \texttt{float})
y cadenas (tipo \texttt{string}).
\item [{Punto flotante:}] formato para representar n√∫meros con parte decimal.
\item [{Variable:}] nombre que se refiere a un valor.
\item [{Sentencia:}] secci√≥n de c√≥digo que representa un comando o acci√≥n.
Hasta aqu√≠ las sentencias que usted ha visto son la de asignaci√≥n
y la de impresi√≥n.
\item [{Asignaci√≥n:}] corresponde a la sentencia que pone un valor en una
variable.
\item [{Diagrama de estados:}] es la representaci√≥n gr√°fica de un conjunto
de variables y los valores a los que se refieren.
\item [{Palabra reservada:}] es una palabra usada por el compilador para
analizar sint√°cticamente un programa; usted no puede usar palabras
reservadas como \texttt{if}, \texttt{def}, y \texttt{while} como nombres
de variables.
\item [{Operador:}] s√≠mbolo especial que representa un simple c√°lculo como
una suma, multiplicaci√≥n o concatenaci√≥n de cadenas.
\item [{Operando:}] uno de los valores sobre el cual act√∫a un operador.
\item [{Expresi√≥n:}] combinaci√≥n de variables, operadores y valores que
representa un √∫nico valor de resultado.
\item [{Evaluar:}] simplificar una expresi√≥n ejecutando varias operaciones
a fin de retornar un valor √∫nico.
\item [{Divisi√≥n entera:}] operaci√≥n que divide un entero por otro y
retorna un entero. La divisi√≥n entera retorna el n√∫mero de veces que
el denominador cabe en el numerador y descarta el residuo.
\item [{Reglas de precedencia:}] reglas que gobiernan el orden en que
las expresiones que tienen m√∫ltiples operadores y operandos se eval√∫an.
\item [{Concatenar:}] unir dos operandos en el orden en que aparecen.
\item [{Composici√≥n:}] es la capacidad de combinar simples expresiones
y sentencias dentro de sentencias y expresiones compuestas para representar
c√°lculos complejos concisamente.
\item [{Comentario:}] informaci√≥n que se incluye en un programa para otro
programador (o lector del c√≥digo fuente) que no tiene efecto en la
ejecuci√≥n.

\index{valor} \index{punto flotante} \index{variable} \index{tipo}
\index{palabra reservada} \index{sentencia} \index{asignaci√≥n}
\index{comentario} \index{diagrama de estados} \index{expresi√≥n}
\index{operador} \index{operando} \index{divisi√≥n entera} \index{reglas de precedencia}
\index{precedencia} \index{concatenaci√≥n} \index{composici√≥n}
\end{description}

\section{Ejercicios}
\begin{enumerate}
\item ¬øQu√© sucede cuando se usa la funci√≥n print con una expresi√≥n?, por
ejemplo: \inputencoding{latin9}
\begin{lstlisting}
print(8+5)
\end{lstlisting}
\inputencoding{utf8}\item ¬øQu√© sucede cuando se ejecuta esto?\inputencoding{latin9}
\begin{lstlisting}
print(5.2, "esto", 4 - 2, "aquello", 5/2.0)
\end{lstlisting}
\inputencoding{utf8}\item Tome la siguiente oraci√≥n: S√≥lo trabajo y nada de juegos hacen de
Juan un ni√±o aburrido. Almacene cada palabra en variables separadas,
despu√©s muestre la oraci√≥n en una sola l√≠nea usando la funci√≥n print.
\item Incluya par√©ntesis a la expresi√≥n 6 {*} 1 - 2 para cambiar su resultado
de 4 a -6.
\item Inserte una l√≠nea de comentario en un l√≠nea previa a una de c√≥digo
funcional, y registre qu√© es lo que sucede cuando corre de nuevo el
programa.
\item La diferencia entre la funci√≥n input y la funci√≥n raw\_input es que
la funci√≥n input eval√∫a la cadena introducida y la funci√≥n raw\_input
no lo hace. Escriba lo siguiente en el int√©rprete de Python, registre
qu√© sucede y explique:

\inputencoding{latin9}\begin{lstlisting}
>>> x = input()
3.14
>>> type(x)
>>> x = raw_input()
3.14
>>> type(x)
\end{lstlisting}
\inputencoding{utf8}\item Escriba una expresi√≥n que calcule la nota definitiva de su curso de
programaci√≥n.
\end{enumerate}

