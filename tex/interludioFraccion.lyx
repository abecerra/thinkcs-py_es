%% LyX 2.2.3 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[oneside]{book}
\usepackage[utf8]{inputenc}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\usepackage{listings}
\renewcommand{\lstlistingname}{\inputencoding{latin9}Listado de cÛdigo}

\begin{document}

\chapter{Interludio 2: Creando un nuevo tipo de datos }

\label{overloading} \index{tipo de dato!definido por el usuario}

Los lenguajes de programaci√≥n orientados a objetos permiten a los
programadores crear nuevos tipos de datos que se comportan de manera
muy similar a los tipos primitivos. Exploraremos esta caracter√≠stica
construyendo una clase \texttt{Fraccionario} que se comporte como
los tipos de datos num√©ricos primitivos (enteros y flotantes).

Los n√∫meros fraccionario o racionales son valores que se pueden expresar
como una divisi√≥n entre dos n√∫meros enteros, como $\frac{1}{3}$.
El n√∫mero superior es el numerador y el inferior es es el denominador.

\index{racional} \index{fracci√≥n} \index{numerador} \index{denominador}

La clase \texttt{Fraccion} empieza con un m√©todo constructor que recibe
como par√°metros al numerador y al denominador:

\inputencoding{latin9}\begin{lstlisting}
class Fraccion:
  def __init__(self, numerador, denominador=1):
    self.numerador = numerador
    self.denominador = denominador
\end{lstlisting}
\inputencoding{utf8}El denominador es opcional. Una Fracci√≥n con un solo par√°metro representa
a un n√∫mero entero. Si el numerador es $n$, construimos la fracci√≥n
$n/1$.

El siguiente paso consiste en escribir un m√©todo \texttt{\_\_str\_\_}
que despliegue las fracciones de una manera natural. Como estamos
acostumbrados a la notaci√≥n ``numerador/denominador'', lo m√°s natural
es:

\inputencoding{latin9}\begin{lstlisting}
class Fraccion:
  ...
  def __str__(self):
    return "%d/%d" % (self.numerador, self.denominador)
\end{lstlisting}
\inputencoding{utf8} Para realizar pruebas, ponemos este c√≥digo en un archivo \texttt{Fraccion.py}
y lo importamos en el int√©rprete de Python. Ahora creamos un objeto
fracci√≥n y lo imprimimos.

\inputencoding{latin9}\begin{lstlisting}
>>> from Fraccion import Fraccion
>>> s = Fraccion(5,6)
>>> print("La fraccion es", s)
La fraccion es 5/6
\end{lstlisting}
\inputencoding{utf8} El m√©todo \texttt{print}, autom√°ticamente invoca al m√©todo \texttt{\_\_str\_\_}
de manera impl√≠cita.

\section{Multiplicaci√≥n de fracciones}

\index{multiplicaci√≥n!de fracciones} \index{fracciones!multiplicaci√≥n}

Nos gustar√≠a aplicar los mismos operadores de suma, resta, multiplicaci√≥n
y divisi√≥n a las fracciones. Para lograr esto podemos sobrecargar
los operadores matem√°ticos en la clase \texttt{Fraccion}.

\index{sobrecarga} \index{operadores!sobrecarga de} \index{operador matem√°tico}

La multiplicaci√≥n es la operaci√≥n m√°s sencilla entre fraccionarios.
El resultado de multiplicar dos fracciones a y v es una nueva fracci√≥n
en la que el numerador es el producto de los dos numeradores (de a
y b) y el denominador es el producto de los dos denominadores (de
a y b).

Python define que el m√©todo \texttt{\_\_mul\_\_} se puede definir
en una clase para sobrecargar el operador \texttt{{*}}:\inputencoding{latin9}
\begin{lstlisting}
class Fraccion:
  ...
  def __mul__(self, otro):
    return Fraccion(self.numerador*otro.numerador, \
                    self.denominador*otro.denominador)
\end{lstlisting}
\inputencoding{utf8}
Podemos probar este m√©todo calculando un producto sencillo:\inputencoding{latin9}
\begin{lstlisting}
>>> print(Fraccion(5,6) * Fraccion(3,4))
15/24
\end{lstlisting}
\inputencoding{utf8}
Funciona, pero se puede mejorar. Podemos manejar el caso en el que
se multiplique una fracci√≥n por un n√∫mero entero. Por medio de la
funci√≥n \texttt{type} se puede probar si \texttt{otro} es un entero
y convertirlo a una fracci√≥n antes de realizar el producto:\inputencoding{latin9}
\begin{lstlisting}
class Fraccion:
  ...
  def __mul__(self, otro):
    if type(otro) == type(5):
      otro = Fraccion(otro)
    return Fraccion(self.numerador   * otro.numerador, \
                    self.denominador * otro.denominador)
\end{lstlisting}
\inputencoding{utf8}
Ahora, la multiplicaci√≥n entre enteros y fracciones funciona, pero
s√≥lo si la fracci√≥n es el operando a la izquierda :

\inputencoding{latin9}\begin{lstlisting}
>>> print(Fraccion(5,6) * 4)
20/6
>>> print(4 * Fraccion(5,6))
TypeError: __mul__ nor __rmul__ defined for these operands
\end{lstlisting}
\inputencoding{utf8} Para evaluar un operador binario como la multiplicaci√≥n, Python chequea
el operando izquierdo primero, para ver si su clase define el m√©todo
\texttt{\_\_mul\_\_}, y que tenga soporte para el tipo del segundo
operando. En este caso el operador primitivo para multiplicar enteros
no soporta las fracciones.

Despu√©s, Python chequea si el operando a la derecha provee un m√©todo
\texttt{\_\_rmul\_\_} que soporte el tipo del operando de la izquierda.
En este caso, como no hay definici√≥n de \texttt{\_\_rmul\_\_} en la
clase \texttt{Fraccion}, se genera un error de tipo.

Hay una forma sencilla de definir \texttt{\_\_rmul\_\_}:\inputencoding{latin9}
\begin{lstlisting}
class Fraccion:
  ...
  __rmul__ = __mul__
\end{lstlisting}
\inputencoding{utf8} Esta asignaci√≥n dice que \texttt{\_\_rmul\_\_} contiene el mismo
c√≥digo que \texttt{\_\_mul\_\_}. Si ahora evaluamos \texttt{4 {*}
Fraccion(5,6)}, Python llama a \texttt{\_\_rmul\_\_} y le pasa al
4 como par√°metro:

\inputencoding{latin9}\begin{lstlisting}
>>> print(4 * Fraccion(5,6))
20/6
\end{lstlisting}
\inputencoding{utf8} Como \texttt{\_\_rmul\_\_} tiene el mismo c√≥digo que \texttt{\_\_mul\_\_},
y el m√©todo \texttt{\_\_mul\_\_} puede recibir un par√°metro entero,
nuestra multiplicaci√≥n de fracciones funciona bien.

\section{Suma de fracciones}

\index{suma!de fracciones} \index{fracciones!suma}

La suma es m√°s complicada que la multiplicaci√≥n. La suma $a/b+c/d$
da como resultado $\frac{(ad+cb)}{bd}$.

Bas√°ndonos en la multiplicaci√≥n, podemos escribir los m√©todos \texttt{\_\_add\_\_}
y \texttt{\_\_radd\_\_}:

\inputencoding{latin9}\begin{lstlisting}
class Fraccion:
  ...
  def __add__(self, otro):
    if type(otro) == type(5):
      otro = Fraccion(otro)
    return Fraccion(self.numerador   * otro.denominador + \
                    self.denominador * otro.numerador,    \
                    self.denominador * otro.denominador) 

  __radd__ = __add__
\end{lstlisting}
\inputencoding{utf8} Podemos probar estos m√©todos con objetos \texttt{Fraccion} y con
n√∫meros enteros.

\inputencoding{latin9}\begin{lstlisting}
>>> print(Fraccion(5,6) + Fraccion(5,6))
60/36
>>> print(Fraccion(5,6) + 3)
23/6
>>> print(2 + Fraccion(5,6))
17/6
\end{lstlisting}
\inputencoding{utf8} Los primeros ejemplos llaman al m√©todo \texttt{\_\_add\_\_}; el √∫ltimo
ejemplo llama al m√©todo \texttt{\_\_radd\_\_}.

\section{El algoritmo de Euclides}

\index{m√°ximo divisor com√∫n} \index{Euclides} \index{pseudoc√≥digo}
\index{simplificar}

En el ejemplo anterior, calculamos $5/6+5/6$ y obtuvimos $60/36$.
Es correcto, pero no es la manera m√°s sencilla de presentar la respuesta.
Para \textbf{simplificar} la fracci√≥n tenemos que dividir el numerador
y el denominador por su \textbf{m√°ximo divisor com√∫n (MDC)}, que para
este caso es 12. Entonces, un resultado mas sencillo es $5/3$.

En general, cada vez que creamos un nuevo objeto de tipo \texttt{Fraccion}
deber√≠amos simplificarlo dividiendo el numerador y el denominador
por su MDC. Si la fracci√≥n no se puede simplificar, el MDC es 1.

Euclides de Alejandr√≠a (aprox. 325‚Äì265 A.C) present√≥ un algoritmo
para encontrar el MDC de dos n√∫meros enteros $m$ y $n$:
\begin{quote}
Si $n$ divide a $m$ exactamente, entonces $n$ es el MDC. Sino,
el MDC de $m$ y $n$ es el MDC de $n$ y el residuo de la divisi√≥n
$m/n$. 
\end{quote}
Esta definici√≥n recursiva se puede implementar en una funci√≥n:

\inputencoding{latin9}\begin{lstlisting}
def MDC (m, n):
  if m % n == 0:
    return n
  else:
    return MDC(n, m%n)
\end{lstlisting}
\inputencoding{utf8} En la primera l√≠nea el operador residuo nos permite chequear si n
divide a n exactamente. En la √∫ltima l√≠nea, lo usamos para calcular
el residuo de la divisi√≥n.

Como todas las operaciones que hemos escrito crean nuevas fracciones
como resultado, podemos simplificar todos los valores de retorno modificando
el m√©todo constructor.

\inputencoding{latin9}\begin{lstlisting}
class Fraccion:
  def __init__(self, numerador, denominador=1):
    g = MDC (numerador, denominador)
    self.numerador   =   numerador / g
    self.denominador = denominador / g
\end{lstlisting}
\inputencoding{utf8} Ahora, cada vez que creamos una nueva \texttt{Fraccion}, ¬°se simplifica!.

\inputencoding{latin9}\begin{lstlisting}
>>> Fraccion(100,-36)
-25/9
\end{lstlisting}
\inputencoding{utf8} Una caracter√≠stica adicional que nos provee \texttt{MDC} es que si
la fracci√≥n es negativa, el signo menos siempre se mueve hacia el
numerador.

\section{Comparando fracciones}

\index{comparaci√≥n!de fracciones} \index{fracciones!comparaci√≥n de}

Si vamos a comparar dos objetos \texttt{Fraccion}, digamos \texttt{a}
y \texttt{b}, evaluando la expresi√≥n \texttt{a == b}. Como la implementaci√≥n
de \texttt{==} chequea igualdad superficial de objetos por defecto,
s√≥lo retornar√° cierto si \texttt{a} y \texttt{b} \textit{son} el mismo
objeto.

Es mucho m√°s probable que deseemos retornar cierto si $a$ y $b$
tienen el mismo valor ‚Äîesto es, chequear igualdad profunda.

Tenemos que ense√±arle a las fracciones c√≥mo compararse entre s√≠. Como
veremos en la secci√≥n \ref{comparecard}, podemos sobrecargar todos
los operadores de comparaci√≥n por medio de la implementaci√≥n de un
m√©todo \texttt{\_\_cmp\_\_}.

Por convenci√≥n, el m√©todo \texttt{\_\_cmp\_\_} retorna un n√∫mero negativo
si \texttt{self} es menos que \texttt{otro}, cero si son iguales,
y un n√∫mero positivo si \texttt{self} es mayor que \texttt{otro}.

La forma m√°s sencilla de comparar fracciones consiste en hacer una
multiplicaci√≥n cruzada. Si $a/b>c/d$, entonces $ad>bc$. Con esto
en mente, implementamos \texttt{\_\_cmp\_\_}:

\inputencoding{latin9}\begin{lstlisting}
class Fraccion:
  ...
  def __cmp__(self, otro):
    dif = (self.numerador  * otro.denominador - \
            otro.numerador * self.denominador)
    return dif
\end{lstlisting}
\inputencoding{utf8} Si \texttt{self} es mayor que \texttt{otro}, entonces \texttt{dif}
ser√° positivo. Si \texttt{otro} es mayor, \texttt{dif} ser√° negativo.
Si son iguales, \texttt{dif} es cero.

\section{Extendiendo las fracciones}

Todav√≠a no hemos terminado. Tenemos que implementar la resta sobrecargando
el m√©todo \texttt{\_\_sub\_\_} y la divisi√≥n con el m√©todo \texttt{\_\_div\_\_}.

Podemos restar por medio de la suma si antes negamos (cambiamos de
signo) al segundo operando. Tambi√©n podemos dividir por medio de la
multiplicaci√≥n si antes invertimos el segundo operando.

Siguiendo este razonamiento, una forma de realizar las operaciones
resta y divisi√≥n consiste en definir primero la negaci√≥n por medio
de la sobrecarga de \texttt{\_\_neg\_\_} y la inversi√≥n sobre sobrecargando
a \texttt{\_\_invert\_\_}.

Un paso adicional ser√≠a implementar \texttt{\_\_rsub\_\_} y \texttt{\_\_rdiv\_\_}.
Desafortunadamente no podemos usar el mismo truco que aplicamos para
la suma y la multiplicaci√≥n, porque la resta y la divisi√≥n no son
conmutativas. En estas operaciones el orden de los operandos altera
el resultado, as√≠ que no podemos asignar a \texttt{\_\_rsub\_\_} y
a \texttt{\_\_rdiv\_\_} los m√©todo \texttt{\_\_sub\_\_} y \texttt{\_\_div\_\_},
respectivamente.

Para realizar la \textbf{negaci√≥n unaria}, sobrecargamos a \texttt{\_\_neg\_\_}.

\index{operador unario} \index{negaci√≥n}

Podemos calcular potencias sobrecargando a \texttt{\_\_pow\_\_}, pero
la implementaci√≥n tiene un caso dif√≠cil: si el exponente no es un
entero, puede que no sea posible representar el resultado como una
\texttt{Fraccion}. Por ejemplo, la siguiente expresi√≥n \texttt{Fraccion(2)
{*}{*} Fraccion(1,2)} es la ra√≠z cuadrada de 2, que es un n√∫mero irracional
(no puede representarse por ninguna fracci√≥n). As√≠ que no es f√°cil
escribir una funci√≥n general para \texttt{\_\_pow\_\_}.

\index{irracional}

Hay otra extensi√≥n a la clase \texttt{Fraccion} que usted puede imaginar.
Hasta aqu√≠, hemos asumido que el numerador y el denominador son enteros.
Tambi√©n podemos permitir que sean de tipo long.

\section{Glosario}
\begin{description}
\item [{M√°ximo divisor com√∫n (MDC):}] el entero positivo m√°s grande
que divide exactamente a dos n√∫meros (por ejemplo, el numerador y
el denominador en una fracci√≥n).
\item [{Simplificar:}] cambiar una fracci√≥n en otra equivalente que tenga
un MDC de 1.
\item [{negaci√≥n unaria:}] la operaci√≥n que calcula un inverso aditivo,
usualmente representada con un signo menos. Es ``unaria'' en contraposici√≥n
con el menos binario que representa a la resta.

\index{m√°ximo divisor com√∫n} \index{simplificar} \index{negaci√≥n unaria}
\end{description}

\section{Ejercicios}
\begin{enumerate}
\item Complemente la implementaci√≥n de la clase \texttt{Fraccion} para que
soporte denominadores y numeradores de tipo long (enteros grandes). 
\item Agregue la operaci√≥n resta
\item Agregue la operaci√≥n divisi√≥n
\item Agregue la operaci√≥n exponenciaci√≥n. 
\end{enumerate}

\end{document}
