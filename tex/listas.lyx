%% LyX 2.2.3 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[oneside]{book}
\usepackage[utf8]{inputenc}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\synctex=-1
\usepackage{url}
\usepackage{graphicx}

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.

\newcommand{\beforefig}{\vspace{1.3\parskip}}
\newcommand{\afterfig}{\vspace{-0.2\parskip}}

\newcommand{\beforeverb}{\vspace{0.6\parskip}}
\newcommand{\afterverb}{\vspace{0.6\parskip}}

\newcommand{\adjustpage}[1]{\enlargethispage{#1\baselineskip}}

\makeatother

\usepackage{listings}
\renewcommand{\lstlistingname}{\inputencoding{latin9}Listado de cÛdigo}

\begin{document}

\chapter{Listas}

\label{cap:listas} \index{lista} \index{elemento} \index{secuencia}

Una \textbf{lista} es un conjunto ordenado de valores que se identifican
por medio de un √≠ndice. Los valores que componen una lista se denominan
\textbf{elementos}. Las listas son similares a las cadenas, que son
conjuntos ordenados de caracteres, pero son mas generales, ya que
pueden tener elementos de cualquier tipo de dato. Las listas y las
cadenas‚Äîy otras conjuntos ordenados que veremos‚Äî se denominan \textbf{secuencias}.

\section{Creaci√≥n de listas}

Hay varias formas de crear una nueva lista; la m√°s simple es encerrar
los elementos entre corchetes (\verb+[+ y \verb+]+):\inputencoding{latin9}
\begin{lstlisting}
[10, 20, 30, 40]
["correo", "lapiz", "carro"]
\end{lstlisting}
\inputencoding{utf8}
El primer ejemplo es una lista de cuatro enteros, la segunda, una
lista de tres cadenas. Los elementos de una lista no tienen que tener
el mismo tipo. La siguiente lista contiene una cadena, un flotante,
un entero y (mirabile dictu) otra lista:\inputencoding{latin9}
\begin{lstlisting}
["hola", 2.0, 5, [10, 20]]
\end{lstlisting}
\inputencoding{utf8}
Cuando una lista est√° contenida por otra se dice que est√° \textbf{anidada}.

\index{lista!anidada}

Las listas que contienen enteros consecutivos son muy comunes, as√≠
que Python proporciona una forma de crearlas:\inputencoding{latin9}
\begin{lstlisting}
>>> list(range(1,5))
[1, 2, 3, 4]
\end{lstlisting}
\inputencoding{utf8}
La funci√≥n \texttt{range} toma dos argumentos y retorna una colecci√≥n
que contiene todos los enteros desde el primero hasta el segundo,
¬°incluyendo el primero y no el √∫ltimo! Esta colecci√≥n se puede convertir
a lista con la funci√≥n  \texttt{ list }

Hay otras formas de usar a \texttt{range}. Con un solo argumento crea
una lista que empieza en 0:\inputencoding{latin9}
\begin{lstlisting}
>>> list(range(10))
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
\end{lstlisting}
\inputencoding{utf8}
Si hay un tercer argumento, este especifica el espacio entre los valores
sucesivos, que se denomina el \textbf{tama√±o del paso}. Este ejemplo
cuenta de 1 a 10 con un paso de tama√±o 2:\inputencoding{latin9}
\begin{lstlisting}
>>> list(range(1, 10, 2))
[1, 3, 5, 7, 9]
\end{lstlisting}
\inputencoding{utf8}
Finalmente, existe una lista especial que no contiene elementos. Se
denomina lista vac√≠a, y se denota con \texttt{{[}{]}}.

Con todas estas formas de crear listas ser√≠a decepcionante si no pudi√©ramos
asignar listas a variables o pasarlas como par√°metros a funciones.
De hecho, podemos hacerlo:\inputencoding{latin9}
\begin{lstlisting}
>>> vocabulario = ["mejorar", "castigar", "derrocar"]
>>> numeros = [17, 123]
>>> vacia = []
>>> print(vocabulario, numeros, vacia)
["mejorar", "castigar", "derrocar"] [17, 123] []
\end{lstlisting}
\inputencoding{utf8}
\section{Accediendo a los elementos}

\index{lista!elemento} \index{acceso}

La sintaxis para acceder a los elementos de una lista es la misma
que usamos en las cadenas‚Äîel operador corchete (\texttt{{[}{]}}).
La expresi√≥n dentro de los corchetes especifica el √≠ndice. Recuerde
que los √≠ndices o posiciones empiezan desde 0:\inputencoding{latin9}
\begin{lstlisting}
print(numeros[0])
numeros[1] = 5
\end{lstlisting}
\inputencoding{utf8}
El operador corchete para listas puede aparecer en cualquier lugar
de una expresi√≥n. Cuanto aparece al lado izquierdo de una asignaci√≥n
cambia uno de los elementos de la lista de forma que el elemento 1
de \texttt{numeros}, que ten√≠a el valor 123, ahora es 5.

Cualquier expresi√≥n entera puede usarse como √≠ndice:\inputencoding{latin9}
\begin{lstlisting}
>>> numeros[3-2]
5
>>> numeros[1.0]
TypeError: sequence index must be integer
\end{lstlisting}
\inputencoding{utf8}
Si usted intenta leer o escribir un elemento que no existe, obtiene
un error en tiempo de ejecuci√≥n:

\index{error en tiempo de ejecuci√≥n}\inputencoding{latin9}
\begin{lstlisting}
>>> numeros[2] = 5
IndexError: list assignment index out of range
\end{lstlisting}
\inputencoding{utf8}
Si el √≠ndice tiene un valor negativo, cuenta hacia atr√°s desde el
final de la lista:\inputencoding{latin9}
\begin{lstlisting}
>>> numeros[-1]
5
>>> numeros[-2]
17
>>> numeros[-3]
IndexError: list index out of range
\end{lstlisting}
\inputencoding{utf8}
\texttt{numeros{[}-1{]}} es el √∫ltimo elemento de la lista, \texttt{numeros{[}-2{]}}
es el pen√∫ltimo, y \texttt{numeros{[}-3{]}} no existe.

Usualmente se usan variables de ciclo como √≠ndices de listas:\inputencoding{latin9}
\begin{lstlisting}
combatientes = ["guerra", "hambruna", "peste", "muerte"]

i = 0
while i < 4:
  print(combatientes[i])
  i = i + 1
\end{lstlisting}
\inputencoding{utf8}
Este ciclo \texttt{while} cuenta de 0 a 4. Cuando la variable de ciclo
\texttt{i} es 4, la condici√≥n falla y el ciclo termina. El cuerpo
del ciclo se ejecuta solamente cuando \texttt{i} es 0, 1, 2, y 3.

En cada iteraci√≥n del ciclo, la variable \texttt{i} se usa como un
√≠ndice a la lista, imprimiendo el \texttt{i}-√©simo elemento. Este
patr√≥n se denomina \textbf{recorrido de una lista}.

\index{lista!recorrido de una} \index{recorrido!lista}

\section{Longitud de una lista}

\index{longitud} \index{lista!longitud}

La funci√≥n \texttt{len} retorna la longitud de una lista. Es una buena
idea usar este valor como l√≠mite superior de un ciclo en vez de una
constante. De √©sta forma, si la lista cambia, usted no tendr√° que
cambiar todos los ciclos del programa, ellos funcionar√°n correctamente
para listas de cualquier tama√±o:\inputencoding{latin9}
\begin{lstlisting}
combatientes = ["guerra", "hambruna", "peste", "muerte"]

i = 0
while i < len(combatientes):
  print(combatientes[i])
  i = i + 1
\end{lstlisting}
\inputencoding{utf8}
La √∫ltima vez que el ciclo se ejecuta \texttt{i} es \texttt{len(combatientes)
- 1}, que es la posici√≥n del √∫ltimo elemento. Cuando \texttt{i} es
igual a \texttt{len(combatientes)}, la condici√≥n falla y el cuerpo
no se ejecuta, lo que est√° muy bien , ya que \texttt{len(combatientes)}
no es un √≠ndice v√°lido.

Aunque una lista puede contener a otra, la lista anidada se sigue
viendo como un elemento √∫nico. La longitud de esta lista es cuatro:\inputencoding{latin9}
\begin{lstlisting}
['basura!', 1, ['Brie', 'Roquefort', 'Pol le Veq'], 
 [1, 2, 3]]
\end{lstlisting}
\inputencoding{utf8}
\section{Pertenencia}

\index{lista!pertenencia} \index{operador in} \index{operador!in}

\texttt{in} es un operador booleano que chequea la pertenencia de
un valor a una secuencia. Lo usamos en la Secci√≥n~\ref{in} con cadenas,
pero tambi√©n funciona con listas y otras secuencias:\inputencoding{latin9}
\begin{lstlisting}
>>> combatientes = ["guerra", "hambruna", "peste", "muerte"]
>>> 'peste' in combatientes
True
>>> 'corrupcion' in combatientes
False
\end{lstlisting}
\inputencoding{utf8}
Ya que ``peste'' es un miembro de la lista \texttt{combatientes},
el operador \texttt{in} retorna cierto. Como ``corrupcion'' no est√°
en la lista, \texttt{in} retorna falso.

Podemos usar el operador l√≥gico \texttt{not} en combinaci√≥n con el
\texttt{in} para chequear si un elemento no es miembro de una lista:\inputencoding{latin9}
\begin{lstlisting}
>>> 'corrupcion' not in combatientes
True
\end{lstlisting}
\inputencoding{utf8}
\section{Listas y ciclos \texttt{for}}

\index{ciclo for} \index{lista!ciclo for} \index{recorrido}

El ciclo \texttt{for} que vimos en la Secci√≥n~\ref{for} tambi√©n
funciona con listas. La sintaxis generalizada de un ciclo \texttt{for}
es:\inputencoding{latin9}
\begin{lstlisting}
for VARIABLE in LISTA:
  CUERPO
\end{lstlisting}
\inputencoding{utf8}
Esto es equivalente a:\inputencoding{latin9}
\begin{lstlisting}
i = 0
while i < len(LISTA):
  VARIABLE = LISTA[i]
  CUERPO
  i = i + 1
\end{lstlisting}
\inputencoding{utf8}
El ciclo \texttt{for} es m√°s conciso porque podemos eliminar la variable
de ciclo \texttt{i}. Aqu√≠ est√° el ciclo de la secci√≥n anterior escrito
con un \texttt{for} en vez de un while: \inputencoding{latin9}
\begin{lstlisting}
for combatiente in combatientes:
  print(combatiente)
\end{lstlisting}
\inputencoding{utf8}
Casi se lee como en espa√±ol: ``Para (cada) combatiente en (la lista
de) combatientes, imprima (el nombre del) combatiente''.

Cualquier expresi√≥n que cree una lista puede usarse en un ciclo \texttt{for}:\inputencoding{latin9}
\begin{lstlisting}
for numero in range(20):
  if numero % 2 == 0:
    print(numero)

for fruta in ["banano", "manzana", "pera"]:
  print("Me gustaria comer " + fruta + "s!")
\end{lstlisting}
\inputencoding{utf8}
El primer ejemplo imprime todos los n√∫meros pares entre uno y diecinueve.
El segundo expresa entusiasmo sobre varias frutas.

\section{Operaciones sobre listas}

\index{operaciones sobre listas} \index{operaci√≥n!sobre listas}

El operador \texttt{+} concatena listas:

\index{concatenaci√≥n!de listas}\inputencoding{latin9}
\begin{lstlisting}
>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> c = a + b
>>> print(c)
[1, 2, 3, 4, 5, 6]
\end{lstlisting}
\inputencoding{utf8}
Similarmente, el operador \texttt{{*}} repite una lista un n√∫mero
de veces determinado:

\index{repetici√≥n!de listas}\inputencoding{latin9}
\begin{lstlisting}
>>> [0] * 4
[0, 0, 0, 0]
>>> [1, 2, 3] * 3
[1, 2, 3, 1, 2, 3, 1, 2, 3]
\end{lstlisting}
\inputencoding{utf8}
El primer ejemplo repite \texttt{{[}0{]}} cuatro veces. El segundo
repite \texttt{{[}1, 2, 3{]}} tres veces.

\section{Segmentos de listas}

\index{segmento} \index{lista!segmento}

Las operaciones para sacar segmentos de cadenas que vimos en la Secci√≥n~\ref{slice}
tambi√©n funcionan con listas:\inputencoding{latin9}
\begin{lstlisting}
>>> lista = ['a', 'b', 'c', 'd', 'e', 'f']
>>> lista[1:3]
['b', 'c']
>>> lista[:4]
['a', 'b', 'c', 'd']
>>> lista[3:]
['d', 'e', 'f']
>>> lista[:]
['a', 'b', 'c', 'd', 'e', 'f']
\end{lstlisting}
\inputencoding{utf8}
\section{Las listas son mutables}

\index{mutable!lista} \index{lista!mutable}

Las listas son mutables y no tienen la restricci√≥n de las cadenas,
esto quiere decir que podemos cambiar los elementos internos usando
el operador corchete al lado izquierdo de una asignaci√≥n.\inputencoding{latin9}
\begin{lstlisting}
>>> fruta = ["banano", "manzana", "pera"]
>>> fruta[0] = "mandarina"
>>> fruta[-1] = "naranja"
>>> print(fruta)
['mandarina', 'manzana', 'naranja']
\end{lstlisting}
\inputencoding{utf8} Con el operador segmento podemos actualizar varios elementos a la
vez:\inputencoding{latin9}
\begin{lstlisting}
>>> lista = ['a', 'b', 'c', 'd', 'e', 'f']
>>> lista[1:3] = ['x', 'y']
>>> print(lista)
['a', 'x', 'y', 'd', 'e', 'f']
\end{lstlisting}
\inputencoding{utf8}
Tambi√©n podemos eliminar varios elementos asign√°ndoles la lista vac√≠a:\inputencoding{latin9}
\begin{lstlisting}
>>> lista = ['a', 'b', 'c', 'd', 'e', 'f']
>>> lista[1:3] = []
>>> print(lista)
['a', 'd', 'e', 'f']
\end{lstlisting}
\inputencoding{utf8}
Igualmente, podemos agregar elementos a una lista apret√°ndolos dentro
de un segmento vac√≠o en la posici√≥n que deseamos:\inputencoding{latin9}
\begin{lstlisting}
>>> lista = ['a', 'd', 'f']
>>> lista[1:1] = ['b', 'c']
>>> print(lista)
['a', 'b', 'c', 'd', 'f']
>>> lista[4:4] = ['e']
>>> print(lista)
['a', 'b', 'c', 'd', 'e', 'f']
\end{lstlisting}
\inputencoding{utf8}
\section{Otras operaciones sobre listas}

\index{operaci√≥n sobre listas}

Usar segmentos para insertar y borrar elementos de una lista es extra√±o
y propenso a errores. Hay mecanismos alternativos m√°s legibles como
\texttt{del} que elimina un elemento de una lista.

\index{borrado!en listas} \index{borrado en listas} \index{del}\inputencoding{latin9}
\begin{lstlisting}
>>> a = ['one', 'two', 'three']
>>> del a[1]
>>> a
['one', 'three']
\end{lstlisting}
\inputencoding{utf8}
Como es de esperar, \texttt{del} recibe √≠ndices negativos, y causa
errores en tiempo de ejecuci√≥n si el √≠ndice est√° fuera de rango.

Tambi√©n se puede usar un segmento como argumento a \texttt{del}:\inputencoding{latin9}
\begin{lstlisting}
>>> lista = ['a', 'b', 'c', 'd', 'e', 'f']
>>> del lista[1:5]
>>> print(lista)
['a', 'f']
\end{lstlisting}
\inputencoding{utf8}
Como de costumbre, los segmentos seleccionan todos los elementos hasta
el segundo √≠ndice, sin incluirlo.

La funci√≥n \texttt{append} agrega un elemento (o una lista) al final
de una lista existente:\inputencoding{latin9}
\begin{lstlisting}
>>> a = ['uno', 'dos']
>>> a.append('tres')
>>> print(a)
\end{lstlisting}
\inputencoding{utf8}
Observe que se llama con la notaci√≥n punto, a diferencia de \texttt{len}
y \texttt{del}.

\section{Objetos y valores}

\index{objeto} \index{valor}

Si ejecutamos estas asignaciones\inputencoding{latin9}
\begin{lstlisting}
a = "banana"
b = "banana"
\end{lstlisting}
\inputencoding{utf8}
sabemos que \texttt{a} y \texttt{b} se referir√°n a una cadena con
las letras \texttt{``banana''}. Pero no podemos afirmar que sea
la {\em misma} cadena.

Hay dos situaciones posibles:

\beforefig \centerline{\includegraphics{illustrations/list1}}
\afterfig

En un caso, \texttt{a} y \texttt{b} se refieren a cosas distintas
que tienen el mismo valor. En el segundo caso, se refieren a la misma
cosa. Estas ``cosas'' tienen nombres‚Äîse denominan \textbf{objetos}.
Un objeto es algo a lo que se puede referir una variable.

Cada objeto tiene un \textbf{identificador} √∫nico, que podemos obtener
con la funci√≥n \texttt{id}. Imprimiendo el identificador de \texttt{a}
y \texttt{b}, podemos saber si se refieren al mismo objeto.\inputencoding{latin9}
\begin{lstlisting}
>>> id(a)
135044008
>>> id(b)
135044008
\end{lstlisting}
\inputencoding{utf8}
De hecho, obtenemos el mismo identificador dos veces, lo que nos dice
que Python s√≥lo cre√≥ una cadena, y que \texttt{a} y \texttt{b} se
refieren a ella.

Las listas, por otro lado, se comportan de manera diferente. Cuando
creamos dos listas obtenemos dos objetos:\inputencoding{latin9}
\begin{lstlisting}
>>> a = [1, 2, 3]
>>> b = [1, 2, 3]
>>> id(a)
135045528
>>> id(b)
135041704
\end{lstlisting}
\inputencoding{utf8}
As√≠ que el diagrama de estados luce as√≠:

\beforefig \centerline{\includegraphics{illustrations/list2}}
\afterfig

\texttt{a} y \texttt{b} tienen el mismo valor pero no se refieren
al mismo objeto.

\section{Alias}

\index{alias} \index{referencia!alias}

Como las variables se pueden referir a objetos, si asignamos una variable
a otra, las dos se referir√°n al mismo objeto:\inputencoding{latin9}
\begin{lstlisting}
>>> a = [1, 2, 3]
>>> b = a
\end{lstlisting}
\inputencoding{utf8}
En este caso el diagrama de estados luce as√≠:

\beforefig \centerline{\includegraphics{illustrations/list3}}
\afterfig

Como la misma lista tiene dos nombres distintos, \texttt{a} y \texttt{b},
podemos decir que b es un \textbf{alias} de a. Los cambios que se
hagan a trav√©s de un alias afectan al otro:\inputencoding{latin9}
\begin{lstlisting}
>>> b[0] = 5
>>> print(a)
[5, 2, 3]
\end{lstlisting}
\inputencoding{utf8}
Aunque este comportamiento puede ser √∫til, algunas veces puede ser
indeseable. En general, es m√°s seguro evitar los alias cuando se est√°
trabajando con objetos mutables. Para objetos inmutables no hay problema.
Esta es la raz√≥n por la que Python tiene la libertad de crear alias
a cadenas cuando ve la oportunidad de economizar memoria. Pero tenga
en cuenta que esto puede variar en las diferentes versiones de Python;
por lo tanto no es recomendable realizar programas que dependan de
este comportamiento.

\section{Clonando listas}

\index{lista!clonando} \index{clonando}

Si queremos modificar una lista y conservar una copia de la original,
necesitamos realizar una copia de la lista, no s√≥lo de la referencia.
Este proceso se denomina \textbf{clonaci√≥n}, para evitar la ambig√ºedad
de la palabra ``copiar''.

La forma m√°s sencilla de clonar una lista es usar el operador segmento:\inputencoding{latin9}
\begin{lstlisting}
>>> a = [1, 2, 3]
>>> b = a[:]
>>> print(b)
[1, 2, 3]
\end{lstlisting}
\inputencoding{utf8}
Al tomar cualquier segmento de \texttt{a} creamos una nueva lista.
En este caso el segmento comprende toda la lista.

Ahora podemos realizar cambios a \texttt{b} sin preocuparnos por \texttt{a}:\inputencoding{latin9}
\begin{lstlisting}
>>> b[0] = 5
>>> print(a)
[1, 2, 3]
\end{lstlisting}
\inputencoding{utf8}
¬øComo ser√≠a un diagrama de estados para \texttt{a} y \texttt{b} antes
y despu√©s de este cambio? 

\section{Listas como par√°metros}

\index{listas!como par√°metros} \index{par√°metro} \index{par√°metro!lista}

Pasar una lista como argumento es pasar un alias (o una referencia),
no una copia de ella. Por ejemplo, la funci√≥n \texttt{cabeza} toma
una lista como par√°metro y retorna el primer elemento:\inputencoding{latin9}
\begin{lstlisting}
def cabeza(lista):
  return lista[0]
\end{lstlisting}
\inputencoding{utf8}
Se puede usar as√≠:\inputencoding{latin9}
\begin{lstlisting}
>>> numeros = [1, 2, 3]
>>> cabeza(numeros)
1
\end{lstlisting}
\inputencoding{utf8}
El par√°metro \texttt{lista} y la variable \texttt{numeros} son alias
para el mismo objeto. El diagrama de estados luce as√≠:

\beforefig \centerline{\includegraphics{illustrations/stack5}}
\afterfig

Como el objeto lista est√° compartido por dos marcos, lo dibujamos
en el medio.

Si una funci√≥n modifica un par√°metro de tipo lista, el que hizo el
llamado ve los cambios. Por ejemplo, \texttt{borrarCabeza} borra el
primer elemento de una lista:\inputencoding{latin9}
\begin{lstlisting}
def borrarCabeza(lista):
  del lista[0]
\end{lstlisting}
\inputencoding{utf8}
Y se puede usar as√≠::\inputencoding{latin9}
\begin{lstlisting}
>>> numeros = [1, 2, 3]
>>> borrarCabeza(numeros)
>>> print(numeros)
[2, 3]
\end{lstlisting}
\inputencoding{utf8}
Si una funci√≥n retorna una lista, retorna una referencia a ella. Por
ejemplo, la funci√≥n \texttt{cola} retorna una lista que contiene todos
los elementos, excepto el primero:\inputencoding{latin9}
\begin{lstlisting}
def cola(lista):
  return lista[1:]
\end{lstlisting}
\inputencoding{utf8}
\texttt{cola} se puede usar as√≠:\inputencoding{latin9}
\begin{lstlisting}
>>> numeros = [1, 2, 3]
>>> resto = cola(numeros)
>>> print(resto)
[2, 3]
\end{lstlisting}
\inputencoding{utf8}
Como el valor de retorno se cre√≥ con el operador segmento, es una
nueva lista. La creaci√≥n de \texttt{resto}, y los cambios subsecuentes
sobre esta variable no tienen efecto sobre \texttt{numeros}.

\section{Listas anidadas}

\label{nested lists} \index{listas anidadas} \index{lista!anidada}

Una lista anidada aparece como elemento dentro de otra lista. En la
siguiente lista, el tercer elemento es una lista anidada:\inputencoding{latin9}
\begin{lstlisting}
>>> lista = ["hola", 2.0, 5, [10, 20]]
\end{lstlisting}
\inputencoding{utf8}
Si imprimimos \texttt{lista{[}3{]}}, vemos \texttt{{[}10, 20{]}}.
Para tomar un elemento de la lista anidada podemos realizar dos pasos:\inputencoding{latin9}
\begin{lstlisting}
>>> elt = lista[3]
>>> elt[0]
10
\end{lstlisting}
\inputencoding{utf8} O, los podemos combinar:\inputencoding{latin9}
\begin{lstlisting}
>>> lista[3][1]
20
\end{lstlisting}
\inputencoding{utf8}
Las aplicaciones del operador corchete se eval√∫an de izquierda a derecha,
as√≠ que √©sta expresi√≥n obtiene el elemento 3 de \texttt{lista} y extrae
de all√≠ el elemento 1.

\section{Matrices}

\index{matriz} \index{lista!anidada}

Las listas anidadas se usan a menudo para representar matrices. Por
ejemplo, la matriz:

\beforefig \centerline{\includegraphics{illustrations/matrix}}
\afterfig

se puede representar as√≠:\inputencoding{latin9}
\begin{lstlisting}
>>> matriz = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
\end{lstlisting}
\inputencoding{utf8}
\texttt{matriz} es una lista con tres elementos, cada uno es una fila.
Podemos seleccionar una fila de la manera usual:\inputencoding{latin9}
\begin{lstlisting}
>>> matriz[1]
[4, 5, 6]
\end{lstlisting}
\inputencoding{utf8}
O podemos extraer un elemento individual de la matriz usando dos √≠ndices:\inputencoding{latin9}
\begin{lstlisting}
>>> matriz[1][1]
5
\end{lstlisting}
\inputencoding{utf8}
El primero escoge la fila, y el segundo selecciona la columna. Aunque
esta forma de representar matrices es com√∫n, no es la √∫nica posibilidad.
Una peque√±a variaci√≥n consiste en usar una lista de columnas en lugar
de una lista de filas. M√°s adelante veremos una alternativa m√°s radical,
usando un diccionario.

\index{diccionario} \index{fila} \index{columna}

\section{Cadenas y listas}

\index{funci√≥n split} \index{funci√≥n join}

Dos de las funciones m√°s usadas de las cadenas implican listas de
cadenas. \texttt{split} separa una cadena en una lista de palabras.
Por defecto, cualquier n√∫mero de espacios en blanco sirven como criterio
de separaci√≥n:
\begin{verbatim}
>>> cancion = "La vida es un ratico..."
>>> str.split(cancion)
['La', 'vida', 'es', 'un', 'ratico...']
\end{verbatim}
Un argumento opcional denominado \textbf{delimitador} se puede usar
para especificar que caracteres usar como criterio de separaci√≥n.
El siguiente ejemplo usa la cadena \texttt{an} como delimitador:\inputencoding{latin9}
\begin{lstlisting}
>>> str.split( "La rana que canta", "an")
['La r', 'a que c', 'ta']
\end{lstlisting}
\inputencoding{utf8}
Note que el delimitador no aparece en la lista resultante.

La funci√≥n \texttt{join} es la inversa de \texttt{split}. Toma una
lista de cadenas y las concatena usando como separador a la cadena
que la llama con notaci√≥n punto:\inputencoding{latin9}
\begin{lstlisting}
>>> m = ['La', 'vida', 'es', 'un', 'ratico']
>>> " ".join(m)
'La vida es un ratico'
\end{lstlisting}
\inputencoding{utf8}
Si usamos una cadena diferente de espacio, obtenemos otro resultado:\inputencoding{latin9}
\begin{lstlisting}
>>> "_".join(m)
'La_vida_es_un_ratico'
\end{lstlisting}
\inputencoding{utf8}
\section{Glosario}
\begin{description}
\item [{Lista:}] colecci√≥n de objetos que recibe un nombre. Cada objeto
se identifica con un √≠ndice o n√∫mero entero positivo.
\item [{√çndice:}] valor o variable entero que indica la posici√≥n de un
elemento en una lista.
\item [{Elemento:}] uno de los valores dentro de una lista (u otra secuencia).
El operador corchete selecciona elementos de una lista.
\item [{Secuencia:}] los tipos de datos que contienen un conjunto ordenado
de elementos, identificados por √≠ndices.
\item [{Lista anidada:}] lista que es elemento de otra lista.
\item [{Recorrido de una lista:}] es el acceso secuencial de cada elemento
de una lista.
\item [{Objeto:}] una cosa a la que una variable se puede referir.
\item [{Alias:}] cuando varias variables tienen referencias hacia el mismo
objeto.
\item [{Clonar:}] crear un objeto con el mismo valor que un objeto preexistente.
Copiar una referencia a un objeto crea un alias, pero no clona el
objeto.
\item [{Delimitador:}] car√°cter o cadena que se usa para indicar el lugar
donde una cadena debe ser separada.

\index{lista} \index{√≠ndice} \index{secuencia} \index{elemento}
\index{lista anidada} \index{recorrido de una lista} \index{objeto}
\index{alias} \index{clonar} \index{delimitador}
\end{description}

\section{Ejercicios}

Para cada funci√≥n, agregue chequeo de tipos y pruebas unitarias.
\begin{enumerate}
\item Escriba una funci√≥n llamada medio que reciba una lista y retorne una
nueva lista que contenga todos los elementos de la lista de entrada
excepto el primero y el √∫ltimo. Por ejemplo, medio({[}1,2,3,4{]})
debe retornar {[}2,3{]}.
\item Escriba una funci√≥n llamada cortar que reciba una lista y la modifique
eliminando el primer y el √∫ltimo elemento, retornando None.
\item Escriba una funci√≥n que recorra una lista de cadenas imprimiendo la
longitud de cada una. ¬øQu√© pasa si usted le pasa un entero a \texttt{len}?
\item Describa la relaci√≥n entre las expresiones:

\texttt{cadena} \hfill{}\texttt{' '.join(str.split(cadena))}

¬øSon iguales para todas las cadenas?

¬øCuando ser√≠an diferentes?
\item Escriba una funci√≥n llamada \verb+esta_ordenada+ que tome una lista
como par√°metro y retorne True si la lista est√° ordenada de forma ascendente
o False si no lo est√°. Usted puede asumir como precondici√≥n que los
elementos son comparables con los operadores relacionales. Por ejemplo:

\verb+esta_ordenada([1,2,2])+ debe retornar True

\verb+esta_ordenada(['b','a'])+ debe retornar False.
\item Dos palabras son anagramas si se pueden reordenar las letras de una
palabra para formar la otra. Escriba una funci√≥n llamada \verb+es_anagrama+
que tome dos cadenas y retorne True si son anagramas y False en caso
contrario.
\item Escriba una funci√≥n llamada \verb+eliminar_duplicados+ que reciba
una lista y retorne una nueva lista con los elementos √∫nicos de la
original. No necesitan estar en el mismo orden.
\item Escriba dos versiones de una funci√≥n que lea el archivo palabras.txt
y construya una lista con un elemento por palabra. Una versi√≥n usar√°
el m√©todo append y la otra la construcci√≥n t=t+{[}x{]}. ¬øCual es mas
lenta? ¬øPor qu√©? Pista: use el m√≥dulo time para medir lo que tarda
la ejecuci√≥n de las versiones.

palabras.txt: \url{https://github.com/abecerra/thinkcs-py_es/releases/download/thinkcs-py_es_e2-rc1/palabras.txt}

Soluci√≥n: \url{http://thinkpython.com/code/wordlist.py}
\item Si hay un grupo de 23 personas, ¬øcual es la probabilidad de que dos
tengan la misma fecha de nacimiento?. Este valor puede estimarse generando
muestras aleatorias de 23 cumplea√±os y contando las coincidencias.
Pista: consulte la funci√≥n randint del m√≥dulo random.

Soluci√≥n: \url{http://thinkpython.com/code/birthday.py}
\item Dos palabras son un ``par inverso'' si cada una es la inversa de
la otra. Escriba un programa que encuentre todos los pares inversos
del espa√±ol (palabras.txt).

Soluci√≥n: \url{http://thinkpython.com/code/reverse_pair.py}
\item Dos palabras se entretejen si tomando las letras de las dos, altern√°ndose,
se puede formar una nueva palabra. Por ejemplo: 'pie' y 'en' se entretejen
en 'peine'.

Soluci√≥n: \url{http://thinkpython.com/code/interlock.py} 
\end{enumerate}

\end{document}
