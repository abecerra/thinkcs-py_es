
\chapter{Funciones fruct铆feras }

\label{funcReturn}

\section{Valores de retorno}

\index{valor de retorno}

Algunas de las funciones primitivas que hemos usado, como las matem谩ticas,
entregan resultados. El llamar a estas funciones genera un valor nuevo,
que usualmente asignamos a una variable o usamos como parte de una
expresi贸n.\inputencoding{latin9}
\begin{lstlisting}
e = math.exp(1.0)
altura = radio * math.sin(angulo)
\end{lstlisting}
\inputencoding{utf8}
Pero hasta ahora ninguna de las funciones que hemos escrito ha retornado
un valor.

En este cap铆tulo vamos a escribir funciones que retornan valores,
los cuales denominamos \textbf{funciones fruct铆feras}, o provechosas\footnote{En algunos libros de programaci贸n, las \textit{funciones} que desarrollamos
en el cap铆tulo anterior se denominan \textit{procedimientos} y las
que veremos en este cap铆tulo s铆 se denominan \textit{funciones}, ya
que los lenguajes de programaci贸n usados para ense帽ar (como Pascal)
hac铆an la distinci贸n. Muchos lenguajes de programaci贸n vigentes (incluido
Python y C) no diferencian sint谩cticamente entre procedimientos y
funciones, por eso usamos esta terminolog铆a.}. El primer ejemplo es \texttt{area}, que retorna el 谩rea de un c铆rculo
dado su radio:\inputencoding{latin9}
\begin{lstlisting}
import math

def area(radio):
  temp = math.pi * radio**2
  return temp
\end{lstlisting}
\inputencoding{utf8}
Ya nos hab铆amos topado con la sentencia \texttt{return} antes, pero,
en una funci贸n fruct铆fera, la sentencia \texttt{return} incluye un
\textbf{valor de retorno}. Esta sentencia significa: ``Retorne inmediatamente
de esta funci贸n y use la siguiente expresi贸n como un valor de retorno.''
La expresi贸n proporcionada puede ser arbitrariamente compleja, as铆
que podr铆amos escribir esta funci贸n m谩s concisamente:

\inputencoding{latin9}\begin{lstlisting}
def area(radio):
  return math.pi * radio**2
\end{lstlisting}
\inputencoding{utf8} 

Por otro lado, las \textbf{variables temporales}, como \texttt{temp},
a menudo permiten depurar los programas m谩s f谩cilmente.

\index{variable temporal} \index{variable!temporal}

Algunas veces es muy 煤til tener m煤ltiples sentencias return, ubicadas
en ramas distintas de un condicional:

\inputencoding{latin9}\begin{lstlisting}
def valorAbsoluto(x):
  if x < 0:
    return -x
  else:
    return x
\end{lstlisting}
\inputencoding{utf8}
Ya que estas sentencias \texttt{return} est谩n en un condicional alternativo,
s贸lo una ser谩 ejecutada. Tan pronto como esto suceda, la funci贸n termina
sin ejecutar las sentencias que siguen.

El c贸digo que aparece despu茅s de la sentencia \texttt{return}, o en
un lugar que el flujo de ejecuci贸n nunca puede alcanzar, se denomina
\textbf{c贸digo muerto}.

\index{c贸digo muerto}

En una funci贸n fruct铆fera es una buena idea garantizar que toda ruta
posible de ejecuci贸n del programa llegue a una sentencia \texttt{return}.
Por ejemplo:

\inputencoding{latin9}\begin{lstlisting}
def valorAbsoluto(x):
  if x < 0:
    return -x
  elif x > 0:
    return x
\end{lstlisting}
\inputencoding{utf8} Este programa no es correcto porque si \texttt{x} llega a ser 0,
ninguna condici贸n es cierta y la funci贸n puede terminar sin alcanzar
una sentencia \texttt{return}. En este caso el valor de retorno que
Python entrega es un valor especial denominado \texttt{None}:

\index{None}\inputencoding{latin9}
\begin{lstlisting}
>>> print(valorAbsoluto(0))
None
\end{lstlisting}
\inputencoding{utf8}
\section{Desarrollo de programas}

\label{program development} \index{andamiaje}

En este momento usted deber铆a ser capaz de leer funciones completas
y deducir lo que hacen. Tambi茅n, si ha realizado los ejercicios, ya
ha escrito algunas funciones peque帽as. A medida en que usted escriba
funciones m谩s grandes puede empezar a tener una dificultad mayor,
especialmente con los errores sem谩nticos y de tiempo de ejecuci贸n.

Para desarrollar programas cada vez m谩s complejos, vamos a sugerir
una t茅cnica denominada \textbf{desarrollo incremental}. El objetivo
del desarrollo incremental es evitar largas sesiones de depuraci贸n
mediante la adici贸n y prueba de una peque帽a cantidad de c贸digo en
cada paso.

\index{desarrollo incremental} \index{desarrollo!incremental}

Como ejemplo, suponga que usted desea hallar la distancia entre dos
puntos dados por las coordenadas $(x_{1},y_{1})$ y $(x_{2},y_{2})$.
Por el teorema de Pit谩goras, la distancia se calcula con:

\begin{equation}
distancia=\sqrt{(x_{2}-x_{1})^{2}+(y_{2}-y_{1})^{2}}
\end{equation}
El primer paso es considerar c贸mo lucir铆a la funci贸n \texttt{distancia}
en Python. En otras palabras, 驴cuales son las entradas (par谩metros)
y cual es la salida (valor de retorno)?

En este caso, los dos puntos son las entradas, que podemos representar
usando cuatro par谩metros. El valor de retorno es la distancia, que
es un valor de punto flotante.

Ya podemos escribir un borrador de la funci贸n:

\inputencoding{latin9}\begin{lstlisting}
def distancia(x1, y1, x2, y2):
  return 0.0
\end{lstlisting}
\inputencoding{utf8} Obviamente, esta versi贸n de la funci贸n no calcula distancias; siempre
retorna cero. Pero es correcta sint谩cticamente y puede correr, lo
que implica que la podemos probar antes de que la hagamos m谩s compleja.

Para probar la nueva funci贸n la llamamos con valores simples:

\inputencoding{latin9}\begin{lstlisting}
>>> distancia(1, 2, 4, 6)
0.0
\end{lstlisting}
\inputencoding{utf8} Escogemos estos valores de forma que la distancia horizontal sea
3 y la vertical 4; de esta forma el resultado es 5 (la hipotenusa
de un tri谩ngulo con medidas 3-4-5). Cuando probamos una funci贸n es
fundamental conocer algunas respuestas correctas.

En este punto hemos confirmado que la funci贸n est谩 bien sint谩cticamente,
y que podemos empezar a agregar l铆neas de c贸digo. Despu茅s de cada
cambio, probamos la funci贸n otra vez. Si hay un error, sabemos d贸nde
debe estar en la 煤ltima l铆nea que agregamos.

Un primer paso l贸gico en este c贸mputo es encontrar las diferencias
$x_{2}-x_{1}$ y $y_{2}-y_{1}$. Almacenaremos estos valores en variables
temporales llamadas \texttt{dx} y \texttt{dy} y los imprimiremos.

\inputencoding{latin9}\begin{lstlisting}
def distancia(x1, y1, x2, y2):
  dx = x2 - x1
  dy = y2 - y1
  print("dx es", dx)
  print("dy es", dy)
  return 0.0
\end{lstlisting}
\inputencoding{utf8} Si la funci贸n trabaja bien, las salidas deben ser 3 y 4. Si es as铆,
sabemos que la funci贸n est谩 obteniendo los par谩metros correctos y
calculando el primer paso correctamente. Si no ocurre 茅sto, entonces
hay unas pocas l铆neas para chequear.

Ahora calculamos la suma de los cuadrados de \texttt{dx} y \texttt{dy}:

\inputencoding{latin9}\begin{lstlisting}
def distancia(x1, y1, x2, y2):
  dx = x2 - x1
  dy = y2 - y1
  discuadrado = dx**2 + dy**2
  print("discuadrado es: ", discuadrado)
  return 0.0
\end{lstlisting}
\inputencoding{utf8} Note que hemos eliminado las sentencias \texttt{print} que ten铆amos
en el paso anterior. Este c贸digo se denomina \textbf{andamiaje} porque
es 煤til para construir el programa pero no hace parte del producto
final.

De nuevo, corremos el programa y chequeamos la salida (que debe ser
25).

Finalmente, si importamos el m贸dulo math, podemos usar la funci贸n
\texttt{sqrt} para calcular y retornar el resultado:

\inputencoding{latin9}\begin{lstlisting}
def distancia(x1, y1, x2, y2):
  dx = x2 - x1
  dy = y2 - y1
  discuadrado = dx**2 + dy**2
  resultado = math.sqrt(discuadrado)
  return resultado
\end{lstlisting}
\inputencoding{utf8} Si esto funciona bien, usted ha terminado. Si no, se podr铆a imprimir
el valor de \texttt{resultado} antes de la sentencia return.

Recapitulando, para empezar, usted deber铆a agregar solamente una l铆nea
o dos cada vez.

A medida que gane m谩s experiencia podr谩 escribir y depurar trozos
mayores. De cualquier forma el proceso de desarrollo incremental puede
evitarle mucho tiempo de depuraci贸n.

Los aspectos claves del proceso son:
\begin{enumerate}
\item Empezar con un programa correcto y hacer peque帽os cambios incrementales.
Si en cualquier punto hay un error, usted sabr谩 exactamente donde
est谩.
\item Use variables temporales para almacenar valores intermedios de manera
que se puedan imprimir y chequear.
\item Ya que el programa est茅 corriendo, usted puede remover parte del andamiaje
o consolidar m煤ltiples sentencias en expresiones compuestas, pero
s贸lo si esto no dificulta la lectura del programa.
\end{enumerate}

\section{Composici贸n}

\index{composici贸n} \index{funci贸n!composici贸n}

Como usted esperar铆a, se puede llamar una funci贸n fruct铆fera desde
otra. Esta capacidad es la \textbf{composici贸n}.

Como ejemplo vamos a escribir una funci贸n que toma dos puntos: el
centro de un c铆rculo y un punto en el per铆metro, y que calcule el
谩rea total del c铆rculo.

Asuma que el punto central est谩 almacenado en las variables \texttt{xc}
y \texttt{yc}, y que el punto perimetral est谩 en \texttt{xp} y \texttt{yp}.
El primer paso es encontrar el radio del c铆rculo, que es la distancia
entre los dos puntos. Afortunadamente, hay una funci贸n, \texttt{distancia},
que hace eso:

\inputencoding{latin9}\begin{lstlisting}
radio = distancia(xc, yc, xp, yp)
\end{lstlisting}
\inputencoding{utf8}
El segundo paso es encontrar el 谩rea de un c铆rculo con dicho radio
y retornarla:

\inputencoding{latin9}\begin{lstlisting}
resultado = area(radio)
return resultado
\end{lstlisting}
\inputencoding{utf8} Envolviendo todo en una funci贸n obtenemos:

\inputencoding{latin9}\begin{lstlisting}
def area2(xc, yc, xp, yp):
  radio = distancia(xc, yc, xp, yp)
  resultado = area(radio)
  return resultado
\end{lstlisting}
\inputencoding{utf8}Llamamos a esta funci贸n \texttt{area2} para distinguirla de la funci贸n
\texttt{area} definida previamente. Solo puede haber una funci贸n con
un nombre dado dentro de un m贸dulo.

Las variables temporales \texttt{radio} y \texttt{area} son 煤tiles
para desarrollar y depurar, pero una vez que el programa est谩 funcionando
podemos hacer la funci贸n m谩s concisa componiendo las llamadas a funciones:

\inputencoding{latin9}\begin{lstlisting}
def area2(xc, yc, xp, yp):
  return area(distancia(xc, yc, xp, yp))
\end{lstlisting}
\inputencoding{utf8}
\section{Funciones booleanas}

\label{boolean} \index{funci贸n booleana} \index{funci贸n booleana}

Las funciones que pueden retornar un valor booleano son convenientes
para ocultar chequeos complicados adentro de funciones. Por ejemplo:

\inputencoding{latin9}\begin{lstlisting}
def esDivisible(x, y):
  if x % y == 0:
    return True       #  es cierto
  else:
    return False      # es falso
\end{lstlisting}
\inputencoding{utf8} El nombre de esta funci贸n es \texttt{esDivisible}. Es muy usual nombrar
las funciones booleanas con palabras o frases que suenan como preguntas
de s铆 o no (que tienen como respuesta un s铆 o un no). \texttt{esDivisible}
retorna \texttt{True} 贸 \texttt{False} para indicar si x es divisible
exactamente por y.

Podemos hacerla m谩s concisa tomando ventaja del hecho de que una condici贸n
dentro de una sentencia \texttt{if} es una expresi贸n booleana. Podemos
retornarla directamente, evitando completamente el \texttt{if}:

\inputencoding{latin9}\begin{lstlisting}
def esDivisible(x, y):
  return x % y == 0
\end{lstlisting}
\inputencoding{utf8} Esta sesi贸n muestra la nueva funci贸n en acci贸n:

\inputencoding{latin9}\begin{lstlisting}
>>>   esDivisible(6, 4)
False
>>>   esDivisible(6, 3)
True
\end{lstlisting}
\inputencoding{utf8}
Las funciones booleanas se usan a menudo en las sentencias condicionales:

\inputencoding{latin9}\begin{lstlisting}
if esDivisible(x, y):
  print("x es divisible por y")
else:
  print("x no es divisible por y")
\end{lstlisting}
\inputencoding{utf8} Puede parecer tentador escribir algo como:

\inputencoding{latin9}\begin{lstlisting}
if esDivisible(x, y) == True:
\end{lstlisting}
\inputencoding{utf8} Pero la comparaci贸n extra es innecesaria.

\section{M谩s recursi贸n}

\index{recursi贸n} \index{lenguaje completo} \index{lenguaje!completo}
\index{Turing, Alan} \index{Turing, T茅sis de}

Hasta aqu铆, usted s贸lo ha aprendido un peque帽o subconjunto de Python,
pero podr铆a interesarle saber que este subconjunto es un lenguaje
de programaci贸n {\em completo}, lo que quiere decir que cualquier
cosa que pueda ser calculada puede ser expresada en este subconjunto.
Cualquier programa escrito alguna vez puede ser reescrito usando solamente
las caracter铆sticas que usted ha aprendido hasta ahora (de hecho,
necesitar铆a algunos comandos mas para manejar dispositivos como el
teclado, el rat贸n, los discos, etc., pero eso ser铆a todo).

Demostrar esta afirmaci贸n no es un ejercicio trivial y fue logrado
por Alan Turing, uno de los primeros cient铆ficos de la computaci贸n
(algunos dir铆an que el era un matem谩tico, pero la mayor铆a de los cient铆ficos
pioneros de la computaci贸n eran matem谩ticos). Esto se conoce como
la Tesis de Turing. Si usted toma un curso de Teor铆a de la Computaci贸n
tendr谩 la oportunidad de ver la demostraci贸n.

Para darle una idea de lo que puede hacer con las herramientas que
ha aprendido, vamos a evaluar unas pocas funciones matem谩ticas definidas
recursivamente.

Una definici贸n recursiva es similar a una circular, ya que 茅stas contienen
una referencia al concepto que se pretende definir. Una definici贸n
circular verdadera no es muy 煤til:
\begin{description}
\item [{frabjuoso:}] un adjetivo usado para describir algo que es frabjuoso.
\end{description}
\index{frabjuoso} \index{definici贸n circular} \index{definici贸n!circular}

Si usted viera dicha definici贸n en el diccionario, quedar铆a confundido.
Por otro lado, si encontrara la definici贸n de la funci贸n factorial
hallar铆a algo como esto:

\vspace{-0.35in}
 
\begin{eqnarray*}
 &  & 0!=1\\
 &  & n!=n(n-1)!
\end{eqnarray*}
\vspace{-0.25in}

Esta definici贸n dice que el factorial de 0 es 1, y que el factorial
de cualquier otro valor, $n$, es $n$ multiplicado por el factorial
de $n-1$.

As铆 que $3!$ es 3 veces $2!$, que es 2 veces $1!$, que es 1 vez
$0!$. Juntando todo esto, $3!$ es igual a 3 veces 2 veces 1 vez
1, lo que da 6.

\index{funci贸n factorial} \index{funci贸n!factorial}

Si usted puede escribir una definici贸n recursiva para algo, usualmente
podr谩 escribir un programa para evaluarlo. El primer paso es decidir
cuales son los par谩metros para esta funci贸n. Con un poco de esfuerzo
usted concluir铆a que \texttt{factorial} recibe un 煤nico par谩metro:

\inputencoding{latin9}\begin{lstlisting}
def factorial(n):
\end{lstlisting}
\inputencoding{utf8}
Si el argumento es 0, todo lo que hacemos es retornar 1:

\inputencoding{latin9}\begin{lstlisting}
def factorial(n):
  if n == 0:
    return 1
\end{lstlisting}
\inputencoding{utf8} 

Sino, y 茅sta es la parte interesante, tenemos que hacer una llamada
recursiva para encontrar el factorial de $n-1$ y, entonces, multiplicarlo
por $n$:\inputencoding{latin9}
\begin{lstlisting}
def factorial(n):
  if n == 0:
    return 1
  else:
    recur = factorial(n-1)
    da = n * recur
    return da
\end{lstlisting}
\inputencoding{utf8}
El flujo de ejecuci贸n de este programa es similar al flujo de \texttt{conteo}
en la Secci贸n~\ref{recursion}. Si llamamos a \texttt{factorial}
con el valor 3:

\adjustpage{1}

Como 3 no es 0, tomamos la segunda rama y calculamos el factorial
de \texttt{n-1}...
\begin{quote}
Como 2 no es 0, tomamos la segunda rama y calculamos el factorial
de \texttt{n-1}...

\begin{quote}
Como 1 no es 0, tomamos la segunda rama y calculamos el factorial
de \texttt{n-1}...

\begin{quote}
Como 0 {\em es} 0, tomamos la primera rama y retornamos 1 sin hacer
m谩s llamados recursivos. 
\end{quote}
El valor de retorno (1) se multiplica por $n$, que es 1, y el resultado
se retorna. 
\end{quote}
El valor de retorno (1) se multiplica por $n$, que es 2, y el resultado
se retorna. 
\end{quote}
El valor de retorno (2) se multiplica por $n$, que es 3, y el resultado,
6, se convierte en el valor de retorno del llamado de funci贸n que
empez贸 todo el proceso.

As铆 queda el diagrama de pila para esta secuencia de llamados de funci贸n:

\vspace{0.1in}
 \beforefig \centerline{\includegraphics{illustrations/stack3}}
\afterfig \vspace{0.1in}

Los valores de retorno mostrados se pasan hacia arriba a trav茅s de
la pila. En cada marco, el valor de retorno es el valor de \texttt{da},
que es el producto de \texttt{n} y \texttt{recur}.

Observe que en el 煤ltimo marco, las variables locales \texttt{recur}
y \texttt{da} no existen porque la rama que las crea no se ejecut贸.

\section{El salto de fe}

\index{recursi贸n} \index{salto de fe}

Seguir el flujo de ejecuci贸n es una forma de leer programas, pero
r谩pidamente puede tornarse algo laber铆ntico. Una alternativa es lo
que denominamos hacer el ``salto de fe.'' Cuando usted llega a un
llamado de funci贸n, en lugar de seguir el flujo de ejecuci贸n, se {\em
asume} que la funci贸n trabaja correctamente y retorna el valor apropiado.

De hecho, usted ya est谩 haciendo el salto de fe cuando usa las funciones
primitivas. Cuando llama a \texttt{math.cos} 贸 a \texttt{math.exp},
no est谩 examinando las implementaciones de estas funciones. Usted
s贸lo asume que est谩n correctas porque los que escribieron el m贸dulo
math son buenos programadores.

Lo mismo se cumple para una de sus propias funciones. Por ejemplo,
en la Secci贸n~\ref{boolean}, escribimos una funci贸n llamada \texttt{esDivisible}
que determina si un n煤mero es divisible por otro. Una vez que nos
hemos convencido de que esta funci贸n es correcta prob谩ndola y examinando
el c贸digopodemos usarla sin mirar el c贸digo nuevamente.

Lo mismo vale para los programas recursivos. Cuando usted llega a
una llamada recursiva, en lugar de seguir el flujo de ejecuci贸n, deber铆a
asumir que el llamado recursivo funciona (retorna el resultado correcto)
y luego preguntarse, ``Asumiendo que puedo encontrar el factorial
de $n-1$, 驴puedo calcular el factorial de $n$?'' En este caso,
es claro que se puede lograr, multiplic谩ndolo por $n$.

Por supuesto que es un poco raro asumir que la funci贸n trabaja correctamente
cuando ni siquiera hemos terminado de escribirla, 隆por eso es que
denominamos a esto el salto de fe!.

\section{Un ejemplo m谩s}

\label{one more example}

En el ejemplo anterior us谩bamos variables temporales para desplegar
los pasos y depurar el c贸digo m谩s f谩cilmente, pero podr铆amos ahorrar
unas cuantas l铆neas:

\inputencoding{latin9}\begin{lstlisting}
def factorial(n):
  if n == 0:
    return 1
  else:
    return n * factorial(n-1)
\end{lstlisting}
\inputencoding{utf8} Desde ahora, vamos a usar esta forma m谩s compacta, pero le recomendamos
que use la forma m谩s expl铆cita mientras desarrolla las funciones.
Cuando est茅n terminadas y funcionando, con un poco de inspiraci贸n
se pueden compactar.

\index{La funci贸n de Fibonacci}

Despu茅s de \texttt{factorial}, el ejemplo m谩s com煤n de funci贸n matem谩tica,
definida recursivamente, es la serie de \texttt{fibonacci}, que tiene
la siguiente definici贸n:

\vspace{-0.25in}
 
\begin{eqnarray*}
 &  & fibonacci(0)=1\\
 &  & fibonacci(1)=1\\
 &  & fibonacci(n)=fibonacci(n-1)+fibonacci(n-2);
\end{eqnarray*}
Traducida a Python, luce as铆:

\inputencoding{latin9}\begin{lstlisting}
def fibonacci (n):
  if n == 0 or n == 1:
    return 1
  else:
    return fibonacci(n-1) + fibonacci(n-2)
\end{lstlisting}
\inputencoding{utf8} Si usted intenta seguir el flujo de ejecuci贸n de fibonacci, incluso
para valores peque帽os de $n$, le va a doler la cabeza. Pero, si seguimos
el salto de fe, si asumimos que los dos llamados recursivos funcionan
correctamente, es claro que el resultado correcto es la suma de 茅stos
dos.

\section{Chequeo de tipos}

\index{chequeo de tipos} \index{chequeo de errores} \index{funci贸n factorial}

驴Qu茅 pasa si llamamos a \texttt{factorial} y le pasamos a 1.5 como
argumento?

\inputencoding{latin9}\begin{lstlisting}
>>> factorial (1.5)
RuntimeError: Maximum recursion depth exceeded
\end{lstlisting}
\inputencoding{utf8} Parece recursi贸n infinita. 驴C贸mo puede darse? Hay un caso base cuando
\texttt{n == 0}. El problema reside en que los valores de \texttt{n}
se {\em saltan} al caso base .

\index{recursi贸n infinita} \index{recursi贸n!infinita}

En la primera llamada recursiva el valor de \texttt{n} es 0.5. En
la siguiente es -0.5. Desde all铆 se hace cada vez m谩s peque帽o, pero
nunca ser谩 0.

Tenemos dos opciones, podemos intentar generalizar la funci贸n \texttt{factorial}
para que trabaje con n煤meros de punto flotante, o podemos chequear
el tipo del par谩metro que llega. La primera opci贸n se denomina en
matem谩tica la funci贸n gama y est谩 fuera del alcance de este libro.
Optaremos por la segunda.

\index{funci贸n gama}

Podemos usar la funci贸n \texttt{type} para comparar el tipo del par谩metro
al tipo de un valor entero conocido (como 1). Mientras estamos en
eso tambi茅n aseguraremos que el par谩metro sea positivo:

\inputencoding{latin9}\begin{lstlisting}
def factorial (n):
  if type(n) != type(1):
    print("Factorial solo esta definido para enteros.")
    return -1
  elif n < 0:
    print("Factorial solo esta definido para positivos")
    return -1
  elif n == 0:
    return 1
  else:
    return n * factorial(n-1)
\end{lstlisting}
\inputencoding{utf8}
Ahora tenemos tres casos base. El primero atrapa a los valores que
no son enteros, el segundo a los enteros negativos. En ambos casos
el programa imprime un mensaje de error y retorna un valor especial,
-1, para indicar que algo fall贸:\inputencoding{latin9}
\begin{lstlisting}
>>> factorial ("pedro")
Factorial solo esta definido para enteros.
-1
>>> factorial (-2)
Factorial solo esta definido para positivos.
-1
\end{lstlisting}
\inputencoding{utf8}
Si pasamos los dos chequeos, tenemos la garant铆a de que $n$ es un
n煤mero entero positivo, y podemos probar que la recursi贸n termina.

Este programa demuestra el uso de un patr贸n denominado \textbf{guarda}.
Los primeros dos condicionales act煤an como guardas, protegiendo al
c贸digo interno de los valores que pueden causar un error. Las guardas
hacen posible demostrar que el c贸digo es correcto.

\section{Pruebas unitarias con doctest}

Con funciones fruct铆feras podemos realizar pruebas unitarias. Por
ejemplo, la funci贸n 谩rea de un cuadrado puede adornarse con un bloque
de comentarios con triple comillas, que explica su prop贸sito:

\inputencoding{latin9}\begin{lstlisting}
def area(lado):
    """ Calcula el area de un cuadrado
        Parmetros:
            radio: nmero
    """
    return lado**2
\end{lstlisting}
\inputencoding{utf8} 

Si al bloque le agregamos una l铆nea probando el llamado de la funci贸n,
seguida del valor de retorno que debe entregar:

\inputencoding{latin9}\begin{lstlisting}
def area(lado):
    """ Calcula el area de un cuadrado
        Parmetros:
            radio: nmero
        Pruebas:
        >>> area(1)
        1        
    """
    return lado**2
\end{lstlisting}
\inputencoding{utf8}
Logramos obtener una funci贸n que se puede probar en un caso particular.
El m贸dulo doctest de Python permite ejecutar autom谩ticamente los casos
de prueba que tengamos en las funciones agregando al final del gui贸n
su importaci贸n y el llamado de la funci贸n testmod(), como se ilustra
a continuaci贸n con la funci贸n area, ahora con cuatro casos de prueba:

\inputencoding{latin9}\begin{lstlisting}
def area(lado):
    """ Calcula el area de un cuadrado
        Parmetros:
            radio: nmero
        Pruebas:
        >>> area(1)
        1
        >>> area(2)
        4
        >>> area(4)
        16
        >>> area(10)
        100
        
    """
    return lado**2

if __name__ == '__main__':
    import doctest
    doctest.testmod()
\end{lstlisting}
\inputencoding{utf8}
Si se ejecuta el gui贸n se ejecutar谩n todas las pruebas unitarias de
todas las funciones, esto nos permite atrapar errores r谩pidamente
y corregirlos. En Unix/Linux, al ejecutar \verb+python -m doctest -v gui贸n.py+
se logran ejecutar los casos de prueba y visualizar detalladamente
en la pantalla.

\section{Glosario}
\begin{description}
\item [{Funci贸n fruct铆fera:}] funci贸n que retorna un resultado.
\item [{Valor de retorno:}] el valor que entrega como resultado un llamado
de funci贸n.
\item [{Variable temporal:}] variable usada para almacenar un valor intermedio
en un c谩lculo complejo.
\item [{C贸digo muerto:}] parte de un programa que nunca puede ser ejecutada,
a menudo porque aparece despu茅s de una sentencia \texttt{return}.
\item [{None:}] valor especial en Python retornado por las funciones que
no tienen una sentencia return, o que tienen una sentencia return
sin un argumento.
\item [{Desarrollo incremental:}] un plan de desarrollo de programas que
evita la depuraci贸n, agregando y probando solo peque帽as porciones
de c贸digo en cada momento.
\item [{Andamiaje:}] c贸digo que se usa durante el desarrollo de programas,
pero no hace parte de la soluci贸n final.
\item [{Guarda:}] una condici贸n que chequea y controla circunstancias que
pueden causar errores.

\index{variable temporal} \index{variable!temporal} \index{valor de retorno}
\index{c贸digo muerto} \index{None} \index{desarrollo incremental}
\index{andamiaje} \index{guarda}
\end{description}

\section{Ejercicios}
\begin{enumerate}
\item Escriba la funci贸n \verb+comparar(a,b)+ que devuelva 1 si $a<b$,
0 si $a=b$, y -1 si $a>b$
\item Tome la soluci贸n del 煤ltimo ejercicio del cap铆tulo anterior y convi茅rtala
en una funci贸n que retorne la nota definitiva de su curso de programaci贸n.
\item Calcule en una funci贸n el 谩rea de un disco, teniendo como entrada
el radio menor y el radio mayor.
\item Escriba la funci贸n \verb+pendiente(x1, y1, x2, y2)+ que calcule la
pendiente de una l铆nea que pasa por los puntos $(x_{1},y_{1})$ y
$(x_{2},y_{2})$.
\item Convierta las funciones de los cap铆tulos pasados, y que se puedan
transformar, a fruct铆feras.
\item Convierta las funciones que obtuvo en el punto anterior agregando
guardas para protegerlas de las situaciones en que reciben argumentos
de un tipo de dato que no pueden manipular.
\item Agregue pruebas unitarias a las funciones que obtuvo en el punto anterior.
\end{enumerate}

