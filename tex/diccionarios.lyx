%% LyX 2.2.3 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[oneside]{book}
\usepackage[utf8]{inputenc}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\synctex=-1
\usepackage{graphicx}

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\newcommand{\beforefig}{\vspace{1.3\parskip}}
\newcommand{\afterfig}{\vspace{-0.2\parskip}}

\newcommand{\beforeverb}{\vspace{0.6\parskip}}
\newcommand{\afterverb}{\vspace{0.6\parskip}}

\newcommand{\adjustpage}[1]{\enlargethispage{#1\baselineskip}}

\makeatother

\usepackage{listings}
\renewcommand{\lstlistingname}{\inputencoding{latin9}Listado de cÛdigo}

\begin{document}

\chapter{Diccionarios}

\index{diccionarios} \index{diccionario} \index{tipo de datos!diccionario}
\index{clave} \index{par clave-valor} \index{√≠ndice}

Los tipos compuestos que ha visto hasta ahora (cadenas, listas y tuplas)
usan enteros como √≠ndices. Si usted intenta usar cualquier otro tipo
como √≠ndice provocar√° un error.

Los \textbf{diccionarios} son similares a otros tipos compuestos,
excepto en que pueden usar como √≠ndice cualquier tipo inmutable. A
modo de ejemplo, crearemos un diccionario que traduzca palabras inglesas
al espa√±ol. En este diccionario, los √≠ndices son cadenas \texttt{(strings)}.

Una forma de crear un diccionario es empezar con el diccionario vac√≠o
y a√±adir elementos. El diccionario vac√≠o se expresa como \texttt{\{\}}:\inputencoding{latin9}
\begin{lstlisting}
>>> ing_a_esp = {}
>>> ing_a_esp['one'] = 'uno'
>>> ing_a_esp['two'] = 'dos'
\end{lstlisting}
\inputencoding{utf8}
La primera asignaci√≥n crea un diccionario llamado \texttt{ing\_a\_esp};
las otras asignaciones a√±aden nuevos elementos al diccionario. Podemos
desplegar el valor actual del diccionario del modo habitual:\inputencoding{latin9}
\begin{lstlisting}
>>> print(ing_a_esp)
{'one': 'uno', 'two': 'dos'}
\end{lstlisting}
\inputencoding{utf8}
Los elementos de un diccionario aparecen en una lista separada por
comas. Cada entrada contiene un √≠ndice y un valor separado por dos
puntos (:). En un diccionario, los √≠ndices se llaman \textbf{claves},
por eso los elementos se llaman \textbf{pares clave-valor}.

Otra forma de crear un diccionario es dando una lista de pares clave-valor
con la misma sintaxis que la salida del ejemplo anterior:\inputencoding{latin9}
\begin{lstlisting}
>>> ing_a_esp={'one': 'uno', 'two': 'dos', 'three': 'tres'}
\end{lstlisting}
\inputencoding{utf8}
Si volvemos a imprimir el valor de \texttt{ing\_a\_esp}, nos llevamos
una sorpresa:\inputencoding{latin9}
\begin{lstlisting}
>>> print(ing_a_esp)
{'one': 'uno', 'three': 'tres', 'two': 'dos'}
\end{lstlisting}
\inputencoding{utf8}
¬°Los pares clave-valor no est√°n en orden! Afortunadamente, no necesitamos
preocuparnos por el orden, ya que los elementos de un diccionario
nunca se indexan con √≠ndices enteros. En lugar de eso, usamos las
claves para buscar los valores correspondientes:\inputencoding{latin9}
\begin{lstlisting}
>>> print(ing_a_esp['two'])
'dos'
\end{lstlisting}
\inputencoding{utf8}
La clave \texttt{'two'} nos da el valor \texttt{'dos'} aunque aparezca
en el tercer par clave-valor.

\section{Operaciones sobre diccionarios}

\index{diccionario!operaciones} \index{diccionarios!operaciones sobre}

La sentencia \texttt{del} elimina un par clave-valor de un diccionario.
Por ejemplo, el diccionario siguiente contiene los nombres de varias
frutas y el n√∫mero de esas frutas en un almac√©n:\inputencoding{latin9}
\begin{lstlisting}
>>> inventario = {'manzanas': 430, 'bananas': 312, 
       'naranjas': 525,   'peras': 217}
>>> print(inventario)
{'naranjas': 525, 'manzanas': 430, 'peras': 217, 
 'bananas': 312}
\end{lstlisting}
\inputencoding{utf8} Si alguien compra todas las peras, podemos eliminar la entrada del
diccionario:\inputencoding{latin9}
\begin{lstlisting}
>>> del inventario['peras']
>>> print(inventario)
{'naranjas': 525, 'manzanas': 430, 'bananas': 312}
\end{lstlisting}
\inputencoding{utf8}
O si esperamos recibir m√°s peras pronto, podemos simplemente cambiar
el inventario asociado con las peras:\inputencoding{latin9}
\begin{lstlisting}
>>> inventario['peras'] = 0
>>> print(inventario)
{'naranjas': 525, 'manzanas': 430, 'peras': 0, 
 'bananas': 312}
\end{lstlisting}
\inputencoding{utf8} La funci√≥n \texttt{len} tambi√©n funciona con diccionarios; devuelve
el n√∫mero de pares clave-valor:\inputencoding{latin9}
\begin{lstlisting}
>>> len(inventario)
4
\end{lstlisting}
\inputencoding{utf8}
\section{M√©todos del diccionario}

\index{diccionario!m√©todos} \index{m√©todo} \index{m√©todo!invocaci√≥n}
\index{diccionarios!m√©todos} \index{m√©todos sobre diccionarios}
\index{invocar m√©todos}

El m√©todo \texttt{keys} acepta un diccionario y devuelve una lista
con las claves que aparecen, pero en lugar de la sintaxis de llamado
de funci√≥n \texttt{keys(ing\_a\_esp)}, usamos la sintaxis para un
m√©todo \texttt{ing\_a\_esp.keys()}.

\index{notaci√≥n de punto}

\inputencoding{latin9}\begin{lstlisting}
>>> ing_a_esp.keys()
['one', 'three', 'two']
\end{lstlisting}
\inputencoding{utf8} Esta forma de notaci√≥n punto especifica el nombre de la funci√≥n,
\texttt{keys}, y el nombre del objeto al que se va a aplicar la funci√≥n,
\texttt{ing\_a\_esp}. Los par√©ntesis vac√≠os indican que este m√©todo
no admite par√°metros.

El m√©todo \texttt{values} es similar; devuelve una lista de los valores
del diccionario:\inputencoding{latin9}
\begin{lstlisting}
>>> ing_a_esp.values()
['uno', 'tres', 'dos']
\end{lstlisting}
\inputencoding{utf8}
El m√©todo \texttt{items} devuelve ambos, una lista de tuplas con los
pares clave-valor del diccionario:\inputencoding{latin9}
\begin{lstlisting}
>>> ing_a_esp.items()
[('one','uno'), ('three', 'tres'), ('two', 'dos')]
\end{lstlisting}
\inputencoding{utf8}
La sintaxis nos proporciona informaci√≥n muy √∫til acerca del tipo de
datos. Los corchetes indican que es una lista. Los par√©ntesis indican
que los elementos de la lista son tuplas.

Para averiguar si una clave aparece en el diccionario, se puede usar
\texttt{in}:\inputencoding{latin9}
\begin{lstlisting}
>>> 'one' in ing_a_esp
True
>>> 'deux' in ing_a_esp
False
\end{lstlisting}
\inputencoding{utf8}
\index{error en tiempo de ejecuci√≥n}

\section{Copiado y alias}

\index{asignaci√≥n de alias} \index{copiado} \index{clonado}

Usted debe estar atento a los alias debido a la mutabilidad de los
diccionarios. Si dos variables se refieren al mismo objeto los cambios
en una afectan a la otra.

Si quiere modificar un diccionario y mantener una copia del original,
se puede usar el m√©todo \texttt{copy}. Por ejemplo, \texttt{opuestos}
es un diccionario que contiene pares de opuestos:\inputencoding{latin9}
\begin{lstlisting}
>>> opuestos = {'arriba': 'abajo', 'derecho': 'torcido', 
  'verdadero': 'falso'}
>>> alias = opuestos
>>> copia = opuestos.copy()
\end{lstlisting}
\inputencoding{utf8}
\texttt{alias} y \texttt{opuestos} se refieren al mismo objeto; \texttt{copia}
se refiere a una copia nueva del mismo diccionario. Si modificamos
\texttt{alias}, \texttt{opuestos} tambi√©n resulta cambiado:\inputencoding{latin9}
\begin{lstlisting}
>>> alias['derecho'] = 'sentado'
>>> opuestos['derecho']
'sentado'
\end{lstlisting}
\inputencoding{utf8}
Si modificamos \texttt{copia}, \texttt{opuestos} no var√≠a:\inputencoding{latin9}
\begin{lstlisting}
>>> copia['derecho'] = 'privilegio'
>>> opuestos['derecho']
'sentado'
\end{lstlisting}
\inputencoding{utf8}
\section{Matrices dispersas}

\index{matriz!dispersa} \index{lista anidada} \index{lista!anidada}

En la Secci√≥n~\ref{nested lists} usamos una lista de listas para
representar una matriz. Es una buena opci√≥n para una matriz en la
que la mayor√≠a de los valores es diferente de cero, pero piense en
una matriz como √©sta:

\beforefig\centerline{\includegraphics{illustrations/sparse}}
%\afterfig

La representaci√≥n de la lista contiene un mont√≥n de ceros:\inputencoding{latin9}
\begin{lstlisting}
>>> matriz = [ [0,0,0,1,0],
           [0,0,0,0,0],
           [0,2,0,0,0],
           [0,0,0,0,0],
           [0,0,0,3,0] ]
\end{lstlisting}
\inputencoding{utf8}
Una posible alternativa consiste en usar un diccionario. Como claves,
podemos usar tuplas que contengan los n√∫meros de fila y columna. √âsta
es la representaci√≥n de la misma matriz por medio de un diccionario:\inputencoding{latin9}
\begin{lstlisting}
>>> matriz = {(0,3): 1, (2, 1): 2, (4, 3): 3}
\end{lstlisting}
\inputencoding{utf8}
S√≥lo hay tres pares clave-valor, uno para cada elemento de la matriz
diferente de cero. Cada clave es una tupla, y cada valor es un entero.

Para acceder a un elemento de la matriz, podemos usar el operador
\texttt{{[}{]}}:\inputencoding{latin9}
\begin{lstlisting}
>>> matriz[0,3]
1
\end{lstlisting}
\inputencoding{utf8}
Observe que la sintaxis para la representaci√≥n por medio del diccionario
no es la misma de la representaci√≥n por medio de la lista anidada.
En lugar de dos √≠ndices enteros, usamos un √≠ndice compuesto que es
una tupla de enteros.

Hay un problema. Si apuntamos a un elemento que es cero, se produce
un error porque en el diccionario no hay una entrada con esa clave:

\index{error en tiempo de ejecuci√≥n}\inputencoding{latin9}
\begin{lstlisting}
>>> matriz[1,3]
KeyError: (1, 3)
\end{lstlisting}
\inputencoding{utf8}
El m√©todo \texttt{get} soluciona este problema:\inputencoding{latin9}
\begin{lstlisting}
>>> matriz.get((0,3), 0)
1
\end{lstlisting}
\inputencoding{utf8}
El primer argumento es la clave; el segundo argumento es el valor
que debe devolver \texttt{get} en caso de que la clave no est√© en
el diccionario:\inputencoding{latin9}
\begin{lstlisting}
>>> matriz.get((1,3), 0)
0
\end{lstlisting}
\inputencoding{utf8}
\texttt{get} mejora sensiblemente la sem√°ntica del acceso a una matriz
dispersa. ¬°L√°stima que la sintaxis no sea tan clara!

\section{Pistas}

\index{pista} \index{funci√≥n de Fibonacci}

Si ha jugado con la funci√≥n \texttt{fibonacci} de la Secci√≥n~\ref{one more example},
es posible que haya notado que cuanto m√°s grande es el argumento que
recibe, m√°s tiempo le cuesta ejecutarse. De hecho, el tiempo de ejecuci√≥n
aumenta muy r√°pidamente. En nuestra m√°quina, \texttt{fibonacci(20)}
acaba instant√°neamente, \texttt{fibonacci(30)} tarda m√°s o menos un
segundo, y \texttt{fibonacci(40)} tarda una eternidad.

Para entender por qu√©, observe este \textbf{gr√°fico de llamadas} de
\texttt{fibonacci} con \texttt{n=4}:

\beforefig \centerline{\includegraphics{illustrations/fibonacci}}
\afterfig

Un gr√°fico de llamadas muestra un conjunto de cajas de funci√≥n con
l√≠neas que conectan cada caja con las cajas de las funciones a las
que llama. En lo alto del gr√°fico, \texttt{fibonacci} con \texttt{n=4}
llama a \texttt{fibonacci} con \texttt{n=3} y \texttt{n=2}. A su vez,
\texttt{fibonacci} con \texttt{n=3} llama a \texttt{fibonacci} con
\texttt{n=2} y \texttt{n=1}. Y as√≠ sucesivamente.

\index{caja de funci√≥n} \index{caja} \index{gr√°fico de llamadas}

Cuente cu√°ntas veces se llama a \texttt{fibonacci(0)} y \texttt{fibonacci(1)}.
Esta funci√≥n es una soluci√≥n ineficiente para el problema, y empeora
mucho a medida que crece el argumento.

Una buena soluci√≥n es llevar un registro de los valores que ya se
han calculado almacen√°ndolos en un diccionario. A un valor que ya
ha sido calculado y almacenado para un uso posterior se le llama \textbf{pista}.
Aqu√≠ hay una implementaci√≥n de \texttt{fibonacci} con pistas:\inputencoding{latin9}
\begin{lstlisting}
anteriores = {0:1, 1:1}

def fibonacci(n):
  if anteriores.has_key(n):
    return anteriores[n]
  else:
    nuevoValor = fibonacci(n-1) + fibonacci(n-2)
    anteriores[n] = nuevoValor
    return nuevoValor
\end{lstlisting}
\inputencoding{utf8}
El diccionario llamado \texttt{anteriores} mantiene un registro de
los valores de Fibonacci que ya conocemos. El programa comienza con
s√≥lo dos pares: 0 corresponde a 1 y 1 corresponde a 1.

Siempre que se llama a \texttt{fibonacci} comprueba si el diccionario
contiene el resultado ya calculado. Si est√° ah√≠, la funci√≥n puede
devolver el valor inmediatamente sin hacer m√°s llamadas recursivas.
Si no, tiene que calcular el nuevo valor. El nuevo valor se a√±ade
al diccionario antes de que la funci√≥n retorne.

Con esta versi√≥n de \texttt{fibonacci}, nuestra m√°quina puede calcular
\texttt{fibonacci(40)} en un abrir y cerrar de ojos. Pero cuando intentamos
calcular \texttt{fibonacci(50)}, nos encontramos con otro problema:

\index{error en tiempo de ejecuci√≥n} \index{desbordamiento}

\inputencoding{latin9}\begin{lstlisting}
>>> fibonacci(50)
OverflowError: integer addition
\end{lstlisting}
\inputencoding{utf8}
La respuesta, como se ver√° en un momento, es 20.365.011.074. El problema
es que este n√∫mero es demasiado grande para caber en un entero de
Python. Se \textbf{desborda}. Afortunadamente, hay una soluci√≥n f√°cil
para este problema.

\section{Enteros largos}

\index{enteros largos} \index{tipos de datos!enteros largos} \index{enteros!largos}

Python proporciona un tipo llamado \texttt{long int} que puede manejar
enteros de cualquier tama√±o. Hay dos formas de crear un valor \texttt{long
int}. Una es escribir un entero con una {\em L} may√∫scula al final:

\inputencoding{latin9}\begin{lstlisting}
>>> type(1L)
<type 'long int'>
\end{lstlisting}
\inputencoding{utf8} La otra es usar la funci√≥n \texttt{long} para convertir un valor
en \texttt{long int}. \texttt{long} acepta cualquier tipo num√©rico
e incluso cadenas de d√≠gitos:\inputencoding{latin9}
\begin{lstlisting}
>>> long(1)
1L
>>> long(3.9)
3L
>>> long('57')
57L
\end{lstlisting}
\inputencoding{utf8}
Todas las operaciones matem√°ticas funcionan sobre los datos de tipo
\texttt{long int}, as√≠ que no tenemos que hacer mucho para adaptar
\texttt{fibonacci}:\inputencoding{latin9}
\begin{lstlisting}
>>> anteriores = {0:1L, 1:1L}
>>> fibonacci(50)
20365011074L
\end{lstlisting}
\inputencoding{utf8}
Simplemente cambiando el contenido inicial de \texttt{anteriores}
cambiamos el comportamiento de \texttt{fibonacci}. Los primeros dos
n√∫meros de la secuencia son de tipo \texttt{long int}, as√≠ que todos
los n√∫meros subsiguientes lo ser√°n tambi√©n.

\index{forzado de tipo de datos} \index{coerci√≥n!tipo}

\section{Contar letras}

\index{recuento} \index{histograma} \index{compresi√≥n}

En el cap√≠tulo~\ref{strings} escribimos una funci√≥n que contaba
el n√∫mero de apariciones de una letra en una cadena. Una versi√≥n m√°s
gen√©rica de este problema es crear un histograma de las letras de
la cadena, o sea, cu√°ntas veces aparece cada letra.

Ese histograma podr√≠a ser √∫til para comprimir un archivo de texto.
Como las diferentes letras aparecen con frecuencias distintas, podemos
comprimir un archivo usando c√≥digos cortos para las letras m√°s habituales
y c√≥digos m√°s largos para las que aparecen con menor frecuencia.

Los diccionarios facilitan una forma elegante de generar un histograma:\inputencoding{latin9}
\begin{lstlisting}
>>> cuentaLetras = {}
>>> for letra in "Mississippi":
      cuentaLetras[letra] = cuentaLetras.get(letra, 0)+1

>>> cuentaLetras
{'M': 1, 's': 4, 'p': 2, 'i': 4}
\end{lstlisting}
\inputencoding{utf8}
Inicialmente, tenemos un diccionario vac√≠o. Para cada letra de la
cadena, buscamos el recuento actual (posiblemente cero) y la incrementamos.
Al final, el diccionario contiene pares de letras y sus frecuencias.

Puede ser m√°s atractivo mostrar el histograma en orden alfab√©tico.
Podemos hacerlo con los m√©todos \texttt{items} y \texttt{sort}:\inputencoding{latin9}
\begin{lstlisting}
>>> itemsLetras = cuentaLetras.items()
>>> list(itemsLetras).sort()
>>> print(itemsLetras)
[('M', 1), ('i', 4), ('p', 2), ('s', 4)]
\end{lstlisting}
\inputencoding{utf8}
Usted ya ha visto el m√©todo \texttt{items} aplicable a los diccionarios;
\texttt{sort} es un m√©todo aplicable a listas. Hay varios m√°s, como
\texttt{append}, \texttt{extend} y \texttt{reverse}. Consulte la documentaci√≥n
de Python para ver los detalles.

\index{m√©todo!lista} \index{m√©todo de lista}

\section{Glosario}
\begin{description}
\item [{Diccionario:}] es una colecci√≥n de pares clave-valor que establece
una correspondencia entre claves y valores. Las claves pueden ser
de cualquier tipo inmutable, los valores pueden ser de cualquier tipo.
\item [{Clave:}] un valor que se usa para buscar una entrada en un diccionario.
\item [{Par clave-valor:}] uno de los elementos de un diccionario, tambi√©n
llamado ``asociaci√≥n''.
\item [{M√©todo:}] tipo de funci√≥n al que se llama con una sintaxis diferente
y al que se invoca ``sobre'' un objeto.
\item [{Invocar:}] llamar a un m√©todo.
\item [{Pista:}] almacenamiento temporal de un valor precalculado, para
evitar c√°lculos redundantes.
\item [{Desbordamiento:}] resultado num√©rico que es demasiado grande para
representarse en formato num√©rico.

\index{diccionario} \index{clave} \index{par clave-valor} \index{pista}
\index{m√©todo} \index{invocar}
\end{description}

\section{Ejercicios}

Para cada funci√≥n, agregue chequeo de tipos y pruebas unitarias.
\begin{enumerate}
\item Como ejercicio, modifique \texttt{factorial} de forma que produzca
un \texttt{long int} como resultado.
\item Escriba una funci√≥n booleana que averig√ºe si una lista tiene alg√∫n
elemento duplicado usando un diccionario.
\item Una cadena de ARN puede representarse como una lista en la que los
elementos pueden ser los caracteres A,C,G y U. Escriba una funci√≥n
booleana que averig√ºe si una lista de caracteres es una cadena de
ARN v√°lida.
\item Generalice la funci√≥n anterior de forma que reciba una biosecuencia
(ADN, ARN √≥ Prote√≠na) y un alfabeto de referencia para averiguar si
est√° bien formada. Para ADN el alfabeto es A,C,T y G, para las prote√≠nas
es:

A,R,N,D,C,E,Q,G,H,I,L,K,M,F,P,S,T,W,Y,V,U,O
\item Escriba una funci√≥n que reciba una cadena de ADN y cuente cuantos
nucle√≥tidos de cada tipo tiene (cuantas veces tiene A,C,G y T) usando
un diccionario.
\item Generalice la funci√≥n anterior de forma que reciba una biosecuencia
(ADN, ARN √≥ Prote√≠na) y un alfabeto. Debe contar cuantos elementos
tiene de cada tipo usando un diccionario.
\item Escriba una funci√≥n producto que reciba una matriz dispersa M, implementada
con un diccionario, y un n√∫mero. Debe retornar la matriz que resulta
de multiplicar cada elemento de M por el n√∫mero.
\item Escriba una funci√≥n que reciba dos matrices dispersas, implementadas
con diccionarios, y las sume, produciendo otra matriz dispersa.
\item Escriba una funci√≥n que reciba dos matrices dispersas, implementadas
con diccionarios, y las multiplique, produciendo otra matriz dispersa.
Base su soluci√≥n en las dos soluciones anteriores.
\item Escriba una funci√≥n booleana que reciba una matriz dispersa y averig√ºe
si es la matriz identidad. 
\end{enumerate}

\end{document}
