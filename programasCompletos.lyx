#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\use_default_options false
\maintain_unincluded_children false
\language spanish
\language_package none
\inputencoding utf8
\fontencoding default
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 0
\use_package cancel 0
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 0
\use_package mhchem 0
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\SpecialChar LyX
 source for textbook 
\begin_inset Quotes eld
\end_inset

How to think like a computer scientist'' 
\end_layout

\begin_layout Plain Layout
Copyright (c) 2001 Allen B.
 Downey, Jeffrey Elkner, and Chris Meyers.
\end_layout

\begin_layout Plain Layout
Permission is granted to copy, distribute and/or modify this document under
 the terms of the GNU Free Documentation License, Version 1.1 or any later
 version published by the Free Software Foundation; with the Invariant Sections
 being "Contributor List", with no Front-Cover Texts, and with no Back-Cover
 Texts.
 A copy of the license is included in the section entitled "GNU Free Documentati
on License".
\end_layout

\begin_layout Plain Layout
This distribution includes a file named fdl.lyx that contains the text of
 the GNU Free Documentation License.
 If it is missing, you can obtain it from www.gnu.org or by writing to the
 Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 02111-1307, USA.
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Programas completos
\end_layout

\begin_layout Section
Clase punto
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Verbatim

class Punto:
\end_layout

\begin_layout Verbatim

  def __init__(self, x=0, y=0):
\end_layout

\begin_layout Verbatim

    self.x = x
\end_layout

\begin_layout Verbatim

    self.y = y
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def __str__(self):
\end_layout

\begin_layout Verbatim

    return '(' + str(self.x) + ',' + str(self.y) + ')'
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def __add__(self, otro):
\end_layout

\begin_layout Verbatim

    return Punto(self.x + otro.x, self.y + otro.y)
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def __sub__(self, otro):
\end_layout

\begin_layout Verbatim

    return Punto(self.x - otro.x, self.y - otro.y)
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def __mul__(self, otro):
\end_layout

\begin_layout Verbatim

    return self.x * otro.x + self.y * otro.y
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def __rmul__(self, otro):
\end_layout

\begin_layout Verbatim

    return Punto(otro * self.x, otro * self.y)
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def invertir(self):
\end_layout

\begin_layout Verbatim

    self.x, self.y = self.y, self.x
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def DerechoYAlReves(derecho):
\end_layout

\begin_layout Verbatim

    from copy import copy
\end_layout

\begin_layout Verbatim

    alreves = copy(derecho)
\end_layout

\begin_layout Verbatim

    alreves.invertir()
\end_layout

\begin_layout Verbatim

    print(str(derecho) + str(alreves))
\end_layout

\end_inset


\end_layout

\begin_layout Section
Clase hora
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Verbatim

class Hora:
\end_layout

\begin_layout Verbatim

  def __init__(self, hora=0, minutos=0, segundos=0):
\end_layout

\begin_layout Verbatim

    self.hora = hora
\end_layout

\begin_layout Verbatim

    self.minutos = minutos
\end_layout

\begin_layout Verbatim

    self.segundos = segundos
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def __str__(self):
\end_layout

\begin_layout Verbatim

    return str(self.hora) + ":" + str(self.minutos) + 
\end_layout

\begin_layout Verbatim

           ":" + str(self.segundos)
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def convertirAsegundoss(self):
\end_layout

\begin_layout Verbatim

    minutos = self.hora * 60 + self.minutos
\end_layout

\begin_layout Verbatim

    segundos = self.minutos * 60 + self.segundos
\end_layout

\begin_layout Verbatim

    return segundos
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def incrementar(self, segs):
\end_layout

\begin_layout Verbatim

    segs = segs + self.segundos
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

    self.hora = self.hora + segs/3600
\end_layout

\begin_layout Verbatim

    segs = segs % 3600
\end_layout

\begin_layout Verbatim

    self.minutos = self.minutos + segs/60
\end_layout

\begin_layout Verbatim

    segs = segs % 60
\end_layout

\begin_layout Verbatim

    self.segundos = segs
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

def crearHora(segs):
\end_layout

\begin_layout Verbatim

  H = Hora()
\end_layout

\begin_layout Verbatim

  H.hora = segs/3600
\end_layout

\begin_layout Verbatim

  segs = segs - H.hora * 3600
\end_layout

\begin_layout Verbatim

  H.minutos = segs/60
\end_layout

\begin_layout Verbatim

  segs = segs - H.minutos * 60
\end_layout

\begin_layout Verbatim

  H.segundos = segs
\end_layout

\begin_layout Verbatim

  return H
\end_layout

\end_inset


\end_layout

\begin_layout Section
Cartas, mazos y juegos
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Verbatim

import random
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

class Carta:
\end_layout

\begin_layout Verbatim

  listaFiguras = ["Treboles", "Diamantes", 
\end_layout

\begin_layout Verbatim

                  "Corazones", "Picas"]
\end_layout

\begin_layout Verbatim

  listaValores = [ "narf", "As", "2", "3", "4", "5", "6", 
\end_layout

\begin_layout Verbatim

               "7","8", "9", "10","Jota", "Reina", "Rey"]
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def __init__(self, figura=0, valor=0):
\end_layout

\begin_layout Verbatim

    self.figura = figura
\end_layout

\begin_layout Verbatim

    self.valor = valor
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def __str__(self):
\end_layout

\begin_layout Verbatim

    return self.listaValores[self.valor] + " de " 
\end_layout

\begin_layout Verbatim

           + self.listaFiguras[self.figura]
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def __cmp__(self, otro):
\end_layout

\begin_layout Verbatim

    # revisa las figuras
\end_layout

\begin_layout Verbatim

    if self.figura > otro.figura: 
\end_layout

\begin_layout Verbatim

       return 1
\end_layout

\begin_layout Verbatim

    if self.figura < otro.figura: 
\end_layout

\begin_layout Verbatim

       return -1
\end_layout

\begin_layout Verbatim

    # las figuras son iguales, se chequean los valores
\end_layout

\begin_layout Verbatim

    if self.valor > otro.valor: 
\end_layout

\begin_layout Verbatim

      return 1
\end_layout

\begin_layout Verbatim

    if self.valor < otro.valor: 
\end_layout

\begin_layout Verbatim

      return -1
\end_layout

\begin_layout Verbatim

    # los valores son iguales,  hay empate
\end_layout

\begin_layout Verbatim

    return 0
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

class Mazo:
\end_layout

\begin_layout Verbatim

  def __init__(self):
\end_layout

\begin_layout Verbatim

    self.Cartas = []
\end_layout

\begin_layout Verbatim

    for figura in range(4):
\end_layout

\begin_layout Verbatim

      for valor in range(1, 14):
\end_layout

\begin_layout Verbatim

        self.Cartas.append(Carta(figura, valor))
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def imprimirMazo(self):
\end_layout

\begin_layout Verbatim

    for Carta in self.Cartas:
\end_layout

\begin_layout Verbatim

      print(Carta)
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def __str__(self):
\end_layout

\begin_layout Verbatim

    s = ""
\end_layout

\begin_layout Verbatim

    for i in range(len(self.Cartas)):
\end_layout

\begin_layout Verbatim

      s = s + " "*i + str(self.Cartas[i]) + "
\backslash
n"
\end_layout

\begin_layout Verbatim

    return s
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def barajar(self):
\end_layout

\begin_layout Verbatim

    import random
\end_layout

\begin_layout Verbatim

    nCartas = len(self.Cartas)
\end_layout

\begin_layout Verbatim

    for i in range(nCartas):
\end_layout

\begin_layout Verbatim

      j = random.randrange(i, nCartas)
\end_layout

\begin_layout Verbatim

      [self.Cartas[i], self.Cartas[j]] = [self.Cartas[j], 
\end_layout

\begin_layout Verbatim

                                          self.Cartas[i]]
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def eliminarCarta(self, Carta):
\end_layout

\begin_layout Verbatim

    if Carta in self.Cartas:
\end_layout

\begin_layout Verbatim

      self.Cartas.remove(Carta)
\end_layout

\begin_layout Verbatim

      return 1
\end_layout

\begin_layout Verbatim

    else: return 0
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def entregarCarta(self):
\end_layout

\begin_layout Verbatim

    return self.Cartas.pop()
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def estaVacio(self):
\end_layout

\begin_layout Verbatim

    return (len(self.Cartas) == 0)
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def repartir(self, manos, nCartas=999):
\end_layout

\begin_layout Verbatim

    nmanos = len(manos)
\end_layout

\begin_layout Verbatim

    for i in range(nCartas):
\end_layout

\begin_layout Verbatim

      if self.estaVacio(): 
\end_layout

\begin_layout Verbatim

         break    # rompe el ciclo si no hay cartas
\end_layout

\begin_layout Verbatim

      # quita la carta del tope
\end_layout

\begin_layout Verbatim

      Carta = self.entregarCarta()      
\end_layout

\begin_layout Verbatim

      # quien tiene el proximo turnoo?
\end_layout

\begin_layout Verbatim

      mano = manos[i % nmanos]    
\end_layout

\begin_layout Verbatim

      # agrega la carta a la mano
\end_layout

\begin_layout Verbatim

      mano.agregarCarta(Carta)         
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

class mano(Mazo):
\end_layout

\begin_layout Verbatim

  def __init__(self, nombre=""):
\end_layout

\begin_layout Verbatim

    self.Cartas = []
\end_layout

\begin_layout Verbatim

    self.nombre = nombre
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def agregarCarta(self,Carta) :
\end_layout

\begin_layout Verbatim

    self.Cartas.append(Carta)
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def __str__(self):
\end_layout

\begin_layout Verbatim

    s = "mano " + self.nombre
\end_layout

\begin_layout Verbatim

    if self.estaVacio():
\end_layout

\begin_layout Verbatim

      s = s + " esta vacia
\backslash
n"
\end_layout

\begin_layout Verbatim

    else:
\end_layout

\begin_layout Verbatim

      s = s + " contiene
\backslash
n"
\end_layout

\begin_layout Verbatim

    return s + Mazo.__str__(self)
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

class JuegoCartas:
\end_layout

\begin_layout Verbatim

  def __init__(self):
\end_layout

\begin_layout Verbatim

    self.Mazo = Mazo()
\end_layout

\begin_layout Verbatim

    self.Mazo.barajar()
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

class ManoJuegoSolterona(mano):
\end_layout

\begin_layout Verbatim

  def eliminarParejas(self):
\end_layout

\begin_layout Verbatim

    cont = 0
\end_layout

\begin_layout Verbatim

    originalCartas = self.Cartas[:]
\end_layout

\begin_layout Verbatim

    for carta in originalCartas:
\end_layout

\begin_layout Verbatim

      m = Carta(3-carta.figura, carta.valor)
\end_layout

\begin_layout Verbatim

      if m in self.Cartas:
\end_layout

\begin_layout Verbatim

        self.Cartas.remove(carta)
\end_layout

\begin_layout Verbatim

        self.Cartas.remove(m)
\end_layout

\begin_layout Verbatim

        print("mano %s: %s parejas %s" % 
\end_layout

\begin_layout Verbatim

                 (self.nombre,carta,m))
\end_layout

\begin_layout Verbatim

        cont = cont+1
\end_layout

\begin_layout Verbatim

    return cont
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

class JuegoSolterona(JuegoCartas):
\end_layout

\begin_layout Verbatim

  def jugar(self, nombres):
\end_layout

\begin_layout Verbatim

    # elimina la reina de treboles
\end_layout

\begin_layout Verbatim

    self.Mazo.eliminarCarta(Carta(0,12))
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

    # crea manos con base en los nombres
\end_layout

\begin_layout Verbatim

    self.manos = []
\end_layout

\begin_layout Verbatim

    for nombre in nombres : 
\end_layout

\begin_layout Verbatim

        self.manos.append(ManoJuegoSolterona(nombre))
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

    # reparte las Cartas
\end_layout

\begin_layout Verbatim

    self.Mazo.repartir(self.manos)
\end_layout

\begin_layout Verbatim

    print("---------- Cartas se han repartido")
\end_layout

\begin_layout Verbatim

    self.imprimirmanos()
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

    # eliminar parejas iniciales
\end_layout

\begin_layout Verbatim

    parejas = self.eliminarParejas()
\end_layout

\begin_layout Verbatim

    print("----- parejas descartadas, empieza el juego")
\end_layout

\begin_layout Verbatim

    self.imprimirmanos()
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

    # jugar hasta que se eliminan 50 cartas
\end_layout

\begin_layout Verbatim

    turno = 0
\end_layout

\begin_layout Verbatim

    nummanos = len(self.manos)
\end_layout

\begin_layout Verbatim

    while parejas < 25:
\end_layout

\begin_layout Verbatim

      parejas = parejas + self.jugarUnturno(turno)
\end_layout

\begin_layout Verbatim

      turno = (turno + 1) % nummanos
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

    print("---------- Juego Terminado")
\end_layout

\begin_layout Verbatim

    self.imprimirmanos ()
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def eliminarParejas(self):
\end_layout

\begin_layout Verbatim

    cont = 0
\end_layout

\begin_layout Verbatim

    for mano in self.manos:
\end_layout

\begin_layout Verbatim

      cont = cont + mano.eliminarParejas()
\end_layout

\begin_layout Verbatim

    return cont
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def jugarUnturno(self, i):
\end_layout

\begin_layout Verbatim

    if self.manos[i].estaVacio():
\end_layout

\begin_layout Verbatim

      return 0
\end_layout

\begin_layout Verbatim

    vecino = self.encontrarvecino(i)
\end_layout

\begin_layout Verbatim

    cartaEscogida = self.manos[vecino].entregarCarta()
\end_layout

\begin_layout Verbatim

    self.manos[i].agregarCarta(cartaEscogida)
\end_layout

\begin_layout Verbatim

    print("mano", self.manos[i].nombre, 
\end_layout

\begin_layout Verbatim

          "escogió", cartaEscogida)
\end_layout

\begin_layout Verbatim

    count = self.manos[i].eliminarParejas()
\end_layout

\begin_layout Verbatim

    self.manos[i].barajar()
\end_layout

\begin_layout Verbatim

    return count
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def encontrarvecino(self, i):
\end_layout

\begin_layout Verbatim

    nummanos = len(self.manos)
\end_layout

\begin_layout Verbatim

    for siguiente in range(1,nummanos):
\end_layout

\begin_layout Verbatim

      vecino = (i + siguiente) % nummanos
\end_layout

\begin_layout Verbatim

      if not self.manos[vecino].estaVacio():
\end_layout

\begin_layout Verbatim

        return vecino
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def imprimirmanos(self) :
\end_layout

\begin_layout Verbatim

    for mano in self.manos :
\end_layout

\begin_layout Verbatim

      print(mano)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Listas enlazadas
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Verbatim

def imprimirlista(Nodo) :
\end_layout

\begin_layout Verbatim

  while Nodo :
\end_layout

\begin_layout Verbatim

    print(Nodo),
\end_layout

\begin_layout Verbatim

    Nodo = Nodo.siguiente
\end_layout

\begin_layout Verbatim

  print()
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

def imprimirAlReves(lista) :
\end_layout

\begin_layout Verbatim

  if lista == None : 
\end_layout

\begin_layout Verbatim

      return
\end_layout

\begin_layout Verbatim

  cabeza = lista
\end_layout

\begin_layout Verbatim

  resto = lista.siguiente
\end_layout

\begin_layout Verbatim

  imprimirAlReves(resto)
\end_layout

\begin_layout Verbatim

  print(cabeza),
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

def imprimirAlRevesBien(lista) :
\end_layout

\begin_layout Verbatim

  print("("),
\end_layout

\begin_layout Verbatim

  if lista != None :
\end_layout

\begin_layout Verbatim

    cabeza = lista
\end_layout

\begin_layout Verbatim

    resto = lista.siguiente
\end_layout

\begin_layout Verbatim

    imprimirAlReves(resto)
\end_layout

\begin_layout Verbatim

    print(cabeza),
\end_layout

\begin_layout Verbatim

  print(")"),
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

def eliminarSegundo(lista) :
\end_layout

\begin_layout Verbatim

  if lista == None : return
\end_layout

\begin_layout Verbatim

  first  = lista
\end_layout

\begin_layout Verbatim

  second = lista.siguiente
\end_layout

\begin_layout Verbatim

  first.siguiente = second.siguiente
\end_layout

\begin_layout Verbatim

  second.siguiente = None
\end_layout

\begin_layout Verbatim

  return second
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

class Nodo :
\end_layout

\begin_layout Verbatim

  def __init__(self, carga=None) :
\end_layout

\begin_layout Verbatim

    self.carga = carga
\end_layout

\begin_layout Verbatim

    self.siguiente  = None
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def __str__(self) :
\end_layout

\begin_layout Verbatim

    return str(self.carga)
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def imprimirAlReves(self) :
\end_layout

\begin_layout Verbatim

    if self.siguiente != None :
\end_layout

\begin_layout Verbatim

      resto = self.siguiente
\end_layout

\begin_layout Verbatim

      resto.imprimirAlReves()
\end_layout

\begin_layout Verbatim

    print(self.carga),
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

class ListaEnlazada :
\end_layout

\begin_layout Verbatim

  def __init__(self) :
\end_layout

\begin_layout Verbatim

    self.numElementos = 0
\end_layout

\begin_layout Verbatim

    self.cabeza   = None
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def imprimirAlReves(self) :
\end_layout

\begin_layout Verbatim

    print("("),
\end_layout

\begin_layout Verbatim

    if self.cabeza != None :
\end_layout

\begin_layout Verbatim

      self.cabeza.imprimirAlReves()
\end_layout

\begin_layout Verbatim

    print(")"),
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def agregarAlPrincipio(self, carga) :
\end_layout

\begin_layout Verbatim

    nodo = Nodo(carga)
\end_layout

\begin_layout Verbatim

    nodo.siguiente = self.cabeza
\end_layout

\begin_layout Verbatim

    self.cabeza = nodo
\end_layout

\begin_layout Verbatim

    self.numElementos = self.numElementos + 1
\end_layout

\end_inset


\end_layout

\begin_layout Section
Clase pila
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Verbatim

class Pila:              
\end_layout

\begin_layout Verbatim

  def __init__(self):
\end_layout

\begin_layout Verbatim

    self.items = []
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def meter(self, item):
\end_layout

\begin_layout Verbatim

    self.items.append(item)
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def sacar(self):
\end_layout

\begin_layout Verbatim

    return self.items.pop()
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def estaVacia(self):
\end_layout

\begin_layout Verbatim

    return(self.items == [])
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

def evalPostfija(expr) :
\end_layout

\begin_layout Verbatim

  import re
\end_layout

\begin_layout Verbatim

  expr = re.split("([^0-9])", expr)
\end_layout

\begin_layout Verbatim

  pila = Pila()
\end_layout

\begin_layout Verbatim

  for lexema in expr :
\end_layout

\begin_layout Verbatim

    if  lexema == '' or lexema == ' ':
\end_layout

\begin_layout Verbatim

      continue
\end_layout

\begin_layout Verbatim

    if  lexema == '+' :
\end_layout

\begin_layout Verbatim

      suma = pila.sacar() + pila.sacar()
\end_layout

\begin_layout Verbatim

      pila.meter(suma)
\end_layout

\begin_layout Verbatim

    elif lexema == '*' :
\end_layout

\begin_layout Verbatim

      producto = pila.sacar() * pila.sacar()
\end_layout

\begin_layout Verbatim

      pila.meter(producto)
\end_layout

\begin_layout Verbatim

    else :
\end_layout

\begin_layout Verbatim

      pila.meter(int(lexema))
\end_layout

\begin_layout Verbatim

  return pila.sacar()
\end_layout

\end_inset


\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Section
Colas PEPS y de colas de prioridad
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Verbatim

class Cola:
\end_layout

\begin_layout Verbatim

  def __init__(self):
\end_layout

\begin_layout Verbatim

    self.numElementos = 0
\end_layout

\begin_layout Verbatim

    self.primero = None
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def estaVacia(self):
\end_layout

\begin_layout Verbatim

    return (self.numElementos == 0)
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def meter(self, carga):
\end_layout

\begin_layout Verbatim

    nodo = Nodo(carga) 
\end_layout

\begin_layout Verbatim

    nodo.siguiente = None
\end_layout

\begin_layout Verbatim

    if self.primero == None:
\end_layout

\begin_layout Verbatim

       # si esta vacia este nodo sera el primero
\end_layout

\begin_layout Verbatim

       self.primero = nodo
\end_layout

\begin_layout Verbatim

    else:
\end_layout

\begin_layout Verbatim

       # encontrar el ultimo nodo
\end_layout

\begin_layout Verbatim

       ultimo = self.primero
\end_layout

\begin_layout Verbatim

       while ultimo.siguiente:
\end_layout

\begin_layout Verbatim

	 ultimo = ultimo.siguiente
\end_layout

\begin_layout Verbatim

	 # pegar el nuevo
\end_layout

\begin_layout Verbatim

	 ultimo.siguiente = nodo
\end_layout

\begin_layout Verbatim

       self.numElementos = self.numElementos + 1
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def sacar(self):
\end_layout

\begin_layout Verbatim

    carga = self.primero.carga
\end_layout

\begin_layout Verbatim

    self.primero = self.primero.siguiente
\end_layout

\begin_layout Verbatim

    self.numElementos = self.numElementos - 1
\end_layout

\begin_layout Verbatim

    return carga
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

class ColaMejorada:
\end_layout

\begin_layout Verbatim

  def __init__(self):
\end_layout

\begin_layout Verbatim

    self.numElementos = 0
\end_layout

\begin_layout Verbatim

    self.primero = None
\end_layout

\begin_layout Verbatim

    self.ultimo = None
\end_layout

\begin_layout Verbatim

        
\end_layout

\begin_layout Verbatim

  def estaVacia(self):
\end_layout

\begin_layout Verbatim

    return (self.numElementos == 0)
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def meter(self, carga):
\end_layout

\begin_layout Verbatim

    nodo = Nodo(carga) 
\end_layout

\begin_layout Verbatim

    nodo.siguiente = None
\end_layout

\begin_layout Verbatim

    if self.numElementos == 0:
\end_layout

\begin_layout Verbatim

      # si esta vacia, el nuevo nodo 
\end_layout

\begin_layout Verbatim

      # es primero y ultimo
\end_layout

\begin_layout Verbatim

      self.primero = self.ultimo = nodo
\end_layout

\begin_layout Verbatim

    else:
\end_layout

\begin_layout Verbatim

      # encontrar el ultimo nodo
\end_layout

\begin_layout Verbatim

      ultimo = self.ultimo
\end_layout

\begin_layout Verbatim

      # pegar el nuevo nodo
\end_layout

\begin_layout Verbatim

      ultimo.siguiente = nodo
\end_layout

\begin_layout Verbatim

      self.ultimo = nodo
\end_layout

\begin_layout Verbatim

      self.numElementos = self.numElementos + 1
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

    def sacar(self):
\end_layout

\begin_layout Verbatim

      carga = self.primero.carga
\end_layout

\begin_layout Verbatim

      self.primero = self.primero.siguiente
\end_layout

\begin_layout Verbatim

      self.numElementos = self.numElementos - 1
\end_layout

\begin_layout Verbatim

      if self.numElementos == 0:
\end_layout

\begin_layout Verbatim

        self.ultimo = None
\end_layout

\begin_layout Verbatim

      return carga
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

class ColaPrioridad:
\end_layout

\begin_layout Verbatim

  def __init__(self):
\end_layout

\begin_layout Verbatim

    self.items = []
\end_layout

\begin_layout Verbatim

      
\end_layout

\begin_layout Verbatim

  def estaVacia(self):
\end_layout

\begin_layout Verbatim

    return self.items == []
\end_layout

\begin_layout Verbatim

  
\end_layout

\begin_layout Verbatim

  def meter(self, item):
\end_layout

\begin_layout Verbatim

    self.items.append(item)
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def eliminar(self) :
\end_layout

\begin_layout Verbatim

    maxi = 0
\end_layout

\begin_layout Verbatim

    for i in range(1,len(self.items)) :
\end_layout

\begin_layout Verbatim

      if self.items[i] > self.items[maxi] :
\end_layout

\begin_layout Verbatim

	maxi = i
\end_layout

\begin_layout Verbatim

    item = self.items[maxi]
\end_layout

\begin_layout Verbatim

    self.items[maxi:maxi+1] = []
\end_layout

\begin_layout Verbatim

    return item
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def sacar(self):
\end_layout

\begin_layout Verbatim

    maxi = 0
\end_layout

\begin_layout Verbatim

    for i in range(0,len(self.items)): 
\end_layout

\begin_layout Verbatim

      if self.items[i] > self.items[maxi]:
\end_layout

\begin_layout Verbatim

	maxi = i
\end_layout

\begin_layout Verbatim

      item = self.items[maxi]
\end_layout

\begin_layout Verbatim

      self.items[maxi:maxi+1] = []
\end_layout

\begin_layout Verbatim

      return item
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

class golfista:
\end_layout

\begin_layout Verbatim

  def __init__(self, nombre, puntaje):
\end_layout

\begin_layout Verbatim

    self.nombre = nombre
\end_layout

\begin_layout Verbatim

    self.puntaje= puntaje
\end_layout

\begin_layout Verbatim

    
\end_layout

\begin_layout Verbatim

  def __str__(self):
\end_layout

\begin_layout Verbatim

    return "%-16s: %d" % (self.nombre, self.puntaje)
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def __cmp__(self, otro):
\end_layout

\begin_layout Verbatim

    # el menor tiene mayor prioridad
\end_layout

\begin_layout Verbatim

    if self.puntaje < otro.puntaje: return 1
\end_layout

\begin_layout Verbatim

      if self.puntaje > otro.puntaje: return -1
\end_layout

\begin_layout Verbatim

        return 0
\end_layout

\end_inset


\end_layout

\begin_layout Section
Árboles
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Verbatim

class Arbol:
\end_layout

\begin_layout Verbatim

  def __init__(self, carga, izquierdo=None, derecho=None):
\end_layout

\begin_layout Verbatim

    self.carga = carga
\end_layout

\begin_layout Verbatim

    self.izquierdo = izquierdo
\end_layout

\begin_layout Verbatim

    self.derecho = derecho
\end_layout

\begin_layout Verbatim

      
\end_layout

\begin_layout Verbatim

  def __str__(self):
\end_layout

\begin_layout Verbatim

    return str(self.carga)
\end_layout

\begin_layout Verbatim

  
\end_layout

\begin_layout Verbatim

  def obtenerizquierdo(self):
\end_layout

\begin_layout Verbatim

    return self.izquierdo
\end_layout

\begin_layout Verbatim

  
\end_layout

\begin_layout Verbatim

  def obtenerderecho(self):
\end_layout

\begin_layout Verbatim

    return self.derecho
\end_layout

\begin_layout Verbatim

  
\end_layout

\begin_layout Verbatim

  def obtenercarga(self):
\end_layout

\begin_layout Verbatim

    return self.carga
\end_layout

\begin_layout Verbatim

    
\end_layout

\begin_layout Verbatim

  def asignarcarga(self, carga):
\end_layout

\begin_layout Verbatim

    self.carga = carga
\end_layout

\begin_layout Verbatim

  
\end_layout

\begin_layout Verbatim

  def asignarizquierdo(self, i):
\end_layout

\begin_layout Verbatim

    self.izquierdo = i
\end_layout

\begin_layout Verbatim

    
\end_layout

\begin_layout Verbatim

  def asignarderecho(self, d):
\end_layout

\begin_layout Verbatim

    self.derecho = d
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

def total(arbol):
\end_layout

\begin_layout Verbatim

  if arbol.izquierdo == None or arbol.derecho== None:
\end_layout

\begin_layout Verbatim

    return arbol.carga
\end_layout

\begin_layout Verbatim

  else:
\end_layout

\begin_layout Verbatim

    return total(arbol.izquierdo) + total(arbol.derecho) + 
\end_layout

\begin_layout Verbatim

             arbol.carga
\end_layout

\begin_layout Verbatim

   
\end_layout

\begin_layout Verbatim

def imprimirarbol(arbol):
\end_layout

\begin_layout Verbatim

  if arbol == None:
\end_layout

\begin_layout Verbatim

    return 
\end_layout

\begin_layout Verbatim

  else:
\end_layout

\begin_layout Verbatim

    print(arbol.carga)
\end_layout

\begin_layout Verbatim

    imprimirarbol(arbol.izquierdo)
\end_layout

\begin_layout Verbatim

    imprimirarbol(arbol.derecho)
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

def imprimirarbolPostorden(arbol):
\end_layout

\begin_layout Verbatim

  if arbol == None:
\end_layout

\begin_layout Verbatim

    return
\end_layout

\begin_layout Verbatim

  else:
\end_layout

\begin_layout Verbatim

    imprimirarbolPostorden(arbol.izquierdo)
\end_layout

\begin_layout Verbatim

    imprimirarbolPostorden(arbol.derecho)
\end_layout

\begin_layout Verbatim

    print(arbol.carga)   
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

def imprimirabolEnOrden(arbol):
\end_layout

\begin_layout Verbatim

  if arbol == None:
\end_layout

\begin_layout Verbatim

    return
\end_layout

\begin_layout Verbatim

  imprimirabolEnOrden(arbol.izquierdo)
\end_layout

\begin_layout Verbatim

  print(arbol.carga,imprimirabolEnOrden(arbol.derecho))
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

def imprimirarbolSangrado(arbol, nivel=0):
\end_layout

\begin_layout Verbatim

  if arbol == None:
\end_layout

\begin_layout Verbatim

    return
\end_layout

\begin_layout Verbatim

  imprimirarbolSangrado(arbol.derecho, nivel+1)
\end_layout

\begin_layout Verbatim

  print(" "*nivel + str(arbol.carga))
\end_layout

\begin_layout Verbatim

  imprimirarbolSangrado(arbol.izquierdo, nivel+1)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Árboles de expresiones
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Verbatim

def obtenerLexema(listaLexemas, esperado):
\end_layout

\begin_layout Verbatim

  if listaLexemas[0] == esperado:
\end_layout

\begin_layout Verbatim

      del listaLexemas[0]
\end_layout

\begin_layout Verbatim

      return 1
\end_layout

\begin_layout Verbatim

  else:
\end_layout

\begin_layout Verbatim

      return 0
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

def obtenerNumero(listaLexemas):
\end_layout

\begin_layout Verbatim

  x = listaLexemas[0]
\end_layout

\begin_layout Verbatim

  if type(x) != type(0):
\end_layout

\begin_layout Verbatim

      return None
\end_layout

\begin_layout Verbatim

  del listaLexemas[0]
\end_layout

\begin_layout Verbatim

  return arbol (x, None, None)
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

def obtenerProducto(listaLexemas):
\end_layout

\begin_layout Verbatim

  a = obtenerNumero(listaLexemas)
\end_layout

\begin_layout Verbatim

  if obtenerLexema(listaLexemas, "*"):
\end_layout

\begin_layout Verbatim

    b = obtenerProducto(listaLexemas) 
\end_layout

\begin_layout Verbatim

    return arbol ("*", a, b)
\end_layout

\begin_layout Verbatim

  else:
\end_layout

\begin_layout Verbatim

    return a
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

def obtenerNumero(listaLexemas):
\end_layout

\begin_layout Verbatim

  if obtenerLexema(listaLexemas, "("):
\end_layout

\begin_layout Verbatim

    # obtiene la subexpresión
\end_layout

\begin_layout Verbatim

    x = obtenerSuma(listaLexemas) 
\end_layout

\begin_layout Verbatim

    # elimina los paréntesis
\end_layout

\begin_layout Verbatim

    obtenerLexema(listaLexemas, ")") 
\end_layout

\begin_layout Verbatim

    return x
\end_layout

\begin_layout Verbatim

  else:
\end_layout

\begin_layout Verbatim

    x = listaLexemas[0]
\end_layout

\begin_layout Verbatim

    if type(x) != type(0):
\end_layout

\begin_layout Verbatim

      return None
\end_layout

\begin_layout Verbatim

    listaLexemas[0:1] = []
\end_layout

\begin_layout Verbatim

   return Arbol (x, None, None)  
\end_layout

\end_inset


\end_layout

\begin_layout Section
Adivinar el animal
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Verbatim

def animal():
\end_layout

\begin_layout Verbatim

  # Un solo nodo
\end_layout

\begin_layout Verbatim

  raiz = Arbol("pajaro")
\end_layout

\begin_layout Verbatim

      # Hasta que el usuario salga
\end_layout

\begin_layout Verbatim

  while True:
\end_layout

\begin_layout Verbatim

    print()
\end_layout

\begin_layout Verbatim

    if not si("Esta pensando en un animal? "):
\end_layout

\begin_layout Verbatim

	break
\end_layout

\begin_layout Verbatim

    # Recorrer el arbol
\end_layout

\begin_layout Verbatim

    arbol = raiz
\end_layout

\begin_layout Verbatim

    while arbol.obtenerizquierdo() != None:
\end_layout

\begin_layout Verbatim

      pregunta = arbol.obtenercarga() + "? "
\end_layout

\begin_layout Verbatim

      if si(pregunta):
\end_layout

\begin_layout Verbatim

	  arbol = arbol.obtenerderecho()
\end_layout

\begin_layout Verbatim

      else:
\end_layout

\begin_layout Verbatim

	  arbol = arbol.obtenerizquierdo()
\end_layout

\begin_layout Verbatim

    # conjetura
\end_layout

\begin_layout Verbatim

    conjetura = arbol.obtenercarga()
\end_layout

\begin_layout Verbatim

    pregunta = "¿Es un" + conjetura + "? "
\end_layout

\begin_layout Verbatim

    if si(pregunta):
\end_layout

\begin_layout Verbatim

      print("¡Soy el mejor!")
\end_layout

\begin_layout Verbatim

      continue
\end_layout

\begin_layout Verbatim

    # obtener mas informacion
\end_layout

\begin_layout Verbatim

    pregunta = "¿Cual es el nombre el animal? "
\end_layout

\begin_layout Verbatim

    animal = input(pregunta)
\end_layout

\begin_layout Verbatim

    pregunta = "¿Que pregunta permitiria distinguir 
\end_layout

\begin_layout Verbatim

		un %s de un %s? "
\end_layout

\begin_layout Verbatim

    q = input(pregunta % (animal,conjetura))
\end_layout

\begin_layout Verbatim

    # agrega un nuevo nodo arbol
\end_layout

\begin_layout Verbatim

    arbol.asignarcarga(q)
\end_layout

\begin_layout Verbatim

    pregunta = "¿Si el animal fuera %s 
\end_layout

\begin_layout Verbatim

		la respuesta sería? "
\end_layout

\begin_layout Verbatim

    if si(pregunta % animal):
\end_layout

\begin_layout Verbatim

      arbol.asignarizquierdo(Arbol(conjetura))
\end_layout

\begin_layout Verbatim

      arbol.asignarderecho(Arbol(animal))
\end_layout

\begin_layout Verbatim

    else:
\end_layout

\begin_layout Verbatim

      arbol.asignarizquierdo(Arbol(animal))
\end_layout

\begin_layout Verbatim

      arbol.asignarderecho(Arbol(conjetura))
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

def si(preg):
\end_layout

\begin_layout Verbatim

  from string import lower
\end_layout

\begin_layout Verbatim

  r = lower(input(preg))
\end_layout

\begin_layout Verbatim

  return (r[0] == 's')
\end_layout

\end_inset


\end_layout

\begin_layout Section
Clase 
\family typewriter
Fraccion
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset listings
lstparams "language=Python,showstringspaces=false,tabsize=4"
inline false
status open

\begin_layout Verbatim

class Fraccion:
\end_layout

\begin_layout Verbatim

  def __init__(self,numerador,denominador=1):
\end_layout

\begin_layout Verbatim

    self.numerador = numerador
\end_layout

\begin_layout Verbatim

    self.denominador = denominador
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def __str__(self):
\end_layout

\begin_layout Verbatim

    return "%d/%d" % (self.numerador, self.denominador)
\end_layout

\begin_layout Verbatim

  
\end_layout

\begin_layout Verbatim

  def __mul__(self, otro):
\end_layout

\begin_layout Verbatim

    if type(otro) == type(5):
\end_layout

\begin_layout Verbatim

      otro = Fraccion(otro)
\end_layout

\begin_layout Verbatim

    return Fraccion(self.numerador * otro.numerador,
\end_layout

\begin_layout Verbatim

		    self.denominador * otro.denominador)
\end_layout

\begin_layout Verbatim

  
\end_layout

\begin_layout Verbatim

  __rmul__ = __mul__ 
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  #suma de fracciones
\end_layout

\begin_layout Verbatim

  def __add__(self, otro):
\end_layout

\begin_layout Verbatim

    if type(otro) == type(5):
\end_layout

\begin_layout Verbatim

      otro = Fraccion(otro)
\end_layout

\begin_layout Verbatim

    return Fraccion(self.numerador * otro.denominador +
\end_layout

\begin_layout Verbatim

		    self.denominador * otro.numerador,
\end_layout

\begin_layout Verbatim

		    self.denominador * otro.denominador)
\end_layout

\begin_layout Verbatim

  
\end_layout

\begin_layout Verbatim

  __radd__ = __add__
\end_layout

\begin_layout Verbatim

  
\end_layout

\begin_layout Verbatim

  def __init__(self, numerador, denominador=1):      
\end_layout

\begin_layout Verbatim

    g=MDC(numerador,denominador)
\end_layout

\begin_layout Verbatim

    self.numerador=numerador / g
\end_layout

\begin_layout Verbatim

    self.denominador=denominador / g
\end_layout

\begin_layout Verbatim

  
\end_layout

\begin_layout Verbatim

  def __cmp__(self, otro):
\end_layout

\begin_layout Verbatim

    dif = (self.numerador * otro.denominador -
\end_layout

\begin_layout Verbatim

	   otro.numerador * self.denominador)
\end_layout

\begin_layout Verbatim

    return dif
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

def MDC (m,n):
\end_layout

\begin_layout Verbatim

      if m%n==0:
\end_layout

\begin_layout Verbatim

	  return n
\end_layout

\begin_layout Verbatim

      else:
\end_layout

\begin_layout Verbatim

	  return MDC(n,m%n)
\end_layout

\end_inset


\end_layout

\end_body
\end_document
