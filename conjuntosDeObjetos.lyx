#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass book
\use_default_options false
\maintain_unincluded_children false
\language spanish
\language_package none
\inputencoding utf8
\fontencoding default
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 0
\use_package cancel 0
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 0
\use_package mhchem 0
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
LyX source for textbook 
\begin_inset Quotes eld
\end_inset

How to think like a computer scientist'' 
\end_layout

\begin_layout Plain Layout
Copyright (c) 2001 Allen B.
 Downey, Jeffrey Elkner, and Chris Meyers.
\end_layout

\begin_layout Plain Layout
Permission is granted to copy, distribute and/or modify this document under
 the terms of the GNU Free Documentation License, Version 1.1 or any later
 version published by the Free Software Foundation; with the Invariant Sections
 being "Contributor List", with no Front-Cover Texts, and with no Back-Cover
 Texts.
 A copy of the license is included in the section entitled "GNU Free Documentati
on License".
\end_layout

\begin_layout Plain Layout
This distribution includes a file named fdl.lyx that contains the text of
 the GNU Free Documentation License.
 If it is missing, you can obtain it from www.gnu.org or by writing to the
 Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 02111-1307, USA.
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Conjuntos de objetos
\end_layout

\begin_layout Section
Composición
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
composición
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
estructura anidada
\end_layout

\end_inset


\end_layout

\begin_layout Standard
En este momento usted ya ha visto varios ejemplos de composición.
 Uno de los primeros fue una invocación de un método como parte de una expresión.
 Otro ejemplo es la estructura anidada de sentencias; por ejemplo, se puede
 colocar una sentencia 
\family typewriter
if
\family default
 dentro de un ciclo 
\family typewriter
while
\family default
, dentro de otra sentencia 
\family typewriter
if
\family default
.
\end_layout

\begin_layout Standard
Después de observar esto y haber aprendido sobre listas y objetos no debería
 sorprenderse al saber que se pueden crear listas de objetos.
 También pueden crearse objetos que contengan listas (como atributos), listas
 que contengan listas, objetos que contengan objetos, y así sucesivamente.
\end_layout

\begin_layout Standard
En este capítulo y el siguiente, mostraremos algunos ejemplos de estas combinaci
ones, usando objetos 
\family typewriter
Carta
\family default
.
\end_layout

\begin_layout Section
Objeto 
\family typewriter
Carta
\family default
 
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Carta
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
clase!Carta
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Si usted no tiene familiaridad con juegos de cartas este es un buen momento
 para conseguir una baraja, de lo contrario este capítulo no tendrá mucho
 sentido.
 Hay cincuenta y dos cartas en una baraja, cada una pertenece a una de las
 cuatro figuras y uno de los trece valores.
 Las figuras son Picas, Corazones, Diamantes y Tréboles.
 Los valores son As, 2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K.
 Dependiendo del juego, el valor del As puede ser más alto que el de un
 rey o más bajo que 2.
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
valor
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
figura
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Si deseamos definir un nuevo objeto para representar una carta del naipe,
 parece obvio que los atributos deberían ser 
\family typewriter
valor
\family default
 y 
\family typewriter
figura
\family default
.
 No es tan obvio que tipo de dato asignar a estos atributos.
 Una posibilidad consiste en usar cadenas de texto con palabras como 
\family typewriter
Picas
\family default
 para las figuras y 
\family typewriter
Reina
\family default
 para los valores.
 Un problema de esta implementación es que no sería tan fácil comparar cartas
 para ver cuál tiene un valor mayor o una figura mayor.
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
codificar
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
encriptar
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
correspondencia
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Una alternativa consiste en usar enteros para 
\series bold
codificar
\series default
 los valores y las figuras.
 Por 
\begin_inset Quotes eld
\end_inset

codificar
\begin_inset Quotes erd
\end_inset

, no estamos haciendo alusión a encriptar o traducir a un código secreto.
 Lo que un científico de la computación considera 
\begin_inset Quotes eld
\end_inset

codificar
\begin_inset Quotes erd
\end_inset

 es 
\begin_inset Quotes eld
\end_inset

definir una correspondencia entre una secuencia de números y los objetos
 que deseamos representar
\begin_inset Quotes erd
\end_inset

.
 Por ejemplo:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforefig
\end_layout

\end_inset

 
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Picas 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mapsto$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Corazones 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mapsto$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Diamantes 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mapsto$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tréboles 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mapsto$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterfig
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Una característica notable de esta correspondencia es que las figuras aparecen
 en orden decreciente de valor así como los enteros van disminuyendo.
 De esta forma, podemos comparar figuras mediante los enteros que las representa
n.
 Una correspondencia para los valores es bastante sencilla; cada número
 se relaciona con el entero correspondiente, y para las cartas que se representa
n con letras tenemos lo siguiente:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
beforefig
\end_layout

\end_inset

 
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mapsto$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
J 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mapsto$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Q 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mapsto$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
K 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mapsto$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
afterfig
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La razón para usar notación matemática en estas correspondencias es que
 ellas no hacen parte del programa en Python.
 Son parte del diseño, pero nunca aparecen explícitamente en el código fuente.
 La definición de la clase 
\family typewriter
Carta
\family default
 luce así:
\begin_inset listings
inline false
status open

\begin_layout Verbatim

class Carta:
\end_layout

\begin_layout Verbatim

  def __init__(self, figura=0, valor=0):
\end_layout

\begin_layout Verbatim

    self.figura = figura
\end_layout

\begin_layout Verbatim

    self.valor = valor
\end_layout

\end_inset

 Como de costumbre, proporcionamos un método de inicialización que toma
 un parámetro opcional para cada atributo.
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
constructor
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Para crear un objeto que represente el 3 de tréboles, usamos este comando:
\begin_inset listings
inline false
status open

\begin_layout Verbatim

tresTreboles = Carta(0, 3)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El primer argumento, 
\family typewriter
0
\family default
, representa la figura (tréboles).
\end_layout

\begin_layout Section
Atributos de clase y el método 
\family typewriter
__str__
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
atributo de clase
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
atributo! de clase
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Para imprimir objetos 
\family typewriter
Carta
\family default
 en una forma que la gente pueda leer fácilmente, queremos establecer una
 correspondencia entre códigos enteros y palabras.
 Una forma natural de hacerlo es con listas de cadenas de texto.
 Asignamos estas listas a 
\series bold
atributos de clase
\series default
 al principio de la clase:
\begin_inset listings
inline false
status open

\begin_layout Verbatim

class Carta:
\end_layout

\begin_layout Verbatim

  listaFiguras = ["Treboles", "Diamantes", "Corazones", 
\end_layout

\begin_layout Verbatim

  "Picas"]
\end_layout

\begin_layout Verbatim

  listaValores = ["narf", "As", "2", "3", "4", "5", "6", 
\end_layout

\begin_layout Verbatim

  "7","8", "9", "10", "Jota", "Reina", "Rey"]
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  # se omite el metodo init
\end_layout

\begin_layout Verbatim

\end_layout

\begin_layout Verbatim

  def __str__(self):
\end_layout

\begin_layout Verbatim

    return (self.listaFiguras[self.valor] + " de " + 
\end_layout

\begin_layout Verbatim

            self.listaValores[self.figura])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Un atributo de clase se define afuera de los métodos y puede ser accedido
 desde cualquiera de ellos.
\end_layout

\begin_layout Standard
Dentro de 
\family typewriter
__str__
\family default
, podemos usar a 
\family typewriter
listaFiguras
\family default
 y 
\family typewriter
listaValores
\family default
 para establecer una correspondencia entre los valores numéricos de 
\family typewriter
figura
\family default
, 
\family typewriter
valor
\family default
 y los nombres de las cartas.
 La expresión 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
verb+self.listaFiguras[self.figura]+
\end_layout

\end_inset

 significa 
\begin_inset Quotes eld
\end_inset

use el atributo 
\family typewriter
figura
\family default
 del objeto 
\family typewriter
self
\family default
 como índice dentro del atributo de clase 
\family typewriter
listaFiguras
\family default
, esto seleccionará la cadena de texto apropiada
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
La razón para el 
\family typewriter

\begin_inset Quotes eld
\end_inset

narf
\begin_inset Quotes erd
\end_inset


\family default
 en el primer elemento de 
\family typewriter
listaValores
\family default
 consiste en ocupar el elemento cero de la lista que no va a ser usado en
 el programa.
 Los valores válidos son de 1 a 13.
 Este elemento desperdiciado no es necesario, podríamos haber empezado a
 contar desde 0, pero es menos confuso codificar 2 como 2, 3 como 3 ...
 y 13 como 13.
\end_layout

\begin_layout Standard
Con los métodos que tenemos hasta aquí, podemos crear e imprimir cartas:
\begin_inset listings
inline false
status open

\begin_layout Verbatim

>>> c1 = Carta(1, 11)
\end_layout

\begin_layout Verbatim

>>> print c1
\end_layout

\begin_layout Verbatim

Jota de Diamantes
\end_layout

\end_inset

 Los atributos de clase como 
\family typewriter
listaFiguras
\family default
 se comparten por todos los objetos 
\family typewriter
Carta
\family default
.
 La ventaja de esto es que podemos usar cualquier objeto 
\family typewriter
Carta
\family default
 para acceder a ellos:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Verbatim

>>> c2 = Carta(1, 3)
\end_layout

\begin_layout Verbatim

>>> print c2
\end_layout

\begin_layout Verbatim

3 de Diamantes
\end_layout

\begin_layout Verbatim

>>> print c2.listaFiguras[1]
\end_layout

\begin_layout Verbatim

Diamantes
\end_layout

\end_inset

 La desventaja es que si modificamos un atributo de clase, afecta a todas
 las otras instancias de la clase.
 Por ejemplo, si decidimos que 
\begin_inset Quotes eld
\end_inset

Jota de Diamantes
\begin_inset Quotes erd
\end_inset

 debería llamarse 
\begin_inset Quotes eld
\end_inset

Caballero de Rombos rojos,
\begin_inset Quotes erd
\end_inset

 podríamos ejecutar:
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
instancia!objeto
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
objeto instancia
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Verbatim

>>> c1.listaFiguras[1] = "Caballero de Rombos rojos"
\end_layout

\begin_layout Verbatim

>>> print c1
\end_layout

\begin_layout Verbatim

Caballero de Rombos rojos
\end_layout

\end_inset

 El problema es que 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
em
\end_layout

\end_inset

 todos
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 los Diamantes ahora son Rombos rojos:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Verbatim

>>> print c2
\end_layout

\begin_layout Verbatim

3 de Rombos rojos
\end_layout

\end_inset

 Usualmente no es una buena idea modificar los atributos de clase.
\end_layout

\begin_layout Section
Comparando cartas
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "comparecard"

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
operador!condicional
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
operador condicional 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Para los tipos primitivos contamos con los operadores (
\family typewriter
<
\family default
, 
\family typewriter
>
\family default
, 
\family typewriter
==
\family default
, etc.) que determinan cuándo un valor es mayor, menor, mayor o igual, menor
 o igual, o igual al otro.
 Para los tipos definidos por el programador podemos sobrecargar el comportamien
to de los operadores predefinidos proporcionando un método llamado 
\family typewriter
__cmp__
\family default
.
 Por convención, 
\family typewriter
__cmp__
\family default
 toma dos parámetros, 
\family typewriter
self
\family default
 y 
\family typewriter
otro
\family default
, y retorna 1 si el primer objeto es más grande, -1 si el segundo es más
 grande y 0 si son iguales entre si.
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
sobrecargar
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
sobrecarga de operadores
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
orden
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
orden total
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
orden parcial
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Algunos tipos tienen un orden total, lo que quiere decir que cualquier pareja
 de elementos se puede comparar para decidir cuál de ellos es mayor.
 Por ejemplo, los números enteros y los de punto flotante tienen un orden
 total.
 Algunos conjuntos no tienen relación de orden, lo que quiere decir que
 no hay una manera sensata de determinar que un elemento es mayor que otro.
 Por ejemplo, las frutas no tienen una relación de orden, y esta es la razón
 por la que no se pueden comparar manzanas con naranjas.
\end_layout

\begin_layout Standard
El conjunto de cartas tiene un orden parcial, lo que quiere decir que algunas
 veces se pueden comparar elementos, y otras veces no.
 Por ejemplo, el 3 de Picas es mayor que el 2 de picas, y el 3 de Diamantes
 es mayor que el 3 de Picas.
 Pero, ¿que es más alto, el 3 de Picas o el 2 de Diamantes? Uno tiene un
 valor más alto, pero el otro tiene una figura más alta.
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
comparable
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Para lograr comparar las cartas, hay que tomar una decisión sobre la importancia
 del valor y de la figura.
 Para ser honestos, esta decisión es arbitraria.
 Así que tomaremos la opción de determinar qué figura es más importante,
 basándonos en que un mazo de cartas nuevo viene con las Picas (en orden),
 luego los Diamantes, y así sucesivamente.
\end_layout

\begin_layout Standard
Con esta decisión 
\family typewriter
__cmp__
\family default
 queda así:
\begin_inset listings
inline false
status open

\begin_layout Verbatim

def __cmp__(self, otro):
\end_layout

\begin_layout Verbatim

  # chequea las figuras
\end_layout

\begin_layout Verbatim

  if self.figura > otro.figura: return 1
\end_layout

\begin_layout Verbatim

  if self.figura < otro.figura: return -1
\end_layout

\begin_layout Verbatim

  # Si tienen la misma figura...
 
\end_layout

\begin_layout Verbatim

  if self.valor > otro.valor: return 1
\end_layout

\begin_layout Verbatim

  if self.valor < otro.valor: return -1
\end_layout

\begin_layout Verbatim

  # si los valores son iguales...
 hay un empate
\end_layout

\begin_layout Verbatim

  return 0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Con este orden los Ases valen menos que los Dos.
\end_layout

\begin_layout Section
Mazos
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
lista!de objetos
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
objeto!lista de
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
mazo
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ahora que tenemos objetos para representar 
\family typewriter
Carta
\family default
s, el siguiente paso lógico consiste en definir una clase para representar
 un 
\family typewriter
Mazo
\family default
.
 Por supuesto, un mazo (o baraja) está compuesto por cartas, así que cada
 instancia de 
\family typewriter
Mazo
\family default
 contendrá como atributo una lista de cartas.
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
método de inicialización
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
método!de inicialización
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La siguiente es la definición de la clase 
\family typewriter
Mazo
\family default
.
 El método de inicialización crea el atributo 
\family typewriter
cartas
\family default
 y genera el conjunto usual de cincuenta y dos cartas:
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
composición
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
ciclo!anidado
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Verbatim

class Mazo:
\end_layout

\begin_layout Verbatim

  def __init__(self):
\end_layout

\begin_layout Verbatim

    self.cartas = []
\end_layout

\begin_layout Verbatim

    for figura in range(4):
\end_layout

\begin_layout Verbatim

      for valor in range(1, 14):
\end_layout

\begin_layout Verbatim

        self.cartas.append(Carta(figura, valor))
\end_layout

\end_inset

 La forma más sencilla de llenar el mazo consiste en usar un ciclo anidado.
 El ciclo exterior enumera las figuras de 0 a 3.
 El ciclo interno enumera los valores de 1 a 13.
 Como el ciclo exterior itera cuatro veces y el interno itera trece veces,
 el número total de iteraciones es cincuenta y dos (
\begin_inset Formula $4\times13$
\end_inset

).
 Cada iteración crea una nueva instancia de 
\family typewriter
Carta
\family default
 y la pega a la lista 
\family typewriter
cartas
\family default
.
\end_layout

\begin_layout Standard
El método 
\family typewriter
append
\family default
 acepta secuencias mutables como las listas y no acepta tuplas.
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
método append
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
método de lista
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
método!de lista
\end_layout

\end_inset


\end_layout

\begin_layout Section
Imprimiendo el mazo
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "printdeck"

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
imprimir!objeto mazo
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Como de costumbre, cuando definimos un nuevo tipo de objeto, deseamos tener
 un método que imprima su contenido.
 Para imprimir un 
\family typewriter
Mazo
\family default
, recorremos la lista e imprimimos cada objeto 
\family typewriter
Carta
\family default
:
\begin_inset listings
inline false
status open

\begin_layout Verbatim

class Mazo:
\end_layout

\begin_layout Verbatim

  ...
\end_layout

\begin_layout Verbatim

  def imprimirMazo(self):
\end_layout

\begin_layout Verbatim

    for carta in self.cartas:
\end_layout

\begin_layout Verbatim

      print carta
\end_layout

\end_inset


\end_layout

\begin_layout Standard
En este ejemplo y en los que siguen, los puntos suspensivos indican que
 hemos omitido los otros métodos de la clase.
\end_layout

\begin_layout Standard
Otra alternativa a 
\family typewriter
imprimirMazo
\family default
 puede ser escribir un método 
\family typewriter
__str__
\family default
 para la clase 
\family typewriter
Mazo
\family default
.
 La ventaja de 
\family typewriter
__str__
\family default
 radica en su mayor flexibilidad.
 Además de imprimir el contenido del objeto, genera una representación de
 él en una cadena de texto que puede manipularse en otros lugares del programa,
 incluso antes de imprimirse.
\end_layout

\begin_layout Standard
A continuación hay una versión de 
\family typewriter
__str__
\family default
 que retorna una representación de un 
\family typewriter
Mazo
\family default
.
 Para añadir un estilo de cascada, cada carta se imprime un espacio mas
 hacia la derecha que la anterior:
\begin_inset listings
inline false
status open

\begin_layout Verbatim

class Mazo:
\end_layout

\begin_layout Verbatim

  ...
\end_layout

\begin_layout Verbatim

  def __str__(self):
\end_layout

\begin_layout Verbatim

    s = ""
\end_layout

\begin_layout Verbatim

    for i in range(len(self.cartas)):
\end_layout

\begin_layout Verbatim

      s = s + " "*i + str(self.cartas[i]) + "
\backslash
n"
\end_layout

\begin_layout Verbatim

    return s
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Este ejemplo demuestra varios puntos.
 Primero, en vez de recorrer los elementos de la lista 
\family typewriter
self.cartas
\family default
, estamos usando a 
\family typewriter
i
\family default
 como variable de ciclo que lleva la posición de cada elemento en la lista
 de cartas.
\end_layout

\begin_layout Standard
Segundo, estamos usando el operador multiplicación aplicado a un número
 y una cadena, de forma que la expresión 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
verb+" "*i+
\end_layout

\end_inset

 produce un número de espacios igual al valor actual de 
\family typewriter
i
\family default
.
\end_layout

\begin_layout Standard
Tercero, en vez de usar el comando 
\family typewriter
print
\family default
 para realizar la impresión, utilizamos la función 
\family typewriter
str
\family default
.
 Pasar un objeto como argumento a 
\family typewriter
str
\family default
 es equivalente a invocar el método 
\family typewriter
__str__
\family default
 sobre el objeto.
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
acumulador
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finalmente, estamos usando a la variable 
\family typewriter
s
\family default
 como 
\series bold
acumulador
\series default
.
 Inicialmente 
\family typewriter
s
\family default
 es la cadena vacía.
 En cada iteración del ciclo se genera una nueva cadena y se concatena con
 el valor viejo de 
\family typewriter
s
\family default
 para obtener el nuevo valor.
 Cuando el ciclo finaliza, 
\family typewriter
s
\family default
 contiene la representación completa del 
\family typewriter
Mazo
\family default
, que se despliega (parcialmente) así:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Verbatim

>>> mazo = Mazo()
\end_layout

\begin_layout Verbatim

>>> print mazo
\end_layout

\begin_layout Verbatim

As de Picas
\end_layout

\begin_layout Verbatim

 2 de Picas
\end_layout

\begin_layout Verbatim

  3 de Picas
\end_layout

\begin_layout Verbatim

   4 de Picas
\end_layout

\begin_layout Verbatim

    5 de Picas
\end_layout

\begin_layout Verbatim

     6 de Picas
\end_layout

\begin_layout Verbatim

      7 de Picas
\end_layout

\begin_layout Verbatim

       8 de Picas
\end_layout

\begin_layout Verbatim

        9 de Picas
\end_layout

\begin_layout Verbatim

         10 de Picas
\end_layout

\begin_layout Verbatim

          J de Picas
\end_layout

\begin_layout Verbatim

           Reina de Picas
\end_layout

\begin_layout Verbatim

            Rey de Picas
\end_layout

\begin_layout Verbatim

             As de Diamantes
\end_layout

\end_inset

 Aunque el resultado se despliega en 52 líneas, es una sola cadena que contiene
 caracteres nueva linea 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
verb+(
\backslash
n)+
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Barajando el mazo
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
barajar
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Si un mazo se baraja completamente, cualquier carta tiene la misma probabilidad
 de aparecer en cualquier posición, y cualquier posición tiene la misma
 probabilidad de contener a cualquier carta.
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
random
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
randrange
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Para barajar el mazo, usamos la función 
\family typewriter
randrange
\family default
 que pertenece al módulo del sistema 
\family typewriter
random
\family default
.
 
\family typewriter
randrange
\family default
 recibe dos parámetros enteros 
\family typewriter
a
\family default
 y 
\family typewriter
b
\family default
, y se encarga de escoger al azar un valor perteneciente al rango 
\family typewriter
a <= x < b
\family default
.
 Como el límite superior es estrictamente menor que 
\family typewriter
b
\family default
, podemos usar el número de elementos de una lista como el segundo parámetro
 y siempre obtendremos un índice válido como resultado.
 Por ejemplo, esta expresión escoge al azar el índice de una carta en un
 mazo:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Verbatim

random.randrange(0, len(self.cartas))
\end_layout

\end_inset

 Una manera sencilla de barajar el mazo consiste en recorrer todas las cartas
 intercambiando cada una con otra carta escogida al azar.
 Es posible que la carta se intercambie consigo misma, pero esto no causa
 ningún problema.
 De hecho, si prohibiéramos esto, el orden de las cartas no sería tan aleatorio:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Verbatim

class Mazo:
\end_layout

\begin_layout Verbatim

  ...
\end_layout

\begin_layout Verbatim

  def barajar(self):
\end_layout

\begin_layout Verbatim

    import random
\end_layout

\begin_layout Verbatim

    nCartas = len(self.cartas)
\end_layout

\begin_layout Verbatim

    for i in range(nCartas):
\end_layout

\begin_layout Verbatim

      j = random.randrange(i, nCartas)
\end_layout

\begin_layout Verbatim

      self.cartas[i], self.cartas[j] = self.cartas[j], 
\end_layout

\begin_layout Verbatim

                                       self.cartas[i]
\end_layout

\end_inset

 En vez de asumir que hay 52 cartas en el mazo, obtenemos el número de ellas
 a través de la función len y lo almacenamos en la variable 
\family typewriter
nCartas
\family default
.
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
intercambiar
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
asignación de tuplas
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
asignación!de tuplas
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Para cada carta en el mazo, escogemos, aleatoriamente, una carta de las
 que no han sido barajadas todavía.
 Intercambiamos la carta actual (con índice 
\family typewriter
i
\family default
) con la seleccionada (con índice 
\family typewriter
j
\family default
).
 Para intercambiar las cartas usamos asignación de tuplas, como en la sección
 
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tuple assignment"

\end_inset

:
\begin_inset listings
inline false
status open

\begin_layout Verbatim

self.cartas[i], self.cartas[j] = self.cartas[j], 
\end_layout

\begin_layout Verbatim

                                 self.cartas[i]
\end_layout

\end_inset


\end_layout

\begin_layout Section
Eliminando y entregando cartas
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
eliminando cartas
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Otro método que sería útil para la clase 
\family typewriter
Mazo
\family default
 es 
\family typewriter
eliminarCarta
\family default
, que toma una carta como parámetro, la remueve y retorna True si la encontró
 en el mazo o False si no estaba:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Verbatim

class Mazo:
\end_layout

\begin_layout Verbatim

  ...
\end_layout

\begin_layout Verbatim

  def eliminarCarta(self, carta):
\end_layout

\begin_layout Verbatim

    if carta in self.cartas:
\end_layout

\begin_layout Verbatim

      self.cartas.remove(carta)
\end_layout

\begin_layout Verbatim

      return True
\end_layout

\begin_layout Verbatim

    else: 
\end_layout

\begin_layout Verbatim

      return True
\end_layout

\end_inset

 El operador 
\family typewriter
in
\family default
 retorna True si el primer operando se encuentra dentro del segundo, que
 debe ser una secuencia.
 Si el primer operando es un objeto, Python usa el método 
\family typewriter
__cmp__
\family default
 para determinar la igualdad de elementos en la lista.
 Como la función 
\family typewriter
__cmp__
\family default
 en la clase 
\family typewriter
Carta
\family default
 detecta igualdad profunda, el método 
\family typewriter
eliminarCarta
\family default
 detecta igualdad profunda.
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
operador in
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
operador!in
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Para entregar cartas necesitamos eliminar y retornar la primera carta del
 mazo.
 El método 
\family typewriter
pop
\family default
 de las listas proporciona esta funcionalidad:
\begin_inset listings
inline false
status open

\begin_layout Verbatim

class Mazo:
\end_layout

\begin_layout Verbatim

  ...
\end_layout

\begin_layout Verbatim

  def entregarCarta(self):
\end_layout

\begin_layout Verbatim

    return self.cards.pop()
\end_layout

\end_inset

 En realidad, 
\family typewriter
pop
\family default
 elimina la 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
em
\end_layout

\end_inset

 última
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 carta de la lista, así que realmente estamos entreganado cartas por la
 parte inferior, y esto no causa ningún inconveniente.
\end_layout

\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
función booleana
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
función!booleana
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Una operación más que podemos requerir es la función booleana 
\family typewriter
estaVacio
\family default
, que retorna True si el mazo está vacío:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Verbatim

class Mazo:
\end_layout

\begin_layout Verbatim

  ...
\end_layout

\begin_layout Verbatim

  def estaVacio(self):
\end_layout

\begin_layout Verbatim

    return (len(self.cartas) == 0)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Glosario
\end_layout

\begin_layout Description
Codificar: representar un conjunto de valores usando otro conjunto de valores
 estableciendo una correspondencia entre ellos.
\end_layout

\begin_layout Description
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

Atributo de clase:
\end_layout

\end_inset

 variable de una clase que está fuera de todos los métodos.
 Puede ser accedida desde todos los métodos y se comparte por todas las
 instancias de la clase.
\end_layout

\begin_layout Description
Acumulador: variable que se usa para acumular una serie de valores en un
 ciclo.
 Por ejemplo, concatenar varios valores en una cadena o sumarlos.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
codificar
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
atributo de clase
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
atributo! de clase
\end_layout

\end_inset

 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
acumulador
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Section
Ejercicios
\end_layout

\begin_layout Enumerate
Modifique 
\family typewriter
__cmp__
\family default
 para que los Ases tengan mayor puntaje que los reyes.
\end_layout

\begin_layout Enumerate
Reescriba el intercambio que se hace en 
\family typewriter
barajar
\family default
 sin usar asignación de tuplas.
\end_layout

\begin_layout Enumerate
Escriba una clase 
\family typewriter
secuenciaADN
\family default
 que permita representar una secuencia de ADN con un método 
\family typewriter
__init__
\family default
 adecuado.
\end_layout

\begin_layout Enumerate
Agregue cuatro métodos a la clase para averiguar la cantidad de cada nucleotido
 en la secuencia, cuantas A, G, C, T.
\end_layout

\end_body
\end_document
