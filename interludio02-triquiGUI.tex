% LaTeX source for textbook ``How to think like a computer scientist''
% Copyright (c)  2001  Allen B. Downey, Jeffrey Elkner, and Chris Meyers.

% Permission is granted to copy, distribute and/or modify this
% document under the terms of the GNU Free Documentation License,
% Version 1.1  or any later version published by the Free Software
% Foundation; with the Invariant Sections being "Contributor List",
% with no Front-Cover Texts, and with no Back-Cover Texts. A copy of
% the license is included in the section entitled "GNU Free
% Documentation License".

% This distribution includes a file named fdl.tex that contains the text
% of the GNU Free Documentation License.  If it is missing, you can obtain
% it from www.gnu.org or by writing to the Free Software Foundation,
% Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

\chapter{Interludio 2: Triqui con interfaz gráfica}
\index{Triqui}


\section{Motivación}
En el capítulo \ref{cap:inter1:triqui} desarrollamos un juego de triqui completo
para integrar varios conceptos de programación. Ahora, para integrar varios
conceptos de programación con objetos haremos lo mismo, construiremos un triqui
con interfaz gráfica de usuario

El programa utiliza la biblioteca Kivy, que permite realizar interfaces
gráficas que corran en celulares, tablets (con pantallas sensibles al tacto) 
y computadores tradicionales (corriendo MacOS X, Windows y Linux). Hay que 
conseguir el instalador de http://kivy.org.

\section{Ganar y empatar}
Para empezar tomamos el código final del triqui desarrollado en el capítulo \ref{cap:inter1:triqui}
y lo convertimos en un módulo que nos permite verificar si alguien gana el juego o
si hay un empate. El proceso es sencillo: eliminamos todo el código que no tenga que ver con 
verificar quien gana o si hay empate, tomando triqui9.py y resultando en validar.py, un 
módulo con 9 funciones: crear,  ganaDiagonal1,  ganaDiagonal2, ganaFila, ganaHorizontal, ganaColumna,
ganaVertical, gana y empate. Mas adelante utilizaremos este módulo dentro del nuevo programa.

Este es un ejemplo de reutilización de código.
\index{reutilización}

\section{Programación orientada a eventos}
\index{Programación orientada a eventos}

En muchas bibliotecas gráficas como kivy existe un gran ciclo que procesa
los eventos generados a través del teclado, apuntador o la pantalla
sensible al tacto. Este ciclo es infinito, pero se le hace un break
cuando se cierra la ventana de la aplicación.

\index{evento}


El flujo del programa está determinado por lo que haga el usuario con
los elementos gráficos de la pantalla. Kivy procesará cada evento (click,
tecla digitada) de manera predeterminada, por ejemplo cerrar la
ventana hará un break en el gran ciclo.

Además, Kivy se encarga de redibujar partes de la ventana cuando otra
ventana se pase por encima, o cuando se cambie de tamaño.

Nuestro primer programa importa lo que necesita de kivy:

\beforeverb
\begin{verbatim}
# triqui0.py
import kivy
kivy.require('1.8.0')
from kivy.app import App
from kivy.uix.gridlayout import GridLayout

class Triqui(GridLayout):
    def __init__(self, **kwargs):
        super(Triqui, self).__init__(**kwargs)
   

class Programa(App):
    def build(self):
        self.title = 'Triqui'
        return Triqui()

if __name__ == '__main__':
    Programa().run()
\end{verbatim}
\afterverb

El gran ciclo reside en la clase App de Kivy, de la que heredamos la clase
Programa. Cuando arranca el programa, al ejecutar run() se corre este
gran ciclo que procesa eventos.

El método build de programa retorna un objeto Triqui, que es nuestra ventana.
La clase Triqui hereda de GridLayout, una ventana que contiene elementos
en disposición de cuadrícula (como una matriz). El método init de Triqui
llama al médodo init de la clase madre y le pasa una lista con un número
de argumentos variable (**kwargs). 

Por ahora nuestra ventana, el objeto de la clase Triqui está vacío.

\section{Widgets}
Las ventanas suelen tener muchos elementos gráficos como menús, botones, paneles
entre otros. En kivy -- y en muchas otras bibliotecas-- se llaman widgets. Por 
ejemplo, un botón es un tipo de widget que  se define en la clase Button.

Como el flujo de los programas gráficos no está determinado por el programador,
sino por el usuario al interactuar con los widgets de la ventana, el mecanismo
que se utiliza para reaccionar es el de registrar métodos que atiendan a los eventos.

\beforeverb
\begin{verbatim}
# triqui1.py
class Triqui(GridLayout):
    def __init__(self, **kwargs):
        super(Triqui, self).__init__(**kwargs)
        # Agregamos el botón, registrando el método 'boton_presionado'
        self.add_widget(Button(font_size=100, on_press=self.boton_presionado))
    
    # Método que responde a la presión del botón
    def boton_presionado(self, w):
        pass

\end{verbatim}
\afterverb

Los widgets se agregan a una ventana mediante el método add\_widget. Aquí agregamos
un botón y registramos un método que responde al evento de presionarlo. Por ahora 
el método no hace nada.

A continuación, definimos la geometría de la ventana como una matriz de 3 filas 
y 3 columnas en la que cada elemento es un botón. Ahora, en el método boton\_presionado
vamos a mostrar un cuadro de diálogo que muestra un texto sencillo.

\beforeverb
\begin{verbatim}
# triqui2.py
class Triqui(GridLayout):
    def __init__(self, **kwargs):
        super(Triqui, self).__init__(**kwargs)
        # la geometria de la cuadrícula 3x3:
        self.cols = 3
        self.rows = 3
        # son 9 botones:
        for i in range(3):
            for j in range(3):
                self.add_widget(Button(font_size=100, on_press=self.boton_presionado))
        
    def boton_presionado(self, w):
	# Se muestra un mensaje cuando se presionan las casillas
        MostrarMensaje("Titulo","Presionaste una casilla")

\end{verbatim}
\afterverb

MostrarMensaje es una clase que heredamos de PopUp, la clase que tiene kivy para
cuadros de diálogo:

\beforeverb
\begin{verbatim}
# triqui2.py
class MostrarMensaje(Popup): 
    def __init__(self, titulo, mensaje, **kwargs):
        self.size_hint_x = self.size_hint_y = .5
        # Esta ventana solo tiene un título
        self.title = titulo
        super(MostrarMensaje, self).__init__(**kwargs)
        # y un botón que la cierra cuando se le presiona
        self.add_widget(Button(text=mensaje, on_press=lambda x:self.dismiss()))
        self.open()


\end{verbatim}
\afterverb

El cuadro de diálogo tiene un título y un botón que, al ser presionado, cierra
todo el cuadro.

\section{Jugando por turnos}

Como el flujo de ejecución depende de los usuarios, vamos a llevar pista en el 
programa de quien tiene el turno de juego con un atributo en la clase Triqui.
Hay que crear el atributo en el método de inicialización y modificarlo en 
cada jugada. El turno será 'O' para el primer jugador y 'X' para el segundo.

\beforeverb
\begin{verbatim}
# triqui3.py
class Triqui(GridLayout):
    def __init__(self, **kwargs):
        super(Triqui, self).__init__(**kwargs)
        self.cols = 3
        self.rows = 3
        for i in range(3):
            for j in range(3):
                self.add_widget(Button(font_size=100, on_press=self.boton_presionado, text=' '))
        self.turno = 'O'

    def boton_presionado(self, w):
        if w.text != ' ':
            MostrarMensaje('Error!', "Ya se ha jugado en esa casilla!")
            return
        # Ahora, cambia el texto y le da el turno al otro jugador
        if self.turno == 'O':
            w.text =  'O'
            self.turno = 'X'
        else:
            w.text = 'X'
            self.turno = 'O'
\end{verbatim}
\afterverb

Cuando se presiona un botón se verifica si la casilla está vacía para poder jugar en 
ella. Si no es así se cambia el texto del botón y se cambia el turno para el otro 
jugador. Observe que en el método de inicialización de Triqui al texto de todos los 
botones se le asigna un espacio.

 Para evitar la duplicación de código se pasa la lógica de revisar el
 estado del juego a un método llamado revisar, que:
 - si el jugador actual gana, muestra el mensaje y resetea todo
 - si hay empate, muestra el mensaje y resetea todo
 - si nadie gana y no hay empate, se cambia el turno al otro jugador.
 

\beforeverb
\begin{verbatim}
# triqui8.py
\end{verbatim}
\afterverb

\beforeverb
\begin{verbatim}
# triqui8.py
\end{verbatim}
\afterverb

\beforeverb
\begin{verbatim}
# triqui8.py
\end{verbatim}
\afterverb

\beforeverb
\begin{verbatim}
# triqui8.py
\end{verbatim}
\afterverb

\beforeverb
\begin{verbatim}
# triqui8.py
\end{verbatim}
\afterverb

\beforeverb
\begin{verbatim}
# triqui8.py
\end{verbatim}
\afterverb

\beforeverb
\begin{verbatim}
# triqui8.py
\end{verbatim}
\afterverb

\beforeverb
\begin{verbatim}
# triqui8.py
\end{verbatim}
\afterverb

\section{Resumen}

\begin{description}

\item[triqui0.py:] crea una ventana vacía
\item[triqui1.py:] Agrega un botón a la ventana (se ve feo!)
\item[triqui2.py:] Agrega 9 botones para formar el tablero del triqui
\item[triqui3.py:] Permite jugar a los dos jugadores sin ningún chequeo
\item[triqui4.py:] Agrega una clase heredada de Button para llevar fila y columna 
\item[triqui5.py:] Cada vez que se juega se copia el estado de los botones a una matriz
\item[triqui6.py:] Se valida si los jugadores ganan el juego con el código del triqui viejo
	    y se resetea el juego.
\item[triqui7.py:] Se revisa si hay empate, si lo hay, se resetea el juego.
\item[triqui8.py:] Se mejora el código evitando la duplicación.
\end{description}

\section{Glosario}

\begin{description}

\item[def:] texto


\index{def}


\end{description}
